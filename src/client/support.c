/***** tell emacs we use -*- c++ -*- style comments *****
 * $Revision: 1.81 $ $Author: brennan $ $Date: 2007/05/30 19:10:31 $
 *
 * COPYRIGHT 2004, Carnegie Mellon University 
 *
 * PROJECT: Exploration Robotics (Life in the Atacama)
 *
 * MODULE:
 *
 * FILE: microraptor/client/support.c
 *
 * DESCRIPTION:
 *
 ********************************************************/
/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 * Eh, we're done using Glade directly now, so I stuck some support functions
 *  in here. -Brennan
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#include <map>
#include <vector>
#include <string>

#include <gtk/gtk.h>
#include <gdk/gdkx.h>

#include "support.h"
#include "processWidget.h"
#include "imageHeaders.h"
#include "callbacks.h"
#include "RCL.h"
#include "mrCommonDefs.h"
#include "processStatus.h"
#include "clientIO.h"
#include "mrCommonTime.h"
#include "interface.h"

using namespace std;

// Declared in claw.c with the rest of the globals
extern map<string, vector<string> > persistentStdinCommandHistory_g;
extern map<string, vector<string> > persistentRegexpHistory_g;
extern string historyFilename_g;

/* This is an internally used function to check if a pixmap file exists. */
static gchar* check_file_exists        (const gchar     *directory,
                                        const gchar     *filename);

/* This is an internally used function to create pixmaps. */
static GtkWidget* create_dummy_pixmap  (GtkWidget       *widget);

size_t ProcessDataHash(ProcessData pd) {
  size_t retval = 0;
  if(pd.procName != NULL && strlen(pd.procName) >= 3) {
    for(int i = 0; i < 3; i++) {
      retval += pd.procName[i];
    }
  }
  if(pd.machName != NULL && strlen(pd.machName) >= 3) {
    for(int i = 0; i < 3; i++) {
      retval += pd.machName[i];
    }
  }
  return retval;
}

bool ProcessDataEqual(ProcessData a, ProcessData b) {
  if(strcmp(a.procName, b.procName) == 0
     && strcmp(a.machName, b.machName) == 0) {
    return true;
  } else {
    return false;
  }
}

/* Return 0 if they're the same.  Note that you have to set the user data
   of a row before you can search for it. :)  There doesn't appear to be
   a good way to search for a row by what's displayed.
   These are now pointers to EntryData's.
*/
gint        
rowCompareFunc(gconstpointer a,
               gconstpointer b)
{
  EntryData *ae;
  EntryData *be;

  if((a == NULL || b == NULL) && (a != b)) return 1;
  if(a == NULL && b == NULL) return 0;

  ae = (EntryData*) a;
  be = (EntryData*) b;

  if((ae->label == NULL || be->label == NULL) && (ae->label != be->label)) return 1;
  if(ae->label == NULL && be->label == NULL) return 0;

  return strcmp(ae->label, be->label);
}

// Returns true if n1 and n2 live at the same level of our processTree hierarchy
bool are_nodetypes_same_level(enum nodeType n1, enum nodeType n2)
{
  switch(n1) {
  case PROCESS_TOP_NODE:
  case SWALLOWED_TOP_NODE:
  case GROUP_TOP_NODE:
    return n2 & (PROCESS_TOP_NODE | SWALLOWED_TOP_NODE | GROUP_TOP_NODE);
    break;
  case PROCESS_NODE:      return n2 == PROCESS_NODE; break;
  case SWALLOWED_NODE:    return n2 == SWALLOWED_NODE; break;
  case GROUP_NODE:        return n2 == GROUP_NODE; break;
  case GROUP_MEMBER_NODE: return n2 == GROUP_MEMBER_NODE; break;
  case UNKNOWN_NODE:      return n2 == UNKNOWN_NODE; break;
  default: return false; // This shouldn't happen...
  }
}

/* clist :	The GtkCList that is affected.
   ptr1 :	A gconstpointer to the first node to compare.
   ptr2 :	A gconstpointer to the second node to compare.
   Returns :	0 if the nodes are equal, less than 0 if the first node should come 
                before the second, and greater than 1 if the second come before the first.
                (Note: the "greater than 1" phrase is from the GTK documentation...)
   Assumes:     ptr1 and ptr2 are in reality GtkCTreeNode*'s
   AHHH-HAH!  THEY'RE ACTUALLY GTK_CLIST_ROW'S
*/
gint treeCompareFunc(GtkCList *clist, gconstpointer ptr1, gconstpointer ptr2)
{
  enum nodeType n1Type;
  enum nodeType n2Type;
  char* n1Text;
  char* n2Text;  
  GtkCTreeNode* n1 = gtk_ctree_find_by_row_data(GTK_CTREE(clist), 
                                                NULL,
                                                ((GtkCListRow*) ptr1)->data);
  GtkCTreeNode* n2 =  gtk_ctree_find_by_row_data(GTK_CTREE(clist), 
                                                NULL,
                                                ((GtkCListRow*) ptr2)->data);  

  // Degenerate cases
  if((n1 == NULL) && (n2 != NULL)) return 2;
  if((n2 == NULL) && (n1 != NULL)) return -2;
  if(n1 == NULL && n2 == NULL) return 0;

  // Pull out the process / daemon / group / whatever name
  gtk_ctree_get_node_info(GTK_CTREE(clist), n1, &n1Text,
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL);
  gtk_ctree_get_node_info(GTK_CTREE(clist), n2, &n2Text,
                          NULL, NULL, NULL, NULL, NULL, NULL, NULL);

  // Okay, the real work gets done here.
  n1Type = get_nodetype(GTK_CTREE(clist), n1);
  n2Type = get_nodetype(GTK_CTREE(clist), n2);


  // If we're not from the same level of the tree, we have badness!
  if(!are_nodetypes_same_level(n1Type, n2Type)) {
    string toBuf = "Gaaahh!  Incompatible node types in treeCompareFunc!  Death!\n";
    toBuf += "   (n1: ";
    toBuf += stringize_nodetypes(n1Type, 0);
    toBuf += ", n2: ";
    toBuf += stringize_nodetypes(n2Type, 0);
    toBuf += "\n";
    print_to_common_buffer(toBuf.c_str(), ERROR_COL);
    // Arbitrary ordering
    if(n1Type < n2Type)
      return -2;
    else
      return 2;
  }

  // Okay, they're the same type.  We sort differently based on the type:
  // User-chosen sorting
  if(n1Type & (PROCESS_TOP_NODE | SWALLOWED_TOP_NODE | GROUP_TOP_NODE)) {
    // Alphabetical sort within types
    if(n1Type == n2Type) {
      return 2*strcmp(n1Text, n2Text);
    }

    // Swallowed is always last
    if(n1Type == SWALLOWED_TOP_NODE && n2Type != SWALLOWED_TOP_NODE) return -2;
    if(n2Type == SWALLOWED_TOP_NODE && n1Type != SWALLOWED_TOP_NODE) return 2;
    
    // PROCESS_TOP_NODE < GROUP_TOP_NODE; use this to our advantage.
    if(prefs_get_view_mode() == DAEMONS_FIRST) {      
      return n1Type < n2Type ? -2 : 2;
    } else {
      return n1Type < n2Type ? 2 : -2;
    }
  } 
  // Alphabetical; really, we shouldn't be sorting these
  else {
    return 2*strcmp(n1Text, n2Text);
  }
}

string stringize_nodetypes(enum nodeType nt, int tablev)
{
  string tabs = "";
  string retstr = "";
  bool ptd = false;
  for(int i = 0; i < tablev; i++) tabs += "\t";
  if(nt & PROCESS_TOP_NODE) {   retstr += (ptd ? ", " : tabs); retstr += "Process top node";   ptd = true; }
  if(nt & PROCESS_NODE) {       retstr += (ptd ? ", " : tabs); retstr += "Process node";       ptd = true; }
  if(nt & SWALLOWED_TOP_NODE) { retstr += (ptd ? ", " : tabs); retstr += "Swallowed top node"; ptd = true; }
  if(nt & SWALLOWED_NODE) {     retstr += (ptd ? ", " : tabs); retstr += "Swallowed node";     ptd = true; }
  if(nt & GROUP_TOP_NODE) {     retstr += (ptd ? ", " : tabs); retstr += "Group top node";     ptd = true; }
  if(nt & GROUP_NODE) {         retstr += (ptd ? ", " : tabs); retstr += "Group node";         ptd = true; }
  if(nt & GROUP_MEMBER_NODE) {  retstr += (ptd ? ", " : tabs); retstr += "Group member node";  ptd = true; }
  if(nt & UNKNOWN_NODE) {       retstr += (ptd ? ", " : tabs); retstr += "Unknown node";       ptd = true; }
  return retstr;
}

void print_nodetypes_inline(enum nodeType nt, int tablev)
{
  cerr << stringize_nodetypes(nt, tablev);
}

void
print_nodetypes(enum nodeType nt, int tablev)
{
  cerr << "Node type(s):" << endl;
  print_nodetypes_inline(nt, tablev);
  cerr << endl;
}


rcl::exp load_local_config(const string& config_file_name) {
  rcl::exp ret;
  try {
    ret = rcl::loadConfigFile(config_file_name);
  } catch (MRException err) {
    if(HeadDino_g != NULL) {
      print_to_common_buffer(err.text.c_str(), ERROR_COL);
    } else {
      string msg = "Could not load config file '";
      msg += config_file_name;
      msg += "'.\nError text:\n";
      msg += err.text;
      createAndShow_messageDialog(msg, true);
    }
  }
  return ret;
}

void get_config(rcl::exp& e) { e = local_config_g; }

GtkWidget*
lookup_widget                          (GtkWidget       *widget,
                                        const gchar     *widget_name)
{
  GtkWidget *parent, *found_widget;

  for (;;)
    {
      if (GTK_IS_MENU (widget))
        parent = gtk_menu_get_attach_widget (GTK_MENU (widget));
      else
        parent = widget->parent;
      if (parent == NULL)
        break;
      widget = parent;
    }

  found_widget = (GtkWidget*) gtk_object_get_data (GTK_OBJECT (widget),
                                                   widget_name);
  if (!found_widget)
    g_warning ("Widget not found: %s", widget_name);
  return found_widget;
}

/* This is a dummy pixmap we use when a pixmap can't be found. */
static char *dummy_pixmap_xpm[] = {
/* columns rows colors chars-per-pixel */
  (char *)"1 1 1 1",
  (char *)"  c None",
/* pixels */
  (char *)" "
};

/* This is an internally used function to create pixmaps. */
static GtkWidget*
create_dummy_pixmap                    (GtkWidget       *widget)
{
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  GtkWidget *pixmap;

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm_d (NULL, colormap, &mask,
                                                     NULL, dummy_pixmap_xpm);
  if (gdkpixmap == NULL)
    g_error ("Couldn't create replacement pixmap.");
  pixmap = gtk_pixmap_new (gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
  return pixmap;
}

static GList *pixmaps_directories = NULL;

/* Use this function to set the directory containing installed pixmaps. */
void
add_pixmap_directory                   (const gchar     *directory)
{
  pixmaps_directories = g_list_prepend (pixmaps_directories,
                                        g_strdup (directory));
}

/* This is an internally used function to create pixmaps. */
GtkWidget*
create_pixmap                          (GtkWidget       *widget,
                                        const gchar     *filename)
{
  gchar *found_filename = NULL;
  GdkColormap *colormap;
  GdkPixmap *gdkpixmap;
  GdkBitmap *mask;
  GtkWidget *pixmap;
  GList *elem;

  if (!filename || !filename[0])
      return create_dummy_pixmap (widget);

  /* We first try any pixmaps directories set by the application. */
  elem = pixmaps_directories;
  while (elem)
    {
      found_filename = check_file_exists ((gchar*)elem->data, filename);
      if (found_filename)
        break;
      elem = elem->next;
    }

  /* If we haven't found the pixmap, try the source directory. */
  if (!found_filename)
    {
      found_filename = check_file_exists ("../pixmaps", filename);
    }

  if (!found_filename)
    {
      g_warning (_("Couldn't find pixmap file: %s"), filename);
      return create_dummy_pixmap (widget);
    }

  colormap = gtk_widget_get_colormap (widget);
  gdkpixmap = gdk_pixmap_colormap_create_from_xpm (NULL, colormap, &mask,
                                                   NULL, found_filename);
  if (gdkpixmap == NULL)
    {
      g_warning (_("Error loading pixmap file: %s"), found_filename);
      g_free (found_filename);
      return create_dummy_pixmap (widget);
    }
  g_free (found_filename);
  pixmap = gtk_pixmap_new (gdkpixmap, mask);
  gdk_pixmap_unref (gdkpixmap);
  gdk_bitmap_unref (mask);
  return pixmap;
}

/* Add a taskbar icon for the window pointed to by the passed widget.
 * NOTE: This must be called *after* the window is
 * gtk_widget_show()'n */
void
add_taskbar_icon                       (GtkWidget       *windowWid,
                                        const gchar     **xpm)
{
  // Create mini-icon pixmap (for taskbar)
  GdkBitmap* iconMask = NULL; // Not used
  GtkStyle *style = gtk_widget_get_style( windowWid ); // Not sure if we need this
  GdkPixmap* iconPixmap = gdk_pixmap_create_from_xpm_d( windowWid->window, &iconMask,
                                                        &style->bg[GTK_STATE_NORMAL],
                                                        (gchar **)xpm );
  gdk_window_set_icon(windowWid->window,
                      NULL, iconPixmap, iconMask);
}

/* This is an internally used function to check if a pixmap file exists. */
static gchar*
check_file_exists                      (const gchar     *directory,
                                        const gchar     *filename)
{
  gchar *full_filename;
  struct stat s;
  gint status;

  full_filename = (gchar*) g_malloc (strlen (directory) + 1
                                     + strlen (filename) + 1);
  strcpy (full_filename, directory);
  strcat (full_filename, G_DIR_SEPARATOR_S);
  strcat (full_filename, filename);

  status = stat (full_filename, &s);
  if (status == 0 && S_ISREG (s.st_mode))
    return full_filename;
  g_free (full_filename);
  return NULL;
}

int
add_group_display(GtkCTreeNode* grpNode)
{
  cerr << "Entering add group display" << endl;
  if(grpNode == NULL) return 0;

  GList* cList = NULL;
  GtkWidget* pwPar;
  SwitchableChildDataAug* scda;  
  GtkCTree* processTree;
  GtkCTreeNode* realNode;
  EntryData* ed;
  EntryDataAug* eda;
  GtkTable* table;
  GtkLabel* label;
  GtkNotebook   *nb;
  GtkCTreeNode* grpMem;
  GtkScrolledWindow* scrollWin;
  char* labelText;
  char* machName;
  char* status;
  ProcessData pd;
  int numMembers = 0;
  int row;

  processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  
  // Build notebook page label
  if((ed = (EntryData*) gtk_ctree_node_get_row_data(processTree, grpNode)) == NULL
     || ed->label == NULL){
    label = GTK_LABEL(gtk_label_new("Unnamed Group"));
  } else {
    label = GTK_LABEL(gtk_label_new(ed->label));
  }
  gtk_label_get(label, &labelText);


  // Check if we've viewed this group yet
  if(tab_exists(string(labelText)))
    return 0;

  // Build list of children
  for(grpMem = GTK_CTREE_ROW(grpNode)->children;
      grpMem != NULL;
      grpMem = GTK_CTREE_ROW(grpMem)->sibling, numMembers++) {
    eda = (EntryDataAug*) gtk_ctree_node_get_row_data(processTree, grpMem);
    if(eda == NULL) continue;
    realNode = eda->realNode;
    if(realNode == NULL) continue;  
    ed = (EntryData*) gtk_ctree_node_get_row_data(processTree, realNode);
    if(ed == NULL) continue;
    // Grab machName; we need it for subscribing and creating
    gtk_ctree_get_node_info(processTree, GTK_CTREE_ROW(realNode)->parent, &machName,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    gtk_ctree_node_get_text(processTree, realNode, 1, &status);
    pd.machName = machName;
    pd.procName = ed->label;
    pd.status = status;
    // If the process is not yet viewed, view the sucker
    if(ed->pw == NULL) {
      //cerr << "Process not yet viewed; creating view." << endl;
      eda->pw = ed->pw = GTK_WIDGET(processWidget_new(ed->label, status, machName));      
      // Fix the buttons
      // Update the two row entries
      gtk_ctree_node_set_row_data(processTree, grpMem, eda);
      gtk_ctree_node_set_row_data(processTree, realNode, ed);
      if(!is_accepting_input(status)) {
        toggle_stdin_entry(ed->label, machName, false);
      }
      gtk_widget_show(GTK_WIDGET(ed->pw));
      // Auto-subscribe
      sub_process(machName, ed->label, prefs_get_back_history_length());
    }

    pwPar = gtk_viewport_new(NULL, NULL);
    scda = new SwitchableChildDataAug();
    scda->parent = pwPar;
    scda->switchedChild = GTK_WIDGET(ed->pw);  
    scda->grpMemNode = grpMem;
    cList = g_list_append(cList, scda);
    PROCESSWIDGET(ed->pw)->viewers->insert(labelText);

    //cerr << "calling pwbs: add group display" << endl;
    processWidget_button_showandtell(eda->pw, &pd, TRUE_TB);

    gtk_widget_show(scda->parent);    
  }
  
  // Create a table
  table = GTK_TABLE(gtk_table_new(numMembers, 1, FALSE));

  // Attach all processWidget parents
  row = 0;
  FOR_GLIST(walker, cList) {
    gtk_table_attach(table, ((SwitchableChildData*) walker->data)->parent, 
                      0, 1, row, row+1,
                     (GtkAttachOptions) (GTK_FILL | GTK_EXPAND), 
                     (GtkAttachOptions) (GTK_FILL | GTK_EXPAND),
                     0, 0);    
    row++;
  }
  gtk_widget_show(GTK_WIDGET(table));

  // Create the scrolled window for the table to live in
  scrollWin = GTK_SCROLLED_WINDOW(gtk_scrolled_window_new (NULL, NULL));
  gtk_widget_ref (GTK_WIDGET(scrollWin));
  gtk_object_set_data_full (GTK_OBJECT (HeadDino_g), "scrollWin", scrollWin,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (GTK_WIDGET(scrollWin));
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrollWin), 
                                 GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scrollWin), GTK_WIDGET(table));

  // Store reference list in tab label
  gtk_object_set_user_data(GTK_OBJECT(label), cList);
  gtk_widget_show(GTK_WIDGET(label));

  // Add notebook page
  // Find the notebook
  nb = GTK_NOTEBOOK(lookup_widget(HeadDino_g, "notebook1"));
  
  gtk_notebook_append_page(nb, GTK_WIDGET(scrollWin), GTK_WIDGET(label));
  gtk_widget_show(GTK_WIDGET(nb));
  
  cerr << "Leaving add group display" << endl;
  return 1;
}

void
remove_group_display (const char* grpName)
{
  GtkWidget* tabKid;
  GtkWidget* label;
  char* labelText;
  GtkNotebook* nb = GTK_NOTEBOOK(lookup_widget(HeadDino_g, "notebook1"));
  GList* list;
  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  ProcessWidget* pw;
  SwitchableChildDataAug* scda;

  if(grpName == NULL) return;
  tabKid = get_child_of_tab(string(grpName));
  if(tabKid == NULL) return;

  // Get reference list
  label = gtk_notebook_get_tab_label(nb, tabKid);
  list = (GList*) gtk_object_get_user_data(GTK_OBJECT(label));
  gtk_label_get(GTK_LABEL(label), &labelText);

  // Remove each from its viewed set
  // This is a mess... there should be a cleaner way to structure this.
  FOR_GLIST(walker, list) {
    if(walker->data == NULL) continue;
    scda = (SwitchableChildDataAug*) walker->data;
    pw = PROCESSWIDGET(scda->switchedChild);
    if(pw == NULL || pw->viewers == NULL) continue;
    pw->viewers->erase(string(labelText));
    // If viewed set is of size zero, null processWidget entries
    if(pw->viewers->size() <= 0) {

      // Store any stdin / regexp entries that have been made
      processWidget_saveHistories(pw);

      if(scda->grpMemNode != NULL) {
        EntryDataAug* eda = (EntryDataAug*) gtk_ctree_node_get_row_data(processTree, scda->grpMemNode);
        if(eda != NULL && eda->realNode != NULL) {
          ProcessData pd;
          init_process_data(&pd);
          fill_process_data_from_process_widget(&pd, pw);
          EntryData* ed = (EntryData*) gtk_ctree_node_get_row_data(processTree, eda->realNode);
          ed->pw = eda->pw = NULL;
          // Unsubscribe from output
          unsub_process(pd.machName, pd.procName);
          // Null pointers in processTree
          gtk_ctree_node_set_row_data(processTree, scda->grpMemNode, eda);
          gtk_ctree_node_set_row_data(processTree, eda->realNode, ed);
        } else {
          string msg = "WARNING: Unable to clean up after group ";
          msg += labelText;
          msg += "! (eda problems)";
          print_to_common_buffer(msg.c_str(), WARNING_COL);
        }
      } else {
        string msg = "WARNING: Unable to clean up after group ";
        msg += labelText;
        msg += "! (treeNode null)";
        print_to_common_buffer(msg.c_str(), WARNING_COL);
      }
      delete pw->viewers;
      pw->viewers = NULL;
    }
  }
  // Remove notebook page
  gtk_notebook_remove_page(nb, gtk_notebook_page_num(nb, tabKid));
}

int
add_process_display (GtkWidget* topWid, const char *machName, const char *procName, const char *status)
{
  ProcessWidget *newProcess = NULL;
  GtkTable      *processTable;
  GtkTableChild *table_child;
  GtkCTree      *processTree;
  GtkNotebook   *nb;
  GtkLabel      *newLabel;
  GList *list;
  ProcessData    pd;
  int** freelist; /* m rows by n columns of potential table spots */
  int i = 0, j = 0;
  int freeI = -1, freeJ = -1;
  char* compositeName;
  //char* searchName;
  string idleStr = "Idle: ";
  GtkCTreeNode *targNode;
  set<string>* viewed;
  bool alreadyViewed = false;
  init_process_data(&pd);

  /* Build composite name; remember to free this below :) */
  // Composite name is now just the process name
  // DUPEDPROCESSFIXME
  compositeName = strdup(procName);
  /*compositeName = (char*) malloc(sizeof(char) * (strlen(procName) + strlen(machName) + 4));
  strcpy(compositeName, procName);
  strcat(compositeName, " @ ");
  strcat(compositeName, machName);  
  */

  processTree = GTK_CTREE(lookup_widget(topWid, "ProcessTree"));

  // We only want the process node, not a group member
  targNode = get_node_from_procname(procName);

  if(targNode != NULL) {
    EntryData* curRowData = (EntryData*) gtk_ctree_node_get_row_data(processTree, targNode);
    if(curRowData != NULL 
       && curRowData->pw != NULL) {
      viewed = PROCESSWIDGET(curRowData->pw)->viewers;
      if(viewed->find(string(compositeName)) != viewed->end()) {
        free(compositeName);
        return 0;
      } else {
        alreadyViewed = true;
      }
    }
  }

  /* Grab the idle function */
  idleStr += get_idle_from_processtree(procName, machName);

  /* Find next free spot in table */
  processTable = GTK_TABLE(lookup_widget(topWid, "ProcessTable"));

  /* How many rows & columns are there?  malloc space appropriately */
  freelist = (int**) malloc(processTable->nrows * sizeof(int *));
  if(freelist == NULL) {
    fprintf(stderr, "Not enough memory to allocate freelist space; unable to add viewable process.\n");
    return 0;
  }
  for(i = 0; i < processTable->nrows; i++) {
    freelist[i] = (int*) malloc( processTable->ncols * sizeof(int));
    if(freelist[i] == NULL) {
      fprintf(stderr, "Not enough memory to allocate freelist space; unable to add viewable process.\n");
      return 0; /* Memory leak */
    }
    for(j = 0; j < processTable->ncols; j++) { freelist[i][j] = 1; }
  }
  /* Okay, done malloc'ing space and init'ing freelist*/

  /* Loop through all children, marking space as free or not.
     Simultaneously, check to make sure we're not double-inserting.
  */
  for (list = processTable->children; list; list = list->next) {
    table_child = (GtkTableChild*) list->data;   
    if(table_child == NULL) continue;
    
    /* We assume each child is only taking up one grid cell. 
       This is reasonable since the user can only add to the table
       via this method. */
    freelist[table_child->top_attach][table_child->left_attach] = 0;
  }

  /* Find the first free spot */
  for(i = 0; i < processTable->nrows; i++) {
    for(j = 0; j < processTable->ncols; j++) {
      if(freelist[i][j]) { freeI = i; freeJ = j; break; }
    }
    if(freeI != -1 && freeJ != -1) break;
  }

  /* Clean up freelist memory */
  for(i = 0; i < processTable->nrows; i++) { free(freelist[i]); }
  free(freelist);

  /* If it's full, add a row */
  if(freeI == -1 || freeJ == -1) {
    /* For now, just stick with one row;
       FILLEMIN: FIXME: if the window is wide enough and there are enough processes,
       add columns
    */
    gtk_table_resize(processTable, processTable->nrows + 1, 1);
    freeI = processTable->nrows - 1;
    freeJ = 0; /* Store in the first element of the new row */
  }

  // Dup's memory
  fill_process_data(&pd, procName, machName, status);

  /* Find the appropriate row */
  EntryData ed;
  EntryData* edCur;
  SwitchableChildData* scd;
  GtkCTreeNode* curRowNode;
  
  // Find machine first
  ed.label = (char*) machName;
  curRowNode = gtk_ctree_find_by_row_data_custom(processTree, NULL, &ed, rowCompareFunc);
  if(curRowNode == NULL) { 
    cerr << "Gah!  Couldn't find machine node \"" << machName << "\"!" << endl;
    return 0;
  }
  // Now find the process under the machine
  ed.label = (char*) procName;
  curRowNode = gtk_ctree_find_by_row_data_custom(processTree, curRowNode, &ed, rowCompareFunc);
  if(curRowNode == NULL) { 
    cerr << "Gah!  Couldn't find process node \"" << procName << "\"!" << endl;
    return 0;
  }
  edCur = (EntryData*) gtk_ctree_node_get_row_data(processTree, curRowNode);
  if(edCur == NULL) cerr << "Blast! edCur is NULL!" << endl;

  /* Find the notebook */
  nb = GTK_NOTEBOOK(lookup_widget(topWid, "notebook1"));

  if(!alreadyViewed) {
    if(edCur->pw != NULL) print_to_common_buffer("ERROR: inconsistent state (alreadyViewed (f) vs. edCur->pw (not null)).", ERROR_COL);
    /* Add a process display group of widgets to the table */
    newProcess = PROCESSWIDGET(processWidget_new(procName, status, machName));

    /* Store the widget pointer for later */
    edCur->pw = GTK_WIDGET(newProcess);
  } else {
    // edCur->pw should be non-null
    if(edCur->pw == NULL) print_to_common_buffer("ERROR: inconsistent state (alreadyViewed (t) vs. edCur->pw (null)).", ERROR_COL);
  }
  //cerr << "Setting row data 1: " << edCur->pw << endl;
  gtk_ctree_node_set_row_data(processTree, curRowNode, edCur);

  GtkWidget* pwPar = gtk_viewport_new(NULL, NULL);
  scd = new SwitchableChildData();
  scd->parent = pwPar;
  scd->switchedChild = edCur->pw;
  // Only add if we don't have a parent
  if(GTK_WIDGET(edCur->pw)->parent == NULL) {
    gtk_container_add(GTK_CONTAINER(pwPar), edCur->pw);
  }
  gtk_widget_show(pwPar);
  /* Store the widget & parent pointers in GList associated with this page's label 
     And yes, I realize process is misspelled. Point for inertia. :)
   */
  char *overviewLabelText;
  GtkWidget* overviewLabel = gtk_notebook_get_tab_label(nb, 
                                                        lookup_widget(topWid, 
                                                                      "proccessTableScrolledWindow"));
  gtk_label_get(GTK_LABEL(overviewLabel), &overviewLabelText);

  if(overviewLabel == NULL) cerr << "Adding: Ah, crud! Overview label is null!  Badness!" << endl;
  else {
    GList* overviewList = g_list_append( (GList*) gtk_object_get_user_data(GTK_OBJECT(overviewLabel)), scd);
    gtk_object_set_user_data(GTK_OBJECT(overviewLabel), overviewList);
  }

  /* Attach the sucker to the table */
  gtk_table_attach(processTable, pwPar, freeJ, freeJ+1, freeI, freeI+1,
                   (GtkAttachOptions) (GTK_FILL | GTK_EXPAND), 
                   (GtkAttachOptions) (GTK_FILL | GTK_EXPAND),
                   0, 0);
  gtk_label_set_text(GTK_LABEL(PROCESSWIDGET(edCur->pw)->ProcessLastStdoutLabel), idleStr.c_str());
  //cerr << "calling pwbs: add process display" << endl;
  processWidget_button_showandtell(edCur->pw, &pd);
  gtk_widget_show(edCur->pw);
  gtk_widget_show(pwPar);
  PROCESSWIDGET(edCur->pw)->viewers->insert(string(overviewLabelText));

  /* Create a label for the new tab; compositeName built above */
  newLabel = GTK_LABEL(gtk_label_new(compositeName));
  /* Name it, to allow the resources file to affect its look-and-feel */
  gtk_widget_set_name(GTK_WIDGET(newLabel), "tab_label");
  /* Add the reference list to the tab's label */
  GList* tabList = NULL;
  GtkWidget* pwPar2 = gtk_viewport_new(NULL, NULL);
  GTK_WIDGET_UNSET_FLAGS (pwPar2, GTK_CAN_FOCUS);
  SwitchableChildData* scd2 = new SwitchableChildData();
  scd2->parent = pwPar2;
  scd2->switchedChild = edCur->pw;
  tabList = g_list_append(tabList, scd2);
  gtk_object_set_user_data(GTK_OBJECT(newLabel), tabList);
  /* Don't actually add the process to the bin; that'll happen on switch */

  /* Add a tab to the notebook, simultaneously adding the processWidget */
  gtk_notebook_append_page(nb, pwPar2, GTK_WIDGET(newLabel));
  gtk_widget_show(pwPar2);
  PROCESSWIDGET(edCur->pw)->viewers->insert(compositeName);

  gtk_widget_show(GTK_WIDGET(nb));

  free(compositeName);
  free_process_data_members(&pd);

  if(!is_accepting_input(status)) {
    toggle_stdin_entry(procName, machName, false);
  }

  if(!alreadyViewed) {
    /* Implicit subscribe, if we have the requisite data 
       and are not currently viewing it.
    */
    sub_process(machName, procName, prefs_get_back_history_length());
  }

  return 1;
}

int
remove_process_display (GtkWidget* topWid, const char *machName, const char *procName)
{
  //EntryData     targRowData;
  GtkCTreeNode  *targNode;
  GtkCTree      *processTree;
  EntryData     *curRowData;
  GtkTable      *processTable;
  //GtkTableChild *table_child;
  GtkNotebook   *nb;
  GList         *list;
  char          *compositeName;
  char          *searchName;
  int           i;

  // Find stuff we'll need
  processTable = GTK_TABLE(lookup_widget(topWid, "ProcessTable"));
  processTree = GTK_CTREE(lookup_widget(topWid, "ProcessTree"));
  nb = GTK_NOTEBOOK(lookup_widget(topWid, "notebook1"));

  // Build composite name
  // This is now just the process name; we'll need to change this if
  //  we ever allow multiple processes with the same name
  // DUPEDPROCESSFIXME
  compositeName = strdup(procName);
  /*
  compositeName = (char*) malloc(sizeof(char) * (strlen(procName) + strlen(machName) + 4));
  strcpy(compositeName, procName);
  strcat(compositeName, " @ ");
  strcat(compositeName, machName);  
  */

  // Find the ProcessWidget 
  //targRowData.label = (char*) procName;  
  //targNode = gtk_ctree_find_by_row_data_custom(processTree, NULL, &targRowData, rowCompareFunc);
  targNode = get_node_from_procname(procName);
  if(targNode == NULL) { free(compositeName); return 0; }
  curRowData = (EntryData*) gtk_ctree_node_get_row_data(processTree, targNode);

  if(curRowData == NULL) {
    cerr << "Error with curRowData in remove_process_display" << endl;
    free(compositeName); 
    return 0;
  }
  // We just haven't been viewed yet
  if(curRowData->pw == NULL) {
    free(compositeName); 
    return 1;
  }
  // Okay, we now have the processWidget pointer.

  // Store any stdin / regexp entries that have been made
  processWidget_saveHistories(PROCESSWIDGET (curRowData->pw));

  // First, reset the last viewed timestamp in subscriptions, so we
  // refill the buffer if we re-view the process.
  ProcessData pd;
  // Ah, the joys of the STL.
  hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>::iterator sit;        

  init_process_data(&pd);
  fill_process_data_from_process_widget(&pd, PROCESSWIDGET (curRowData->pw));
  sit = subscriptions_g->find(pd);
  if(sit != subscriptions_g->end()) {
    (*sit).second.second = microraptor::timevalOf(0.0);
  }


  // We need to remove the notebook tab and the table child from the
  //   Overview tab.
  // Overview first
  char* overviewLabelText;
  GtkWidget* overviewLabel = gtk_notebook_get_tab_label(nb, 
                                                        lookup_widget(topWid, 
                                                                      "proccessTableScrolledWindow"));
  gtk_label_get(GTK_LABEL(overviewLabel), &overviewLabelText);

  if(overviewLabel == NULL) cerr << "Removing: Ah, crud! Overview label is null!  Badness!" << endl;
  else {
    GList* overviewList = (GList*) gtk_object_get_user_data(GTK_OBJECT(overviewLabel));
    if(overviewList == NULL) {
      free(compositeName);
      cerr << "Strange.  No list in the overview tab." << endl;
      return 0;
    }
    // Find the culprit
    FOR_GLIST(walker, overviewList) {
      if(walker->data == NULL) continue;
      // Aha!  The right entry!
      if( ((SwitchableChildData*) walker->data)->switchedChild == curRowData->pw) {
        //cerr << "Found it!" << endl;
        set<string>* viewers = PROCESSWIDGET(curRowData->pw)->viewers;
       
        // Remove the viewport (and the processWidget if it was realized here and only here)
        viewers->erase(string(overviewLabelText));
        viewers->erase(string(compositeName));

        // And sync the tree up
        if(viewers->size() <= 0) {
          // Removing the container will delete it
          //delete curRowData->pw;
          curRowData->pw = NULL;
          gtk_ctree_node_set_row_data(processTree, targNode, curRowData);
          /* Implicit unsubscribe, if we have the requisite data */
          unsub_process(machName, procName);          
        }

        // Okay, we need to reparent the processWidget to a group if a group including
        //   it is viewed.
        // FIXME: This is a mess...
        if(viewers->size() > 0) {
          bool reparented = false;
          // Look through groups until we find one with our process
          for(set<string>::iterator viewIt = viewers->begin();
              viewIt != viewers->end();
              viewIt++) {
            string viewingGrp = *viewIt;
            GtkWidget* tabLabel = gtk_notebook_get_tab_label(nb, get_child_of_tab(viewingGrp));
            GList* kidList = (GList*) gtk_object_get_user_data(GTK_OBJECT(tabLabel));
            SwitchableChildData* scd_kid;
            GtkWidget* sChild;
            // Walk through members of this group
            FOR_GLIST(walker2, kidList) {
              if(walker2->data == NULL 
                 || ((SwitchableChildData*) walker2->data)->switchedChild != ((SwitchableChildData*) walker->data)->switchedChild) {
                continue;
              }
              // Okay, we've found the right element
              scd_kid = (SwitchableChildData*) walker2->data;
              // Actually do the reparenting
              gtk_object_ref (GTK_OBJECT(scd_kid->switchedChild));
              // If we haven't seen it yet, don't remove
              sChild = GTK_WIDGET(((SwitchableChildData*) walker->data)->switchedChild);
              if(sChild->parent != NULL)
                gtk_container_remove (GTK_CONTAINER(sChild->parent), sChild);
              gtk_container_add (GTK_CONTAINER(scd_kid->parent), scd_kid->switchedChild);
              gtk_object_unref (GTK_OBJECT(scd_kid->switchedChild));    
              reparented = true;
              ProcessData kidpd;
              init_process_data(&kidpd);
              fill_process_data_from_process_widget(&kidpd, PROCESSWIDGET(scd_kid->switchedChild));
              processWidget_button_showandtell(scd_kid->switchedChild, &kidpd, TRUE_TB);
              break;
            }
            if(reparented) break;
          } // End loop through group
        } // end if(viewers->size() > 0)

        // Remove the bin from the table
        gtk_container_remove(GTK_CONTAINER(processTable), 
                             GTK_WIDGET(((SwitchableChildData*) walker->data)->parent));
        // Remove from the list
        overviewList = g_list_remove_link(overviewList, walker);
        delete (SwitchableChildData*) walker->data;
        g_list_free(walker);
        break;
      } // end if(this is the right overview child)
    } // End loop through overview list
    gtk_object_set_user_data(GTK_OBJECT(overviewLabel), overviewList);
  }
  
  //cerr << "Searching for " << compositeName << endl;
  // And now the individual tab...
  for(i = 0, list = nb->children; list; i++, list = list->next) {
    GtkWidget *page = gtk_notebook_get_nth_page(nb, i);
    GtkLabel *tab_label = (GtkLabel *)gtk_notebook_get_tab_label(nb, page);
    searchName = (char *)gtk_label_get_label(tab_label);
    if(strcmp(searchName, compositeName) == 0) break;
  }
  if(list) { /* If we didn't walk off the end of the list, remove the page */
    // We had to erase the individual tab name from viewers earlier
    gtk_notebook_remove_page(nb, i);
  } else {
    cerr << "Couldn't find it." << endl;
  }

  // Clean up 
  free(compositeName);
  return 1;
}

// Add one or more member nodes under a group node
// grpMembers is a space-separated string of the process names of one or more group members
// grpNode is the node in the processTree under which we're adding members
// processTree is, of course, the GtkCTree that displays the process/group/swallowed tree
// Returns true if there was a "-p" in grpMembers; false otherwise
bool add_grp_mem_to_tree(string grpMembers, GtkCTreeNode* grpNode, 
                         GtkCTree* processTree, string grpName) 
{
  // Now, add the members of the group as leaves under it if they're not there yet
  rcl::exp e = rcl::readFromString(grpMembers);
  rcl::vector v = e.getVector();
  GtkCTreeNode* gmNode = NULL;
  bool parallel = false;
  EntryDataAug* gmRowData;
  const char* colData[3];

  FOR_EACH(gMem, v) {
    if(gMem->getString() == "-p") {
      parallel = true;
    } else {
      string status = "unknown";
      // First, check to make sure we haven't already added this child
      if((gmNode = get_node_from_grp_mem_name(gMem->getString().c_str(), grpNode)) == NULL) {
        GtkCTreeNode* realProcNode = get_node_from_procname(gMem->getString().c_str(), NULL);
        // If we can find the "real" node associated with this process, go for it
        if(realProcNode != NULL) {
          char* realProcStatus;
          EntryData* realRowData = (EntryData*) gtk_ctree_node_get_row_data(processTree, realProcNode);
          
          colData[0] = gMem->getString().c_str();
          colData[1] = "";
          colData[2] = "";
          // If we can extract status info, do so; otherwise, use an empty string
          if(gtk_ctree_node_get_text(processTree, realProcNode, 1, &realProcStatus)) {
            colData[1] = realProcStatus;
            status = realProcStatus;
          }
          gmNode = gtk_ctree_insert_node(processTree, grpNode, NULL,
                                         /* I'm pretty sure colData isn't modified*/
                                         (char**) colData, 0,
                                         NULL, NULL, NULL, NULL,
                                         TRUE, FALSE);
          gmRowData = new EntryDataAug();
          gmRowData->label = strdup(colData[0]);
          if(realRowData != NULL) {
            gmRowData->pw = realRowData->pw;
          } else {
            gmRowData->pw = NULL;
          }
          gmRowData->realNode = realProcNode;
          gtk_ctree_node_set_row_data (processTree, gmNode, gmRowData);
          // Store pointer to self in real node
          realRowData->grpMems.insert(gmNode);
        } else {
          string msg = "Unable to set up group member node for group \"";
          msg += grpName;
          msg += "\", member \"";
          msg += gMem->getString();
          msg += "\":\n\tThis process' daemon isn't up yet.\n\tWe'll straighten things out when it comes alive.\n";
          print_to_common_buffer(msg.c_str(), SPECIAL_COL);
        }
      } // end check if we've already added the child
      else {
        //cerr << "Already added " << gMem->getString() << " to group " << grpName << endl;
      }
      // Update color
      if(gmNode != NULL) {
        //cerr << "Updating group member color" << endl;
        GdkColor col = status_to_color(status.c_str());
        gtk_clist_set_foreground(GTK_CLIST(processTree), 
                                 gtk_clist_find_row_from_data(GTK_CLIST(processTree), 
                                                              GTK_CTREE_ROW(gmNode)->row.data),
                                 &col);
      }

    } // end "-p or not" check    
  }
  return parallel;
}

// DUPEDPROCESSFIXME
string
procname_from_label                    (string          label)
{
  int atLoc = -1;
  string procName;

  if((atLoc = label.find('@')) < (int) label.length()) {
    procName = label.substr(0, atLoc-1);
  } else {
    procName = label;
  }

  return procName;
}

bool
tab_exists                             (string          targLabel)
{
  char* labelText;
  GtkWidget* tabLabel;
  GtkWidget* nb = lookup_widget(HeadDino_g, "notebook1");
  string targetLabel = procname_from_label(targLabel);
 
  for(GList* ambler = gtk_container_children(GTK_CONTAINER(nb));
      ambler;
      ambler = g_list_next(ambler)) {
    if(ambler->data == NULL) continue;
    tabLabel = gtk_notebook_get_tab_label(GTK_NOTEBOOK(nb), GTK_WIDGET(ambler->data));
    gtk_label_get(GTK_LABEL(tabLabel), &labelText);
    if(labelText != NULL && string(labelText) == targetLabel) {
      //cerr << labelText << " exists in a tab!" << endl;
      return true;
    }
  }
  //cerr << labelText << " does NOT exist in a tab!" << endl;
  return false;
}

GtkWidget*
get_child_of_tab                       (string          targLabel)
{
  char* labelText;
  GtkWidget* tabLabel;
  GtkWidget* nb = lookup_widget(HeadDino_g, "notebook1");
  string targetLabel = procname_from_label(targLabel);

  for(GList* ambler = gtk_container_children(GTK_CONTAINER(nb));
      ambler;
      ambler = g_list_next(ambler)) {
    if(ambler->data == NULL) continue;
    tabLabel = gtk_notebook_get_tab_label(GTK_NOTEBOOK(nb), GTK_WIDGET(ambler->data));
    gtk_label_get(GTK_LABEL(tabLabel), &labelText);
    if(labelText != NULL && string(labelText) == targetLabel) {
      // This is understood to return the processWidget for singleton tabs
      if(GTK_CHECK_TYPE(ambler->data, gtk_type_from_name("GtkViewport")) 
         && IS_PROCESSWIDGET(GTK_BIN(ambler->data)->child)) {
        return GTK_WIDGET(GTK_BIN(ambler->data)->child);
      } else {
        return GTK_WIDGET(ambler->data);
      }
    }
  }
  // Okay, so this is pretty weird.  If this return isn't here, the compiler 
  // doesn't warn or error.  It really really should...
  return NULL;
}

void
switch_to_tab                          (string          targLabel)
{
  char* labelText;
  GtkWidget* tabLabel;
  GtkWidget* nb = lookup_widget(HeadDino_g, "notebook1");
  string targetLabel = procname_from_label(targLabel);

  for(GList* ambler = gtk_container_children(GTK_CONTAINER(nb));
      ambler;
      ambler = g_list_next(ambler)) {
    if(ambler->data == NULL) continue;
    tabLabel = gtk_notebook_get_tab_label(GTK_NOTEBOOK(nb), GTK_WIDGET(ambler->data));
    gtk_label_get(GTK_LABEL(tabLabel), &labelText);
    if(labelText != NULL && string(labelText) == targetLabel) {
      int newPageNum = gtk_notebook_page_num(GTK_NOTEBOOK(nb),
                                             GTK_WIDGET(ambler->data));
      gtk_notebook_set_page(GTK_NOTEBOOK(nb), newPageNum);
    }
  }
}

void
switch_to_tab                          (ProcessData     *pd)
{
  string targetLabel;

  if(pd != NULL) targetLabel = process_data_to_label(pd);
  else targetLabel = "Overview";
  switch_to_tab(targetLabel);
}

void
get_names_from_node                    (GtkCTree        *processTree,
                                        GtkCTreeNode    *node,
                                        char            **procName,
                                        char            **status,
                                        char            **machName)
{
  GtkCTreeNode *selMach;

  if(processTree == NULL || node == NULL) {
    if(procName != NULL) *procName = NULL;
    if(status != NULL)   *status   = NULL;
    if(machName != NULL) *machName = NULL;
    return;
  }

  /* Grab process name; first column in tree isn't a text column */
  if(procName != NULL && 
     !gtk_ctree_get_node_info(processTree, node, procName,
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
    *procName = NULL;
  }  
  /* Grab process status */
  if(status != NULL &&
     !gtk_ctree_node_get_text(processTree, node, 1, status)) {
    *status = NULL;
  }

  /* Only get machine name if we have a valid place to put it */
  if(machName != NULL) {
    /* Find machine (our ancestor). */
    selMach = GTK_CTREE_ROW(node)->parent;
    /* Get machine name */
    if(selMach != NULL && !gtk_ctree_get_node_info(processTree, selMach, machName,
                                                   NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
      *machName = NULL;
    } else if(selMach == NULL) {
      *machName = NULL;
    }
  } /* if(machName != NULL) */  
} /* end get_names_from_node */


/* Fill ProcessData structure given a GtkCTreeNode */
bool
fill_process_data_from_treenode        (ProcessData     *pd,
                                        GtkCTreeNode    *node,
                                        GtkCTree        *processTree)
{
  GtkCTreeNode *selMach = NULL;
  char* tmpStr;

  if(pd == NULL || node == NULL || processTree == NULL) return false;

  // Sigh.  It really really looks like processTree is okay...
  /* Grab process name; first column in tree isn't a text column */
  if(!gtk_ctree_get_node_info(processTree, GTK_CTREE_NODE(node), &tmpStr /*&(pd->procName)*/,
                              NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
    return false;
  }

  pd->procName = tmpStr;

  /* Grab process status; nonexistence is not an error */
  if(!gtk_ctree_node_get_text(processTree, node, 1, &(pd->status))) {
    pd->status = NULL;
  }
  /* Find machine (our ancestor). */
  selMach = GTK_CTREE_ROW(node)->parent;
  /* Get machine name */
  if(selMach != NULL && !gtk_ctree_get_node_info(processTree, selMach, 
                                                 &(pd->machName),
                                                 NULL, NULL, NULL, 
                                                 NULL, NULL, NULL, NULL)) {
    pd->machName = NULL;
  } else if(selMach == NULL) {
    pd->machName = NULL;//
  }
  return true;
}

bool
fill_process_data_from_process_widget  (ProcessData     *pd,
                                        ProcessWidget   *pw)
{
  char* nameLabel;
  char* statusLabel;
  if(pd == NULL || pw == NULL) return false;

  gtk_label_get(GTK_LABEL(PROCESSWIDGET(pw)->ProcessNameLabel), &nameLabel);
  gtk_label_get(GTK_LABEL(PROCESSWIDGET(pw)->ProcessStateLabel), &statusLabel);
  process_data_from_label(pd, nameLabel, statusLabel);
  return true;
}


void
remove_swallowed_from_tree               (string           winName)
{
  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  GtkCTreeNode* winNode;
  GtkCTreeNode* swalNode;
  EntryData ed;
  ed.label = (char*) winName.c_str();
  ed.pw = NULL;
  winNode = gtk_ctree_find_by_row_data_custom(processTree,
                                              NULL, /* Where to start searching (root) */
                                              &ed,
                                              rowCompareFunc);  
  if(winNode != NULL) {
    // Find our parent; if we're its only child, remove the parent
    swalNode = GTK_CTREE_ROW(winNode)->parent;
    // Remove ourself
    gtk_ctree_remove_node(processTree, winNode);  
    // If that was the last swallowed window, remove the "swallowees" node
    if(swalNode != NULL && GTK_CTREE_ROW(swalNode)->children == NULL) {      
      gtk_ctree_remove_node(processTree, swalNode);
    } // End swalNode != NULL
  } // End winNode != NULL
}


void
add_swallowed_to_tree                  (string           winName)
{
  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  GtkCTreeNode* treeNode;
  GtkCTreeNode* procNode;
  char* swch = (char *)"Swallowees";
  const char* colData[3];
  EntryData* newRowData;
  EntryData  targRowData;
  targRowData.pw = NULL;

  if(processTree == NULL) return;  
  // Is the swallowed top node in the tree?
  targRowData.label = swch;
  treeNode = gtk_ctree_find_by_row_data_custom(processTree,
                                               NULL, /* Where to start searching (root) */
                                               &targRowData,
                                               rowCompareFunc);
  if(treeNode == NULL) {
    // If not, add it
    colData[0] = swch;
    colData[1] = "";
    colData[2] = "";
    treeNode = gtk_ctree_insert_node(processTree, NULL, NULL,
                                     /* I'm pretty sure colData isn't modified*/
                                     (char**) colData, 0, 
                                     NULL, NULL, NULL, NULL,
                                     FALSE, TRUE);
    newRowData = new EntryData();
    newRowData->label = strdup(swch);
    newRowData->pw = NULL;
    gtk_ctree_node_set_row_data (processTree, treeNode, newRowData);   
    // This could necessitate a resort
    gtk_ctree_sort_node(processTree, NULL);
  }
  // Add this window to the tree (allow multiples, since you can swallow multiple
  //   windows with the same name)
  colData[0] = winName.c_str();
  colData[1] = "";
  colData[2] = "";
  procNode = gtk_ctree_insert_node(processTree, treeNode, NULL,
                                   /* I'm pretty sure colData isn't modified*/
                                   (char**) colData, 0, 
                                   NULL, NULL, NULL, NULL,
                                   TRUE, TRUE);
  newRowData = new EntryData();
  newRowData->label = strdup(winName.c_str());
  newRowData->pw = NULL;
  gtk_ctree_node_set_row_data (processTree, procNode, newRowData);   
  
  gtk_widget_show(GTK_WIDGET(processTree));  
}


enum nodeType
get_nodetype                           (const char      *procName,
                                        const char      *machName)
{
  ProcessData pd;
  enum nodeType nt;
  init_process_data(&pd);
  fill_process_data_shallow(&pd, (char*) procName, (char*) machName, NULL);
  nt = get_nodetype(&pd);
  return nt;
}

enum nodeType
get_nodetype                           (ProcessDataAug  *pda)
{
  ProcessData pd;
  if(pda == NULL) return UNKNOWN_NODE;

  pd.machName = pda->machName;
  pd.procName = pda->procName;
  pd.status = pda->status;
  return get_nodetype(&pd);
}

enum nodeType
get_nodetype                           (ProcessData     *pd)
{
  // Deduce type from contents
  if(pd == NULL) return UNKNOWN_NODE;
  // Toplevel node
  if(pd->machName == NULL) {
    if(pd->procName == NULL) {
      return UNKNOWN_NODE;
    } else if(strcmp(pd->procName, "Swallowees") == 0) {
      return SWALLOWED_TOP_NODE;
    } else if(strcmp(pd->procName, "Groups") == 0) {
      return GROUP_TOP_NODE;
    } else if(strncmp(pd->procName, "d_", 2) == 0) {
      return PROCESS_TOP_NODE;
    } else {
      return UNKNOWN_NODE;
    }
  }
  // Lowerlevel node; deduce by parent
  else {
    if(strcmp(pd->machName, "Swallowees") == 0) {
      return SWALLOWED_NODE;
    } else if(strcmp(pd->machName, "Groups") == 0) {
      return GROUP_NODE;
    } else if(strncmp(pd->machName, "d_", 2) == 0) {
      return PROCESS_NODE;
    } else {
      return GROUP_MEMBER_NODE;
    }
  }
}

enum nodeType
get_nodetype                           (GtkCTree        *processTree,
                                        GtkCTreeNode    *node)
{
  // Do this a weird way to make life easier, since I already have
  //  some helper functions written.
  // Clean this up at some point.
  ProcessData tmp_pd;
  init_process_data(&tmp_pd);
  if(fill_process_data_from_treenode(&tmp_pd, node, processTree)) {
    if(tmp_pd.machName == NULL && tmp_pd.procName != NULL) {
      // Parent node
      if(strcasecmp(tmp_pd.procName, "swallowees") == 0)
        return SWALLOWED_TOP_NODE;
      else if(strcasecmp(tmp_pd.procName, "groups") == 0)
        return GROUP_TOP_NODE;
      else if(strncmp(tmp_pd.procName, "d_", 2) == 0)
        return PROCESS_TOP_NODE;
      else
        return UNKNOWN_NODE;
    } else if(tmp_pd.machName != NULL && tmp_pd.procName != NULL) {
      // Child node
      if(strcasecmp(tmp_pd.machName, "swallowees") == 0)
        return SWALLOWED_NODE;
      else if(strcasecmp(tmp_pd.machName, "groups") == 0)
        return GROUP_NODE;
      else if(strncmp(tmp_pd.machName, "d_", 2) == 0)
        return PROCESS_NODE;
      else
        return GROUP_MEMBER_NODE;
    } else {
      return UNKNOWN_NODE;
    }
  } else {
    return UNKNOWN_NODE;
  }
  
}


void
get_status_helper                           (GtkCTree *ctree,
                                             GtkCTreeNode *node,
                                             gpointer data)
{
  ProcessData *pd = (ProcessData*) data;
  ProcessData tmp_pd;
  if(pd == NULL) return;
  init_process_data(&tmp_pd);
  if(fill_process_data_from_treenode(&tmp_pd, node, ctree)) {
    if(tmp_pd.machName != NULL && tmp_pd.procName != NULL) {
      if(strcmp(tmp_pd.machName, pd->machName) == 0
         && strcmp(tmp_pd.procName, pd->procName) == 0
         && tmp_pd.status != NULL) {
        if(pd->status != NULL) free(pd->status);
        pd->status = strdup(tmp_pd.status);
      }
    }
  }
}


/* Get status from processTree */
string
get_status_from_processtree            (const char      *procName,
                                        const char      *machName)
{
  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  ProcessData pd;
  string retval;
  init_process_data(&pd);
  if(processTree == NULL) return "";
  fill_process_data(&pd, procName, machName, NULL);
  pd.status = NULL;

  gtk_ctree_post_recursive(processTree, NULL, get_status_helper, &pd);
  if(pd.status != NULL) {
    retval = pd.status;
  }
  else
    retval = "";
  free_process_data_members(&pd);
  return retval;
}


void
get_idle_helper                             (GtkCTree *ctree,
                                             GtkCTreeNode *node,
                                             gpointer data)
{
  ProcessData *pd = (ProcessData*) data;
  ProcessData tmp_pd;
  if(pd == NULL) return;
  init_process_data(&tmp_pd);
  if(fill_process_data_from_treenode(&tmp_pd, node, ctree)) {
    if(tmp_pd.machName != NULL && tmp_pd.procName != NULL) {
      if(strcmp(tmp_pd.machName, pd->machName) == 0
         && strcmp(tmp_pd.procName, pd->procName) == 0
         && tmp_pd.status != NULL) {
        gtk_ctree_node_get_text(ctree, node, 2, &(pd->status));
      }
    }
  }
}

/* Get status from processTree */
string
get_idle_from_processtree              (const char      *procName,
                                        const char      *machName)
{
  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  ProcessData pd;
  string retval;
  if(processTree == NULL) return "";
  init_process_data(&pd);
  fill_process_data(&pd, procName, machName, NULL);

  gtk_ctree_post_recursive(processTree, NULL, get_idle_helper, &pd);

  if(pd.status != NULL) 
    retval = pd.status;
  else
    retval = "";
  // Status is set to point to data handled by gtk; don't free it
  pd.status = NULL;
  free_process_data_members(&pd);
  return retval;
}

/*  Get data from a multiple selection
    Returns a GList* of ProcessData's
 */
GList*
get_multiple_selected_data             (GtkCTree        *processTree,
                                        int             *selectCnt,
                                        enum nodeType   targetNodeTypes)
{
  GtkCTreeNode *selProcess = NULL;
  GList *list;
  GList *dataList = NULL;
  ProcessData* pd = NULL;

  if(selectCnt != NULL) *selectCnt = 0;

  for(list = (GList*) GTK_CLIST(processTree)->selection; list; list = list->next) {
    pd = new ProcessData();
    init_process_data(pd);
    selProcess = GTK_CTREE_NODE(list->data);

    if(fill_process_data_from_treenode(pd, selProcess, processTree)) {
      /* Mask by acceptable node types */
      if(get_nodetype(processTree, selProcess) & targetNodeTypes) {
        /* Add to list */
        dataList = g_list_append(dataList, pd);
        if(selectCnt != NULL) (*selectCnt)++;
      }
    }
    //free(pd);
  } /* Walk through selections */
  return g_list_first(dataList);
} /* get_selected_data(...) */


/* Assuming single-selection mode 
   DEPRECATED
 */
void
get_selected_data                      (GtkCTree        *processTree,
                                        char            **procName,
                                        char            **status,
                                        char            **machName)
{
  GtkCTreeNode *selProcess = NULL;
  GtkCTreeNode *selMach = NULL;
  GSList *list;

  fprintf(stderr, "WARNING: get_selected_data is deprecated in favor of get_multiple_selected_data.\n");
  list = (GSList*) GTK_CLIST(processTree)->selection;
  if(list == NULL) {
    if(procName != NULL) *procName = NULL;
    if(status != NULL)   *status   = NULL;
    if(machName != NULL) *machName = NULL;
    return;
  }
  if(list->next != NULL) {
    fprintf(stderr, "WARNING: multiple selections are active; get_selected_data only examining first item.\n");
  }
  selProcess = GTK_CTREE_NODE(list->data);
  if(selProcess != NULL) {
    /* Grab process name; first column in tree isn't a text column */
    if(!gtk_ctree_get_node_info(processTree, selProcess, procName,
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
      *procName = NULL;
    }
    /* Grab process status */
    if(status != NULL) {
      if(!gtk_ctree_node_get_text(processTree, selProcess, 1, status)) {
        *status = NULL;
      }
    }
    /* Only get machine name if we have a valid place to put it */
    if(machName != NULL) {
      /* Find machine (our ancestor). selProcess guaranteed non-NULL here */
      selMach = GTK_CTREE_ROW(selProcess)->parent;
      /* Get machine name */
      if(selMach != NULL && !gtk_ctree_get_node_info(processTree, selMach, machName,
                                                     NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
        *machName = NULL;
      } else if(selMach == NULL) {
        *machName = NULL;
      }
    } /* if(machName != NULL) */
  } /* if selProcess != NULL */
} /* get_selected_data(...) */


void
get_all_data_helper                         (GtkCTree *ctree,
                                             GtkCTreeNode *node,
                                             gpointer data)
{
  GList* list;
  GtkCTreeNode* selMach;
  ProcessData* pd;

  /* data should be a GList**; NULL is a valid GList */
  if(data == NULL) return;
  list = (GList*) (*((GList**) data));

  if(node != NULL) {
    pd = (ProcessData*) malloc(sizeof(ProcessData));
    /* Grab process name; first column in tree isn't a text column */
    if(!gtk_ctree_get_node_info(ctree, node, &(pd->procName),
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
      pd->procName = NULL;
    }
    /* Grab process status */
    if(!gtk_ctree_node_get_text(ctree, node, 1, &(pd->status))) {
      pd->status = NULL;
    }
    /* Find machine (our ancestor). node guaranteed non-NULL here */
    selMach = GTK_CTREE_ROW(node)->parent;
    /* Get machine name */
    if(selMach != NULL && 
       !gtk_ctree_get_node_info(ctree, selMach, &(pd->machName),
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
      pd->machName = NULL;
    } else if(selMach == NULL) {
      pd->machName = NULL;
    }

    /* Only store this if it has a machine above it; otherwise, it's a machine name */
    if(pd->machName != NULL) {
      list = g_list_append(list, pd);      
      *((GList**)data) = list;
    } else {
      /* Otherwise, free stuff up */
      free(pd);
    }
  } /* if node != NULL */
  
} /* get_all_data_helper */

/* This is only visible within this file.
   It's a bit ugly, but I don't like building structs just for one function call.
 */
enum nodeType gadType_g;

/* Data is a GList of ProcessDataAug's */
void
get_all_data_helper_aug                     (GtkCTree *ctree,
                                             GtkCTreeNode *node,
                                             gpointer data)
{
  GList* list;
  GtkCTreeNode* selMach;
  ProcessDataAug* pda = NULL;
  EntryData* ed;

  /* data should be a GList**; NULL is a valid GList */
  if(ctree == NULL || data == NULL) return;
  list = (GList*) (*((GList**) data));

  if(node != NULL) {
    pda = (ProcessDataAug*) malloc(sizeof(ProcessDataAug));
    init_process_data_aug(pda);
    /* Grab process name; first column in tree isn't a text column */
    if(!gtk_ctree_get_node_info(ctree, node, &(pda->procName),
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
      pda->procName = NULL;
    }
    /* Grab process status */
    if(!gtk_ctree_node_get_text(ctree, node, 1, &(pda->status))) {
      pda->status = NULL;
    }
    /* Find machine (our ancestor). node guaranteed non-NULL here */
    selMach = GTK_CTREE_ROW(node)->parent;
    /* Get machine name */
    if(selMach != NULL && 
       !gtk_ctree_get_node_info(ctree, selMach, &(pda->machName),
                                NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
      pda->machName = NULL;
    } else if(selMach == NULL) {
      pda->machName = NULL;
    }
    
    /* Grab process widget */
    ed = (EntryData*) gtk_ctree_node_get_row_data(ctree, node);
    if(ed != NULL && ed->pw != NULL) {
      pda->pw = PROCESSWIDGET(ed->pw);
    } else {
      pda->pw = NULL;
    }

    if(get_nodetype(pda) & gadType_g) {
      // Copy it deep
      ProcessDataAug* pdaCopy = new ProcessDataAug();
      pda_to_pda(pdaCopy, pda);
      list = g_list_append(list, pdaCopy);      
      *((GList**)data) = list;
    }
    free(pda);
  } /* if node != NULL */  
} /* get_all_data_helper_aug */


/* Safe version of strcat */
void
safecat                           (char            *dest,
                                   const char      *src,
                                   unsigned int    *buffSize,
                                   bool             addSpace)
{
  /* malloc more space if we need it.
     Add 2 for space & null character */
  if(strlen(dest) + strlen(src) + 2 > *buffSize) {
    *buffSize *= 2;
    realloc(dest, *buffSize);
  }
  /* Append a space, then the new process name */
  if(addSpace) {
    strcat(dest, " ");
  }
  strcat(dest, src);
}

GList*
get_all_data                      (GtkCTree        *processTree,
                                   enum nodeType    targetTypes)
{
  /* The Right Way to do this */
  GList* list = NULL;
  //ProcessDataAug* pda;

  if(processTree == NULL) return NULL;

  gadType_g = targetTypes;
  /* Grab all data elements.  No easy way to hand in the nodeType;
     do filtering afterwards. */
  gtk_ctree_post_recursive(processTree, NULL, get_all_data_helper_aug, &list);

  return list;
}


/* Allocates data for procName, status, and machName; must free outside of here */
void
get_all_data                      (GtkCTree        *processTree,
                                   char            **procName,
                                   char            **status,
                                   char            **machName)
{
  GList* list = NULL;
  GList* walker;
  ProcessData* pd;
  unsigned int buffSpaceP, buffSpaceS, buffSpaceM;

  /* Don't do squat if we don't have anywhere to store things */
  if(procName == NULL && status == NULL && machName == NULL) return;
  
  buffSpaceP = buffSpaceS = buffSpaceM = 1024;

  /* Allocate initial buffers */
  if(procName != NULL) { *procName = (char*) malloc(sizeof(char)*buffSpaceP); (*procName)[0] = '\0'; }
  if(status != NULL) { *status = (char*) malloc(sizeof(char)*buffSpaceS); (*status)[0] = '\0'; }
  if(machName != NULL) { *machName = (char*) malloc(sizeof(char)*buffSpaceM); (*machName)[0] = '\0'; }

  gtk_ctree_post_recursive(processTree, NULL, get_all_data_helper, &list);
  
  /* Walk list and build composite strings */
  for(walker = g_list_first(list); walker != NULL; walker = g_list_next(walker)) {
    if(walker->data != NULL) {
      pd = (ProcessData*) walker->data;
      
      /* Append to buffers */
      if(procName != NULL && pd->procName != NULL) {
        safecat(*procName, pd->procName, &buffSpaceP);
      }
      if(status != NULL && pd->status != NULL) {
        safecat(*status, pd->status, &buffSpaceS);
      }
      if(machName != NULL && pd->machName != NULL) {
        safecat(*machName, pd->machName, &buffSpaceM);
      }
    } else {
      fprintf(stderr, "Data null\n");
    }
  }

  /* Free list */
  for(walker = g_list_first(list); walker != NULL; walker = g_list_next(walker)) {
    free(walker->data);
  }
  g_list_free(list);

} /* get_all_data(...) */


/* This is only visible within this file.
   It's a bit ugly, but I don't like building structs just for one function call.
 */
int ganType_g;  // OR of elements of enum nodeTypes
const char* ganName_g;

/* Data is a GList** of GtkCTreeNode*'s */
void
get_all_nodes_helper                   (GtkCTree *ctree,
                                        GtkCTreeNode *node,
                                        gpointer data)
{
  enum nodeType nt;
  GList* list;

  /* data should be a GList**; NULL is a valid GList */
  if(ctree == NULL || node == NULL || data == NULL) return;
  list = (GList*) (*((GList**) data));

  nt = get_nodetype(ctree, node);

  /* If we're interested in this type of node, store it */
  if(nt & ganType_g) {
    // If we're checking for a given procname, do so
    if(ganName_g != NULL) {
      char* procName = NULL;
      get_names_from_node(ctree, node, &procName, NULL, NULL);
      if(strcmp(ganName_g, procName) != 0)
        return;
    }
    list = g_list_append(list, node);      
    *((GList**)data) = list;
  }
}

/* Returns a GList of GtkCTreeNode*'s associated with the nodes
   of the given types.
*/
GList*
get_all_nodes                          (GtkCTree        *processTree,
                                        int              targetTypes,  // OR of elements of enum nodeTypes
                                        const char      *procName)
{
  GList* list = NULL;

  if(processTree == NULL) return NULL;

  ganType_g = targetTypes;
  ganName_g = procName;
  /* Grab all nodes.  Node type goes in via global ganType_g; no easy
     way to pass it in. */
  gtk_ctree_post_recursive(processTree, NULL, get_all_nodes_helper, &list);

  return list;
}


/* Global to this file; only reasonable way to get data 
   into recursive helper function */
const char* gnfp_name_g;

void
get_node_from_procname_helper               (GtkCTree *ctree,
                                             GtkCTreeNode *node,
                                             gpointer data)
{
  GtkCTreeNode** nodeToSet;
  char* curProcName;
  if(ctree == NULL || data == NULL || gnfp_name_g == NULL) return;
  /* data should be a GtkCTreeNode** */
  nodeToSet = (GtkCTreeNode**) data;

  /* Check if it's a process or group node */
  if(get_nodetype(ctree, node) != PROCESS_NODE
     && get_nodetype(ctree, node) != GROUP_NODE) {
    return;
  }

  /* Grab process name; first column in tree isn't a text column */
  if(gtk_ctree_get_node_info(ctree, node, &curProcName,
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
    if(strcmp(curProcName, gnfp_name_g) == 0) {
      *nodeToSet = node;
      // No way to terminate the recursion...
    }
  }
}

GtkCTreeNode*
get_node_from_procname                 (const char       *procName,
                                        GtkCTreeNode     *root)
{
  GtkCTreeNode* node = NULL;
  gnfp_name_g = procName;
  gtk_ctree_post_recursive(GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree")),
                           root, 
                           get_node_from_procname_helper, 
                           &node);
  return node;
}

/* Global to this file; only reasonable way to get data 
   into recursive helper function */
const char* gnfgmn_name_g;
enum nodeType gnfgmn_types_g;

void
get_node_from_grp_mem_name_helper               (GtkCTree *ctree,
                                                 GtkCTreeNode *node,
                                                 gpointer data)
{
  GtkCTreeNode** nodeToSet;
  char* curProcName;
  if(ctree == NULL || data == NULL || gnfgmn_name_g == NULL) return;
  /* data should be a GtkCTreeNode** */
  nodeToSet = (GtkCTreeNode**) data;

  /* Check if it's an acceptable type */
  if(!(get_nodetype(ctree, node) & gnfgmn_types_g))
    return;

  /* Grab process name; first column in tree isn't a text column */
  if(gtk_ctree_get_node_info(ctree, node, &curProcName,
                             NULL, NULL, NULL, NULL, NULL, NULL, NULL)) {
    if(strcmp(curProcName, gnfgmn_name_g) == 0) {
      *nodeToSet = node;
      // No way to terminate the recursion...
    }
  }
}

GtkCTreeNode*
get_node_from_grp_mem_name                 (const char       *procName,
                                            GtkCTreeNode     *grpNode,
                                            enum nodeType     nodetypes)
{
  GtkCTreeNode* node = NULL;
  gnfgmn_name_g = procName;
  gnfgmn_types_g = nodetypes;
  gtk_ctree_post_recursive(GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree")),
                           grpNode, 
                           get_node_from_grp_mem_name_helper, 
                           &node);
  return node;
}

/* Global to this file; only reasonable way to get data 
   into recursive helper function */
const ProcessData* gnfpd_pd_g;

void
get_node_from_process_data_helper               (GtkCTree *ctree,
                                                 GtkCTreeNode *node,
                                                 gpointer data)
{
  GtkCTreeNode** nodeToSet;
  ProcessData lpd;
  if(ctree == NULL || data == NULL || gnfpd_pd_g == NULL) return;
  /* data should be a GtkCTreeNode** */
  nodeToSet = (GtkCTreeNode**) data;

  init_process_data(&lpd);

  fill_process_data_from_treenode(&lpd, node, ctree);

  /* Grab process name; first column in tree isn't a text column */
  if(ProcessDataEqual(*gnfpd_pd_g, lpd)) {
    *nodeToSet = node;
    // No way to terminate the recursion...
  }
}

GtkCTreeNode*
get_node_from_process_data             (ProcessData     *pd)
{
  GtkCTreeNode* node = NULL;
  gnfpd_pd_g = pd;
  gtk_ctree_post_recursive(GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree")), NULL, 
                           get_node_from_process_data_helper, &node);
  return node;
}


/* All strings must have an equal number of space-separated tokens 
*/
GList*
strings_to_glist                       (const char      *processList,
                                        const char      *status,
                                        const char      *machList)
{
  GList* list = NULL;
  ProcessData* pd;
  /* Dupes to allow const char* args */
  char* plD;
  char* sD;
  char* mlD;
  /* Roving pointers */
  char* plP;
  char* sP;
  char* mlP;
  char* curSpace;

  if(processList == NULL && status == NULL && machList == NULL) return NULL;

  if(processList != NULL) plP = plD = strdup(processList);
  else plP = plD = NULL;
  if(status != NULL) sP = sD = strdup(status);
  else sP = sD = NULL;
  if(machList != NULL) mlP = mlD = strdup(machList);
  else mlP = mlD = NULL;

  while(plP || sP || mlP) {
    pd = (ProcessData*) calloc(1, sizeof(ProcessData));
    if(plP) {
      curSpace = strstr(plP, " ");
      if(curSpace != NULL) {
        *curSpace = '\0';
        pd->procName = strdup(plP);
        *curSpace = ' ';
        plP = curSpace+1;
      } else { /* last item */
        pd->procName = strdup(plP);
        plP = NULL;
      }
    } /* if(plP) */

    if(sP) {
      curSpace = strstr(sP, " ");
      if(curSpace != NULL) {
        *curSpace = '\0';
        pd->status = strdup(sP);
        *curSpace = ' ';
        sP = curSpace+1;
      } else { /* last item */
        pd->status = strdup(sP);
        sP = NULL;
      }
    } /* if(sP) */

    if(mlP) {
      curSpace = strstr(mlP, " ");
      if(curSpace != NULL) {
        *curSpace = '\0';
        pd->machName = strdup(mlP);
        *curSpace = ' ';
        mlP = curSpace+1;
      } else { /* last item */
        pd->machName = strdup(mlP);
        mlP = NULL;
      }
    } /* if(mlP) */
    /* Ignore stuff that's all spaces */
    if((pd->procName == NULL || strlen(pd->procName) <= 0)
       && (pd->status == NULL || strlen(pd->status) <= 0)
       && (pd->machName == NULL || strlen(pd->machName) <= 0)) {
      free_process_data(pd);
      continue;
    }
    /* Tack on the node */
    list = g_list_append(list, (gpointer) pd);
  } /* while(plP || sP || mlP) */

  /* Free dup'd data */
  if(plD != NULL) free(plD);
  if(sD != NULL)  free(sD);
  if(mlD != NULL) free(mlD);

  return list;
}

void
free_process_data_list                 (GList          *list,
                                        bool            fullDepth)
{
  GList *walker;
  if(list == NULL) return;
  for(walker = g_list_first(list); walker; walker = g_list_next(walker)) {
    if(walker->data != NULL) {
      if(fullDepth) {
        free_process_data_members((ProcessData*) walker->data);
        delete (ProcessData*) walker->data;
      }
      else // walker->data is cleaned up by free_process_data
        delete (ProcessData*) walker->data;
    }
  }
}


// STYLE: is there a nice way to just call free_process_data_members?
//        I don't like having that const in there...
void
free_process_data                      (ProcessData    *pd)
{
  if(pd == NULL) return;
  if(pd->procName != NULL) free(pd->procName);
  if(pd->status != NULL) free(pd->status);
  if(pd->machName != NULL) free(pd->machName);
  free(pd); // Is there any way to tell if data has been malloc'd or new'd?
  pd = NULL;
}

void
free_process_data_members              (const ProcessData *pd)
{
  if(pd == NULL) return;
  if(pd->procName != NULL) free(pd->procName);
  if(pd->status != NULL) free(pd->status);
  if(pd->machName != NULL) free(pd->machName);
}

void
print_process_data                     (ProcessData    *pd) {
  if(pd == NULL) return;
  fprintf(stderr, "machName: \"%s\", procName: \"%s\", status: \"%s\"",
          pd->machName == NULL ? "NULL" : pd->machName, 
          pd->procName == NULL ? "NULL" : pd->procName, 
          pd->status == NULL ? "NULL" : pd->status);
}

void
print_process_data_aug                 (ProcessDataAug *pda) {
  if(pda == NULL) return;
  fprintf(stderr, "machName: \"%s\", procName: \"%s\", status: \"%s\", pw: %p",
          pda->machName == NULL ? "NULL" : pda->machName, 
          pda->procName == NULL ? "NULL" : pda->procName, 
          pda->status == NULL ? "NULL" : pda->status,
          pda->pw);
}

void
print_process_data_list                (GList          *list,
                                        bool            augmented)
{
  cerr << "Printing process data list " << list << ":" << endl;
  FOR_GLIST(walker, list) {
    if(augmented) print_process_data_aug((ProcessDataAug*) (walker->data));
    else          print_process_data((ProcessData*) (walker->data));
    cerr << endl;
  }
}


void
init_process_data_aug                  (ProcessDataAug  *pda)
{
  if(pda == NULL) return;
  pda->procName = pda->machName = pda->status = NULL;
  pda->pw = NULL;
}

/* Fill with NULL's */
void
init_process_data                      (ProcessData     *pd)
{
  if(pd == NULL) return;
  pd->procName = pd->machName = pd->status = NULL;
}

ProcessData*
copy_process_data                      (ProcessData    *dest,
                                        ProcessData    *src)
{
  if(dest == NULL || src == NULL) {
    cerr << "ERROR: attempting to copy a process data with a null ";
    if(dest == NULL) cerr << "destination ";
    if(src == NULL) cerr << "source ";
    cerr << "argument(s)." << endl;
    return NULL;
  }
  if(src->machName != NULL) dest->machName = strdup(src->machName);
  else dest->machName = NULL;
  if(src->procName != NULL) dest->procName = strdup(src->procName);
  else dest->procName = NULL;
  if(src->status != NULL) dest->status = strdup(src->status);
  else dest->status = NULL;

  return dest;
}

void
pda_to_pda                             (ProcessDataAug *pdaDest,
                                        ProcessDataAug *pdaSrc)
{
  if(pdaDest == NULL || pdaSrc == NULL) return;
  init_process_data_aug(pdaDest);
  if(pdaSrc->procName != NULL) pdaDest->procName = strdup(pdaSrc->procName);
  if(pdaSrc->machName != NULL) pdaDest->machName = strdup(pdaSrc->machName);
  if(pdaSrc->status != NULL) pdaDest->status = strdup(pdaSrc->status);
  // Don't dup the processWidget, of course!
  pdaDest->pw = pdaSrc->pw;
}

void
pda_to_pd                              (ProcessData    *pdDest,
                                        ProcessDataAug *pdaSrc)
{
  if(pdDest == NULL || pdaSrc == NULL) return;
  init_process_data(pdDest);
  fill_process_data(pdDest, pdaSrc->procName, pdaSrc->machName, pdaSrc->status);
}

void
fill_process_data                      (ProcessData    *pd,
                                        const char     *procName,
                                        const char     *machName,
                                        const char     *status)
{
  if(pd == NULL) return;
  free_process_data_members(pd);
  if(procName != NULL) pd->procName = strdup(procName);
  else pd->procName = NULL;
  if(machName != NULL) pd->machName = strdup(machName);
  else pd->machName = NULL;
  if(status != NULL) pd->status = strdup(status);
  else pd->status = NULL;
}

void
pda_to_pd_shallow                      (ProcessData    *pdDest,
                                        ProcessDataAug *pdaSrc)
{
  if(pdDest == NULL || pdaSrc == NULL) return;
  init_process_data(pdDest);
  fill_process_data(pdDest, pdaSrc->procName, pdaSrc->machName, pdaSrc->status);
}

/* Copies pointers; doesn't dup */
void
fill_process_data_shallow              (ProcessData    *pd,
                                        char           *procName,
                                        char           *machName,
                                        char           *status)
{
  if(pd == NULL) return;
  pd->procName = procName;
  pd->machName = machName;
  pd->status = status;
}

void
process_data_from_label                (ProcessData    *pd,
                                        const char     *nameLabel,
                                        const char     *statusLabel)
{
  if(pd == NULL) return;
  // Just in case
  free_process_data_members(pd);
  if(nameLabel == NULL) {
    pd->procName = pd->machName = NULL;
  } else {
    char* victim = strdup(nameLabel);
    char* mangler = strstr(victim, " @ ");
    if(mangler == NULL) pd->procName = pd->machName = NULL;
    else {
      mangler[0] = '\0';
      pd->procName = strdup(victim);
      mangler += 3;
      pd->machName = strdup(mangler);
    }
    free(victim);
  }
  if(statusLabel == NULL) {
    pd->status = NULL;
  } else {
    pd->status = strdup(statusLabel);
  }
}

string
process_data_to_label                  (ProcessData    *pd)
{
  string retval;
  if(pd == NULL) return "";

  if(pd->procName == NULL) retval = "";
  else retval = pd->procName;
  
  retval += " @ ";
  
  if(pd->machName == NULL) retval += "";
  else retval += pd->machName;

  return retval;
}


void
print_process_data_list                (GList           *list)
{
  for( ; list; list = list->next) {
    print_process_data((ProcessData*) list->data);
  }
}

/* Print a timestamp to timebuf */
void
timestamp_output                     (const timeval *ts,
                                      const char    *searchName,
                                      char          *timebuf,
                                      unsigned int  timebuflen) {
  timeval        ts_loc;
  struct tm     *time_breakdown;
  hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>::iterator sIt;
  timeval        skew_tv;

  /* Timestamp the output */
  if(ts == NULL) {
    /* if the timestamp is NULL, it's a local message happening           
       right now, so show the current time */
    gettimeofday(&ts_loc, NULL);
    time_breakdown = localtime(&(ts_loc.tv_sec));
    strftime(timebuf, timebuflen, "(%T): ", time_breakdown);
  } else {
    // Else, we were handed daemon time - calculate skew
    hash_map<string, timeval>::iterator it;
    const char* daemonName = strstr(searchName, "@");
    ProcessData pd;
    pd.machName = pd.procName = pd.status = NULL;
    // There's a space after the @; point to the character after it
    if(strlen(daemonName) >= 2)
      daemonName += 2;

    // Store the daemon time for future subscribe calls
    process_data_from_label(&pd, searchName, NULL);
    sIt = subscriptions_g->find(pd);
    if(sIt != subscriptions_g->end()) {
      (*sIt).second.second = *ts;
      free_process_data_members(&pd);
    } else {
      // This is rather weird...
      string warnMsg = "WARNING: received stdout message from ";
      warnMsg += searchName;
      warnMsg += ", but we're not subscribed... Okay, who turned the world upside down?";
      print_to_common_buffer(warnMsg, WARNING_COL);
      subscriptions_g->insert(pair<ProcessData, pair<bool, timeval> >(pd, pair<bool, timeval>(false, *ts)));
    }

    if((it = clockSkew_g.find(daemonName)) != clockSkew_g.end()) {
      /* we've got clock skew, apply it */
      timeradd(ts, &((*it).second), &skew_tv);
      time_breakdown = localtime(&(skew_tv.tv_sec));
      strftime(timebuf, timebuflen, "(%T): ", time_breakdown);
    } else {
      /* if we don't have clock skew, we can't figure out when
         it happened in client time terms; show time as unknown. */
      time_breakdown = localtime(&(ts_loc.tv_sec));
      sprintf(timebuf, "(--:--:--): ");
    }
  } // End timestamp calculations
}

void
write_line_to_screen  (ProcessWidget* pw,
                       char           lineType,
                       const char*    timebuf,
                       string         textStr,
#ifdef USE_ZVT_TERM
                       char          *colorCode,
#else
                       GdkColor      *fgColor,
#endif
                       bool           filterThisLine)
{
  string         tsOutput;
#ifdef USE_ZVT_TERM
  ZvtTerm       *logText;
#else
  ClawText      *logText;
#endif

#ifdef USE_ZVT_TERM
  logText = ZVT_TERM(pw->LogText);
  tsOutput = "";
  if (pw->last_line_type != 'c'
      && prefs_get_display_timestamps() ) {
    tsOutput += timebuf;
  }
  tsOutput += textStr;
  pw->last_line_type = lineType;
#else
  logText = CLAW_TEXT(pw->LogText);

  tsOutput = "";
  if (logText->get_last_line_type() != 'c'
      && prefs_get_display_timestamps() ) {
    tsOutput += timebuf;
  }
  tsOutput += textStr;
#endif

  //process_data_from_label(&tmp_pd, searchName, NULL);

#ifdef USE_ZVT_TERM
  // the print_cr_next_time logic avoids obscuring the
  //   first character of the line under the cursor
  static bool print_cr_next_time = false;

  if (print_cr_next_time) {
    processWidget_term_feed(pw, "\r", 1);
    print_cr_next_time = false;
  }

  if(lineType == 'x') tsOutput += "\n\r";
  if(lineType == 'r') print_cr_next_time = true;

  // If we're filtering, change the background
  processWidget_term_feed(pw, colorCode, strlen(colorCode));
  if(filterThisLine) {
    //cout << "Printing filter background: " << mr_filter_code << " (blah)" << endl;
    processWidget_term_feed(pw, mr_filter_code, strlen(mr_filter_code));
  }

  processWidget_term_feed(pw, (char*) tsOutput.c_str(), tsOutput.length());
  //processWidget_term_feed(pw, mr_ok_code, strlen(mr_ok_code));

  // ...and revert it.
  if(filterThisLine) {
    //cout << "Printing nofilter background: " << mr_nofilter_code << " (blah)" << endl;
    processWidget_term_feed(pw, mr_nofilter_code, strlen(mr_nofilter_code));
  }

#if 0
  if(lineType == 'x') {
    processWidget_term_feed(pw, "\n\r", 2);
    cerr << "<nr>\n\r";
  }
#endif
  //if(lineType == 'r') processWidget_term_feed(pw, "\r", 1);
#else
  logText = CLAW_TEXT(pw->LogText);
  logText->insert(tsOutput, lineType, /* font = */ NULL, fgColor, /* bgColor = */ NULL);
#endif
}


// WARNING: this doesn't deal well wrt timestamps if handed a list of 
//          processes running on different machines, since we only take
//          one timestamp as input.          
// We _really_ should change this to a single-item call or pass in the lists
//
// Regexp matching happens here.
void
print_to_processes                     (const char      *processList,
                                        const char      *machList,
                                        const char      *text,
                                        GtkWidget       *topWid,
#ifdef USE_ZVT_TERM
                                        char            *colorCode,
#else
                                        GdkColor        *fgColor,
#endif
                                        timeval         *ts,
                                        char            lineType)
{
  // FIXME: TODO: maybe use get_process_widget
  //GtkTable      *processTable;
  //GtkTableChild *table_child;
  GtkCTree      *processTree;
  GList         *treeList;
  GList         *list;
  GList         *walker;
  ProcessData   *ambler;
  char          *searchList;
  char          *searchName;
  unsigned int   bufSize = 1024;
  char           timebuf[128];
  ProcessWidget *pw;
  string         textStr;
  //ProcessData    tmp_pd;

  /*fprintf(stderr, "print_to_processes: lineType = %c\n", lineType);*/

  /* Munge the process and machine lists together */
  list = strings_to_glist(processList, NULL, machList);

  if(list == NULL) return;

  /* Fills with NULL pointers */
  //init_process_data(&tmp_pd);

  /* Build a list of procName@machName pairs */
  searchList = (char*) malloc(sizeof(char)*bufSize);
  searchList[0] = '\0';
  for(walker = list; walker; walker = g_list_next(walker)) {
    ambler = (ProcessData*) walker->data;
    if(ambler->procName != NULL && ambler->machName != NULL) {
      safecat(searchList, ambler->procName, &bufSize);
      safecat(searchList, "@",            &bufSize);
      safecat(searchList, ambler->machName, &bufSize);
      safecat(searchList, " ",              &bufSize);
    }
  }
  
  /* Find the affected elements and write to them */
  /* Ah, damn.  We need to loop through the ctree, not the process table. */
  //cerr << "Entering print_to_processes..." << endl;
  processTree = GTK_CTREE(lookup_widget(topWid, "ProcessTree"));
  treeList = get_all_data(processTree, PROCESS_NODE);
  // Loop through all process nodes, viewed or not.
  FOR_GLIST(walker, treeList) {
    if(walker->data == NULL || ((ProcessDataAug*) walker->data)->pw == NULL) {
      //cerr << "Argh! this is not a ProcessWidget!" << endl;
      //print_process_data((ProcessData*) walker->data);
      //cerr << endl;
      continue;
    }
    //cerr << "\tProcessing ";
    //print_process_data_aug((ProcessDataAug*) walker->data);
    //cerr << endl;
    pw = PROCESSWIDGET(((ProcessDataAug*) walker->data)->pw);
    gtk_label_get(GTK_LABEL(pw->ProcessNameLabel), &searchName);    
    if(strstr(searchList, searchName) != NULL) 
    {
      GdkColor colorBlack;
      colorBlack.red = colorBlack.green = colorBlack.blue = 0;
      bool filterThisLine = ( pw->regexpActive
                              // only filter "OK" (e.g. normal) text
#ifdef USE_ZVT_TERM
                              && !strcmp(colorCode, mr_ok_code)
#else
                              && gdk_color_equal(fgColor, &colorBlack)
#endif
        );

      textStr = text;
      /* We now know this is the process we want.  Perform regexp
       * matching here. */
      if(filterThisLine) {
        // If we're matching regexps, we want to match on full
        // lines, which means doing a bit of extra buffering here,
        // since we don't want to try matching against continued
        // ('c') lines.
        *(pw->regexpBuffer) += textStr;
        if(lineType == 'c') {
          //cerr << "Continued line; continuing" << endl;
          continue;
        } else { // Match 'r' and 'x's
          int errorCode;
          if((errorCode = regexec(&pw->regexpPatternBuffer, pw->regexpBuffer->c_str(), 0, NULL, 0)) == 0) {
            //cerr << "Matched: " << textStr << endl;
            // Print out the precontext buffer (if any)
            while(pw->regexpPreContextBuffer.size() > 0) {
              string pcb = pw->regexpPreContextBuffer.front();
              //cerr << "  Precontext buffer: " << pcb << endl;
              timestamp_output(ts, searchName, timebuf, sizeof(timebuf));
              // Hmm.  May run into colorizing problems; have to check.
#ifdef USE_ZVT_TERM
              write_line_to_screen(pw, 'x', timebuf, pcb, colorCode, true);
#else
              write_line_to_screen(pw, 'x', timebuf, pcb, fgColor, true);
#endif
              // Deques don't seem to work for some reason.  Argh.
              //pw->regexpPreContextBuffer.pop_front();
              pw->regexpPreContextBuffer.erase(pw->regexpPreContextBuffer.begin());
            }
            // MATCH!
            textStr = *(pw->regexpBuffer);
            *(pw->regexpBuffer) = "";
            // Restart the postcontext counter on a match.
            pw->regexpPostContextRemaining = pw->regexpPostContext;
            //cerr << "PostContextRemaining reset to " << pw->regexpPostContextRemaining << endl;
          } else {
            if(errorCode != REG_NOMATCH) {
              char errBuf[4096];
              regerror(errorCode, &pw->regexpPatternBuffer, errBuf, 4096);
              string toBuffer = "Regexp Error: ";
              toBuffer += errBuf;
              print_to_common_buffer(toBuffer.c_str(), ERROR_COL);
              *(pw->regexpBuffer) = "";
              continue;
            } else {
              //cerr << "Did not match: " << pw->regexpBuffer << endl;
              //If we still have post-context remaining, set textStr
              //and fall through to the print code below.
              if(pw->regexpPostContextRemaining > 0) {
                //cerr << "Post context 'match'." << endl;
                textStr = *(pw->regexpBuffer);
                pw->regexpPostContextRemaining--;
                *(pw->regexpBuffer) = "";
              }
              // If we didn't match, and didn't post-context match,
              // buffer for pre-context matching if needed.
              else if(pw->regexpPreContext > 0) {
                //cerr << "Pushing onto pre-context buffer: " << *(pw->regexpBuffer) << endl;
                pw->regexpPreContextBuffer.push_back(*(pw->regexpBuffer));
                while(pw->regexpPreContextBuffer.size() > pw->regexpPreContext) {
                  //cerr << "Popping off of pre-context buffer: " << pw->regexpPreContextBuffer.front() << endl;
                  // Deques don't seem to work for some reason.  Argh.
                  //pw->regexpPreContextBuffer.pop_front();
                  pw->regexpPreContextBuffer.erase(pw->regexpPreContextBuffer.begin());
                }
                *(pw->regexpBuffer) = "";
                continue;
              }
              else {
                *(pw->regexpBuffer) = "";
                continue;
              }
            }
          } // End "line didn't match"
        }
      } // End "filter this line"

      timestamp_output(ts, searchName, timebuf, sizeof(timebuf));

#ifdef USE_ZVT_TERM
      write_line_to_screen(pw, lineType, timebuf, textStr, colorCode, filterThisLine);
#else
      write_line_to_screen(pw, lineType, timebuf, textStr, fgColor, filterThisLine);
#endif

    } // End "this process is being printed to"
  } // End loop through process nodes

  /* Free the GList and all data elements (ProcessData's and associated strings) */
  free(searchList);
  for(walker = list; walker; walker = g_list_next(walker)) {
    free_process_data((ProcessData*) walker->data);
  }  
  g_list_free(list);
  /* Free the treeList, which was returned by get_all_data */
  free_process_data_list(treeList, true);
  g_list_free(treeList);
}

void
print_to_processes                     (const char      *processList,
                                        const char      *machList,
                                        const char      *text,
                                        GtkWidget       *topWid,
                                        enum printColors pc,
                                        timeval         *ts,
                                        char            lineType)
{
#ifdef USE_ZVT_TERM
  print_to_processes(processList, machList, text, topWid, enum_to_code(pc), ts, lineType);
#else
  GdkColor col = enum_to_color(pc);
  print_to_processes(processList, machList, text, topWid, &col, ts, lineType);
#endif
}


void
print_to_lower_buffer                  (ClawText        *buffer,
                                        const char      *toprint,
                                        GdkColor        *fgColor)
{
  string tsOutput;
  timeval ts;
  struct tm* time_breakdown;
  char timebuf[128];

  if(fgColor == NULL || toprint == NULL || HeadDino_g == NULL) {
    cerr << toprint << endl;
    return;
  }

  // Get time of day for timestamping
  gettimeofday(&ts, NULL);

  // Timestamp output
  time_breakdown = localtime(&(ts.tv_sec));
  strftime(timebuf, sizeof(timebuf), "(%T): ", time_breakdown);
  tsOutput = timebuf;
  tsOutput += toprint;

  buffer->insert(tsOutput, /* line_type = */ 'x', /* font = */ NULL, fgColor, /* bg_color = */ NULL);

}

void
print_to_common_buffer                 (const char      *toprint,
                                        GdkColor        *fgColor)
{
  static bool errorImage = false;
  ClawText* errorOut;
  // Can't output to the buffer when the window doesn't exist! :-)
  // This can occur if you try to load a config file that doesn't
  // exist using the --config commandline options.
  if(HeadDino_g == NULL) {
    return;
  }
  errorOut = CLAW_TEXT(lookup_widget(HeadDino_g, "ErrorOutput"));
  // If we're printing in a brightish red, put up an error image.
  if(fgColor->red > 40000 && fgColor->blue < 500 && fgColor->green < 500) {
    set_gratuitous_image(true);
    errorImage = true;
  }
  // Otherwise, revert.
  else {
    if(errorImage) {
      set_gratuitous_image(false);
      errorImage = false;
    }
  }
  print_to_lower_buffer(errorOut, toprint, fgColor);

  // Echo to stderr
  cerr << toprint << endl;
}

void
print_to_chat_buffer                   (const char      *toprint,
                                        GdkColor        *fgColor)
{
  ClawText* chatOut;
  chatOut = CLAW_TEXT(lookup_widget(HeadDino_g, "ChatOutput"));
  print_to_lower_buffer(chatOut, toprint, fgColor);  
}


/* Wrapper to keep C++ folks happy */
void
update_skew_display                    (string           daemon,
                                        string           skew)
{  
  update_skew_display(daemon.c_str(), skew.c_str());
}

/* Update skew display in processTree */
void
update_skew_display                    (const char      *daemon,
                                        const char      *skew)
{
  GtkCTreeNode *machNode;
  GtkCTree *processTree;
  char *dupSkew;
  EntryData targRowData;
  targRowData.pw = NULL;
  if(daemon == NULL || skew == NULL) return;

  dupSkew = strdup(skew);

  processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));  

  // Find node associated with this daemon
  targRowData.label = (char*) daemon;
  machNode = gtk_ctree_find_by_row_data_custom(processTree,
                                               NULL, /* Where to start searching (root) */
                                               &targRowData,
                                               rowCompareFunc);  
  if(machNode != NULL) {
    // Update data
    gtk_ctree_node_set_text(processTree, machNode, 1, dupSkew);
  } else {
    string errStr = "ERROR: Received clock skew of ";
    errStr += skew;
    errStr += " for daemon ";
    errStr += daemon;
    errStr += " that we haven't been introduced to.  Learn your manners!";
    print_to_common_buffer(errStr, ERROR_COL);
    free(dupSkew);
  }
}

bool
is_accepting_input                     (const char      *status)
{
  // Use Trey's utility
  try {
    bool takesinput = !(Process_Status::is_runnable(string(status)));
    if(strcmp(status, "pending") == 0) takesinput = true;
    return takesinput;  
  } catch(MRException e) {
    //cerr << "is_accepting_input: caught exception: " << e.text << endl;
    // If we don't know what the status string means, it's probably
    //  not running. ;)
    return false;    
  }
    return false;    
}

bool
is_running                             (const char      *status)
{
  // Use Trey's utility
  try{
    return !(Process_Status::is_runnable(string(status)));
  } catch(MRException e) {
    //cerr << "is_running: caught exception: " << e.text << endl;
    // If we don't know what the status string means, it's probably
    //  not running. ;)
    return false;
  }
  return false;
}

// Locally global; for use with callback
int group_running_cnt_g;
int group_notrunning_cnt_g;

bool
is_group_running_helper                (const char      *machName,
                                        const char      *procName,
                                        const char      *status)
{
  if(is_running(status)) group_running_cnt_g++;
  else group_notrunning_cnt_g++;
  return true;
}

enum groupRunningState
is_group_running                       (ProcessData     *pd)
{
  group_running_cnt_g = group_notrunning_cnt_g = 0;
  
  apply_func_to_grp_members(get_node_from_process_data(pd), 
                            GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree")), 
                            NULL, 
                            is_group_running_helper);

  // We only count as running if the whole group is running
  if(group_notrunning_cnt_g == 0) return ALL_ALIVE;
  else if(group_running_cnt_g == 0) return ALL_DEAD;
  else return DEAD_AND_ALIVE;
}

// Locally global; for use with callback
int group_subscribed_cnt_g;
int group_notsubscribed_cnt_g;

bool
is_group_subscribed_helper                (const char      *machName,
                                           const char      *procName,
                                           const char      *status)
{
  hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>::iterator sit;        
  ProcessData pd;
  init_process_data(&pd);

  // We promise not to screw with pd's contents
  fill_process_data_shallow(&pd, (char*) procName, (char*) machName, (char*) status);

  sit = subscriptions_g->find(pd);

  if(sit != subscriptions_g->end() && (*sit).second.first)
    group_subscribed_cnt_g++;
  else 
    group_notsubscribed_cnt_g++;
  return true;
}

enum groupSubState
is_group_subscribed                    (ProcessData     *pd)
{
  group_subscribed_cnt_g = group_notsubscribed_cnt_g = 0;
  
  apply_func_to_grp_members(get_node_from_process_data(pd), 
                            GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree")), 
                            NULL, 
                            is_group_subscribed_helper);

  // We only count as subscribed if the whole group is subscribed
  if(group_notsubscribed_cnt_g == 0) return ALL_SUB;
  else if(group_subscribed_cnt_g == 0) return ALL_UNSUB;
  else return SUB_AND_UNSUB;
}

GdkColor
status_to_color(const char* status)
{
  GdkColor retval;
  retval.red = retval.blue = retval.green = 0;
  if(strcmp(status, "not_started") == 0
     || strcmp(status, "unknown") == 0) {
    // Do nothing; we want black
  } else if(strcmp(status, "running") == 0) {
    retval.green = 32000;
  } else if(strcmp(status, "clean_exit") == 0) {
    // Do nothing; we want black
  } else if(strcmp(status, "error_exit") == 0) {
    retval.red = 65535;
  } else if(strcmp(status, "signal_exit") == 0) {
    // Do nothing; we want black
  } else if(strcmp(status, "pending") == 0) {
    // Dark blue
    retval.blue = 65535;
  } else if(strcmp(status, "starting") == 0) {
    // Light blue
    retval.blue = 65535;
    retval.red = retval.green = 32000;
  } else {
    cerr << "WARNING: status_to_color called with unknown status \"" << status
         << "\"; returning black." << endl;
  }
  return retval;
}

GdkColor
enum_to_color                          (enum printColors pc)
{
  GdkColor retval;
  retval.red = retval.green = retval.blue = 0;
  switch(pc) {
  case GOOD_COL:    retval.green = 32000; break;
  case OK_COL:      break; // black
  case WARNING_COL: retval.red = 32000;   break;
  case ERROR_COL:   retval.red = 65532;   break;
  case SPECIAL_COL: retval.blue = 65532;  break;
  case STDIN_COL:   retval.blue = 65532;  break;
  case STATUS_COL:  retval.green = 32000; break;
  case ACTION_COL:  retval.red = 35464; retval.green = 20559; break; // brown
  case FILTER_COL:   retval.red = retval.green = 65532; retval.blue = 41118; break; // yellow
  case NOFILTER_COL: retval.red = retval.green = retval.blue = 65532; break; // white
  }
  return retval;
}

char*
enum_to_code                           (enum printColors pc)
{
  switch(pc) {
  case GOOD_COL:    return mr_good_code;
  case OK_COL:      return mr_ok_code;
  case WARNING_COL: return mr_warning_code;
  case ERROR_COL:   return mr_error_code;
  case SPECIAL_COL: return mr_special_code;
  case STDIN_COL:   return mr_stdin_code;
  case STATUS_COL:  return mr_status_code;
  case ACTION_COL:  return mr_action_code;
  case FILTER_COL:   return mr_filter_code;
  case NOFILTER_COL: return mr_nofilter_code;
  }
  return mr_ok_code;
}

void
print_to_common_buffer                 (const char        *toprint,
                                        enum printColors pc)
{
  GdkColor col = enum_to_color(pc);
  print_to_common_buffer(toprint, &col);
}

void
print_to_common_buffer                 (string            toprint,
                                        enum printColors pc)
{ 
  print_to_common_buffer(toprint.c_str(), pc); 
}

void
print_to_chat_buffer                   (const char        *toprint,
                                        enum printColors pc)
{
  GdkColor col = enum_to_color(pc);
  print_to_chat_buffer(toprint, &col);
}

void
print_to_chat_buffer                   (string            toprint,
                                        enum printColors pc)
{ 
  print_to_chat_buffer(toprint.c_str(), pc); 
}

GtkWidget*
get_process_widget                     (const char      *processName,
                                        const char      *machName)
{
  EntryData targRowData;
  GtkCTreeNode *targNode;
  GtkCTree     *processTree;

  /* Find the machine */
  processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  targRowData.label = (char*) machName;  
  targNode = gtk_ctree_find_by_row_data_custom(processTree, NULL, &targRowData, rowCompareFunc);

  /* Find the process, if the machine exists */
  if(targNode != NULL) { 
    targRowData.label = (char*) processName;
    targNode = gtk_ctree_find_by_row_data_custom(processTree, targNode, &targRowData, rowCompareFunc);
    
    if(targNode != NULL) {
      EntryData* curRowData = (EntryData*) gtk_ctree_node_get_row_data(processTree, targNode);
      if(curRowData != NULL && curRowData->pw != NULL) {
        return curRowData->pw;
      }
    }
  }
  return NULL;
}

/* If error is true, pick an image from the "error" set; otherwise
   reset to the microraptor image
*/
void
set_gratuitous_image                   (bool error)
{
#ifndef NO_BIG_XPMS
  // Set the image, whether we're currently viewing it or not.
  // That way, if we turn it on in the middle, it's already set
  //  correctly. 
  GdkPixmap* pixmap;
  GdkBitmap *mask;
  GtkStyle *style;
  const char **xpmArray;
  int numPix = 11;
  int pickedPic;

  GtkWidget* im = lookup_widget(HeadDino_g, "RaptorImage");
  if(error) {
    pickedPic = rand() % numPix;
    switch(pickedPic) {
    case 0:  xpmArray = meteorBlue_xpm; break;
    case 1:  xpmArray = meteorCartoon_xpm; break;
    case 2:  xpmArray = meteorCrater_xpm; break;
    case 3:  xpmArray = meteorFlaming_xpm; break;
    case 4:  xpmArray = brontoMeteor_h; break;
    case 5:  xpmArray = atmosphereImpact1_h; break;
    case 6:  xpmArray = atmosphereImpact2_h; break;
    case 7:  xpmArray = oceanImpact_h; break;
    case 8:  xpmArray = asteroid_h; break;
    case 9:  xpmArray = flamingDinos_h; break;
    case 10: xpmArray = flamingAtmosphere_h; break;
    default: xpmArray = meteorBlue_xpm; break;
    }
  } else {
    xpmArray = microRaptor_xpm;
  }
  style = gtk_widget_get_style( HeadDino_g );
  pixmap = gdk_pixmap_create_from_xpm_d( HeadDino_g->window, &mask,
                                         &style->bg[GTK_STATE_NORMAL],
                                         (char **)xpmArray );
  gtk_pixmap_set(GTK_PIXMAP(im), pixmap, mask);
#endif
}

/* Enable or disable the stdin entry for a given process.  We used to
 * hide it entirely, but we want to be able to change the filter when
 * a process is dead. */
void
toggle_stdin_entry                     (const char *procName, 
                                        const char *machName,
                                        bool show)
{
  if(procName == NULL || machName == NULL) return;
  GtkWidget* pw = get_process_widget(procName, machName);
  if(pw == NULL) return;
  if(show) {
    //gtk_widget_show_now(PROCESSWIDGET(pw)->entryBox);
    gtk_editable_set_editable(GTK_EDITABLE(PROCESSWIDGET(pw)->stdinEntry), TRUE);
    gtk_widget_set_sensitive(PROCESSWIDGET(pw)->stdinEntry, TRUE);
  } else {
    //gtk_widget_hide(PROCESSWIDGET(pw)->entryBox);
    gtk_editable_set_editable(GTK_EDITABLE(PROCESSWIDGET(pw)->stdinEntry), FALSE);
    gtk_widget_set_sensitive(PROCESSWIDGET(pw)->stdinEntry, FALSE);
  }
}

void
toggle_stdin_entry                     (string procName, 
                                        string machName,
                                        bool show)
{
  toggle_stdin_entry(procName.c_str(), machName.c_str(), show);
}

enum triBool
calc_grpmem(ProcessData* pd, int curPage = -42, int* isOverview = NULL)
{
  GtkNotebook * nb;
  GtkWidget* tabLabel;
  char* labelText;
  //ProcessData tabPD;
  triBool grpMem = TRUE_TB;

  // First, find the label of the current tab
  nb = GTK_NOTEBOOK(lookup_widget(HeadDino_g, "notebook1"));
  if(curPage == -42)
    curPage = gtk_notebook_get_current_page(nb);
  tabLabel = gtk_notebook_get_tab_label(nb, gtk_notebook_get_nth_page(nb, curPage));
  gtk_label_get(GTK_LABEL(tabLabel), &labelText);

  if(!strcmp(labelText, "Overview")) {
    if(isOverview != NULL) *isOverview = TRUE;
    return FALSE_TB;
  }
  if(isOverview != NULL) *isOverview = FALSE;

  // DUPEDPROCESSFIXME
  //cerr << "  labelText: " << labelText << endl;
  //process_data_from_label(&tabPD, labelText, NULL);  
  // Now, check if our process name matches.  If it does, we're singly-viewed
  //  (not part of a group), and don't need to show this button.
  //cerr << "  max calc: comparing \"" << tabPD.procName << "\" to \"" << pd->procName << "\"" << endl;
  //if(tabPD.procName == NULL || strcmp(tabPD.procName, pd->procName) != 0)
  if(!strcmp(labelText, pd->procName)) {
    grpMem = FALSE_TB;
  }
  //free_process_data_members(&tabPD);
  return grpMem;
}

void
processWidget_button_showandtell(GtkWidget* pw,
                                 ProcessData* pd,
                                 int curPage)
{
  // Use the real deal
  //cerr << "pwbs, curPage version" << endl;
  int isOverview;
  enum triBool grpMem = calc_grpmem(pd, curPage, &isOverview);
  //cerr << "      grpMem: " << grpMem << ", isOverview: " << isOverview << endl;
  processWidget_button_showandtell(pw, pd, grpMem, isOverview);
}

void
processWidget_button_showandtell(GtkWidget* pw, 
                                 ProcessData* pd,
                                 enum triBool grpMemTb,
                                 int isOverview)
{
  char* itemName;
  GList* walker;
  hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>::iterator sit;        
  bool grpMem = false;

  if(grpMemTb == UNKNOWN_TB) {
    grpMem = calc_grpmem(pd, -42, &isOverview);
  } else {
    grpMem = grpMemTb ? true : false;
  }

  if(pw == NULL || pd == NULL) return;

  sit = subscriptions_g->find(*pd);
        
  //cerr << "      " << pd->procName << ": grpMem: " << grpMem << ", isOverview: " << isOverview << endl;
  /* Loop through children, showing or hiding them as we see fit */
  for(walker = g_list_first(gtk_container_children(GTK_CONTAINER(PROCESSWIDGET(pw)->ProcessURButtons)));
      walker;
      walker = g_list_next(walker)) {
    if(walker->data == NULL) continue;    
    itemName = (char *) gtk_object_get_user_data(GTK_OBJECT(walker->data));
    //cerr << "  Processing " << itemName << "... " << endl;;

    if(strcmp(itemName, "R") == 0) { // Run
      if(is_running(pd->status)) {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      } else {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      }
    } else if(strcmp(itemName, "K") == 0) { // Kill
      if(!is_running(pd->status)) {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      } else {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      }
    } else if(strcmp(itemName, "I") == 0) { // sIgnal
      if(!is_running(pd->status)) {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      } else {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      }
    } else if(strcmp(itemName, "S") == 0) { // Subscribe
      if(sit != subscriptions_g->end()
         && (*sit).second.first) {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      } else {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      }
    } else if(strcmp(itemName, "U") == 0) { // Unsubscribe
      if(sit == subscriptions_g->end()
         || !(*sit).second.first) {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      } else {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      }
    } else if(strcmp(itemName, "H") == 0) { // Hide
      if(grpMem) {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      } else {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      }
    } else if(strcmp(itemName, "M") == 0) { // Maximize
      if(grpMem || isOverview) {
        gtk_widget_show(GTK_WIDGET(walker->data)); //cerr << "Shown" << endl;
      } else {
        gtk_widget_hide(GTK_WIDGET(walker->data)); //cerr << "Hidden" << endl;
      }
    } 
  }
  //cerr << "pwbs: leaving" << endl;
}


GtkMenu*
pw_popup_menu                          (void)
{  
  GtkWidget* popup_menu;
  GtkWidget* run_item;
  GtkWidget* run_group_item;
  GtkWidget* run_rem_item;
  GtkWidget* kill_item;
  GtkWidget* kill_group_item;
  GtkWidget* kill_rem_item;
  GtkWidget* signal_item;
  GtkWidget* signal_group_item;
  GtkWidget* signal_rem_item;  
  GtkWidget* view_item;
  GtkWidget* view_max_item;
  GtkWidget* hide_item;
  GtkWidget* sub_item;
  GtkWidget* sub_group_item;
  GtkWidget* sub_rem_item;
  GtkWidget* unsub_item;
  GtkWidget* unsub_group_item;
  GtkWidget* unsub_rem_item;
  GtkWidget* set_config_item;  
  GtkWidget* reset_buffer_item;

  popup_menu = gtk_menu_new ();

  /* Create menu items if applicable */

  /* Run option (kill at end to prevent accidental clickage) */
  run_item = gtk_menu_item_new_with_label(_("Run"));
  gtk_menu_append(GTK_MENU(popup_menu), run_item);
  gtk_signal_connect (GTK_OBJECT (run_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_run_item_activate),
                      NULL);
  gtk_widget_show (run_item);

  /* Run group; used for group popup menus */
  run_group_item = gtk_menu_item_new_with_label(_("Run group"));
  gtk_menu_append(GTK_MENU(popup_menu), run_group_item);
  gtk_signal_connect (GTK_OBJECT (run_group_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_run_item_activate),
                      NULL);
  gtk_widget_show (run_group_item);

  /* Run remainder of group; used for group popup menus */
  run_rem_item = gtk_menu_item_new_with_label(_("Run remainder"));
  gtk_menu_append(GTK_MENU(popup_menu), run_rem_item);
  gtk_signal_connect (GTK_OBJECT (run_rem_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_run_item_activate),
                      NULL);
  gtk_widget_show (run_rem_item);

  /* View / hide items */
  view_item = gtk_menu_item_new_with_label(_("View"));
  gtk_menu_append(GTK_MENU(popup_menu), view_item);
  gtk_signal_connect (GTK_OBJECT (view_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_view_item_activate),
                      NULL);
  gtk_widget_show (view_item);

  view_max_item = gtk_menu_item_new_with_label(_("View maximized"));
  gtk_menu_append(GTK_MENU(popup_menu), view_max_item);
  gtk_signal_connect (GTK_OBJECT (view_max_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_view_item_activate), // Same as view
                      NULL);
  gtk_widget_show (view_max_item);

  hide_item = gtk_menu_item_new_with_label(_("Hide"));
  gtk_menu_append(GTK_MENU(popup_menu), hide_item);
  gtk_signal_connect (GTK_OBJECT (hide_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_hide_item_activate),
                      NULL);
  gtk_widget_show (hide_item);

  /* Subscribe / unsubscribe items */
  sub_item = gtk_menu_item_new_with_label(_("Subscribe"));
  gtk_menu_append(GTK_MENU(popup_menu), sub_item);
  gtk_signal_connect (GTK_OBJECT (sub_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_sub_item_activate),
                      NULL);
  gtk_widget_show (sub_item);

  sub_group_item = gtk_menu_item_new_with_label(_("Subscribe group"));
  gtk_menu_append(GTK_MENU(popup_menu), sub_group_item);
  gtk_signal_connect (GTK_OBJECT (sub_group_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_sub_item_activate),
                      NULL);
  gtk_widget_show (sub_group_item);

  sub_rem_item = gtk_menu_item_new_with_label(_("Subscribe remainder"));
  gtk_menu_append(GTK_MENU(popup_menu), sub_rem_item);
  gtk_signal_connect (GTK_OBJECT (sub_rem_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_sub_item_activate),
                      NULL);
  gtk_widget_show (sub_rem_item);

  unsub_item = gtk_menu_item_new_with_label(_("Unsubscribe"));
  gtk_menu_append(GTK_MENU(popup_menu), unsub_item);
  gtk_signal_connect (GTK_OBJECT (unsub_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_unsub_item_activate),
                      NULL);
  gtk_widget_show (unsub_item);

  unsub_group_item = gtk_menu_item_new_with_label(_("Unsubscribe group"));
  gtk_menu_append(GTK_MENU(popup_menu), unsub_group_item);
  gtk_signal_connect (GTK_OBJECT (unsub_group_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_unsub_item_activate),
                      NULL);
  gtk_widget_show (unsub_group_item);

  unsub_rem_item = gtk_menu_item_new_with_label(_("Unsubscribe remainder"));
  gtk_menu_append(GTK_MENU(popup_menu), unsub_rem_item);
  gtk_signal_connect (GTK_OBJECT (unsub_rem_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_unsub_item_activate),
                      NULL);
  gtk_widget_show (unsub_rem_item);

  /* Always allow the user to set the config */
  set_config_item = gtk_menu_item_new_with_label(_("Set config"));
  gtk_menu_append(GTK_MENU(popup_menu), set_config_item);
  gtk_signal_connect (GTK_OBJECT (set_config_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_set_config_item_activate),
                      NULL);
  gtk_widget_show (set_config_item);

  /* Kill option */
  kill_item = gtk_menu_item_new_with_label(_("Kill"));
  gtk_menu_append(GTK_MENU(popup_menu), kill_item);
  gtk_signal_connect (GTK_OBJECT (kill_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_kill_item_activate),
                      NULL);
  gtk_widget_show (kill_item);

  /* Analagous to kill for groups */
  kill_group_item = gtk_menu_item_new_with_label(_("Kill group"));
  gtk_menu_append(GTK_MENU(popup_menu), kill_group_item);
  gtk_signal_connect (GTK_OBJECT (kill_group_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_kill_item_activate),
                      NULL);
  gtk_widget_show (kill_group_item);

  /* Also analagous to kill for groups */
  kill_rem_item = gtk_menu_item_new_with_label(_("Kill remainder"));
  gtk_menu_append(GTK_MENU(popup_menu), kill_rem_item);
  gtk_signal_connect (GTK_OBJECT (kill_rem_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_kill_item_activate),
                      NULL);
  gtk_widget_show (kill_rem_item);

  /* Signal option */
  GtkWidget* processTree = lookup_widget(HeadDino_g, "ProcessTree");

  signal_item = gtk_menu_item_new_with_label(_("Signal"));
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(signal_item), build_signal_submenu(processTree, 1));
  gtk_menu_append(GTK_MENU(popup_menu), signal_item);
  gtk_widget_show (signal_item);

  /* Analagous to signal for groups */
  signal_group_item = gtk_menu_item_new_with_label(_("Signal group"));
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(signal_group_item), build_signal_submenu(processTree, 1));
  gtk_menu_append(GTK_MENU(popup_menu), signal_group_item);
  gtk_widget_show (signal_group_item);

  /* Also analagous to signal for groups */
  signal_rem_item = gtk_menu_item_new_with_label(_("Signal remainder"));
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(signal_rem_item), build_signal_submenu(processTree, 1));
  gtk_menu_append(GTK_MENU(popup_menu), signal_rem_item);
  gtk_widget_show (signal_rem_item);

  /* Reset / clear buffer */
  reset_buffer_item = gtk_menu_item_new_with_label(_("Clear buffer"));
  gtk_menu_append(GTK_MENU(popup_menu), reset_buffer_item);
  gtk_signal_connect (GTK_OBJECT (reset_buffer_item), "activate",
                      GTK_SIGNAL_FUNC (on_pw_popup_reset_buffer_item_activate),
                      NULL);
  gtk_widget_show (reset_buffer_item);

  return GTK_MENU(popup_menu);
}

GtkWidget*
build_signal_submenu                   (GtkWidget* processTree, int popup_mode, gboolean clickHack)
{
  GtkWidget* signal_submenu = gtk_menu_new();
  // Supported signals are: HUP, INT, ILL, ABRT, BUS, SEGV, PIPE, TERM, and KILL
  vector<pair<string, string> > signalList;
  signalList.push_back(pair<string, string>("HUP", "Hangup; death of parent"));
  signalList.push_back(pair<string, string>("INT", "Interrupt; Ctrl+C"));
  signalList.push_back(pair<string, string>("ILL", "Illegal Instruction"));
  signalList.push_back(pair<string, string>("ABRT", "Abort; force a core dump"));
  signalList.push_back(pair<string, string>("BUS", "Bus error; no core dump"));
  signalList.push_back(pair<string, string>("SEGV", "Invalid memory reference"));
  signalList.push_back(pair<string, string>("PIPE", "Broken pipe"));
  signalList.push_back(pair<string, string>("TERM", "Terminate (catchable)"));
  signalList.push_back(pair<string, string>("KILL", "Kill (uncatchable)"));

  for(vector<pair<string, string> >::iterator slit = signalList.begin();
      slit != signalList.end();
      slit++) {
    string label = (*slit).first;
    label += ": ";
    label += (*slit).second;
    GtkWidget* signal_submenu_item = gtk_menu_item_new_with_label (_(label.c_str()));
    gtk_menu_append (GTK_MENU (signal_submenu), signal_submenu_item);
    pair<GtkWidget*, string>* callbackData = new pair<GtkWidget*, string>(processTree, (*slit).first);
    if(popup_mode) {
      gtk_signal_connect (GTK_OBJECT (signal_submenu_item), "activate",
                          GTK_SIGNAL_FUNC (on_pw_popup_signal_item_activate),
                          callbackData);
      if(clickHack) {
        // Sigh.  It's taking a double-left-click to activate a menu
        // item in a signals menu when it's on its own.  This is a
        // hack.
        gtk_signal_connect (GTK_OBJECT (signal_submenu_item), "button-press-event",
                            GTK_SIGNAL_FUNC (on_pw_popup_signal_button_press_event),
                            callbackData);
      }
    } else {
      gtk_signal_connect (GTK_OBJECT (signal_submenu_item), "activate",
                          GTK_SIGNAL_FUNC (on_menu_signal_selected_activate),
                          callbackData);
    }
    gtk_widget_show (signal_submenu_item);
  }
  return signal_submenu;
}

void claw_quit(void)
{
  cerr << "EXITING..." << endl;

  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));

  if(prefs_get_remember_window() && HeadDino_g->window != NULL) {
    cerr << "\tRemembering current window geometry of ";
    gint x, y, width, height;
    char geomStr[1024];
    x = y = width = height = 0;
    gdk_window_get_root_origin(HeadDino_g->window, &x, &y);
    gdk_window_get_size(HeadDino_g->window, &width, &height);
    sprintf(geomStr, "%dx%d+%d+%d", width, height, x, y);
    prefs_g[0]("initial_window_geometry") = string(geomStr);
    cerr << prefs_initial_window_geometry() << "...done." << endl;
  }

  string prefFile = get_prefs_file_with_default();

  cerr << "\tSaving local preferences to '" << prefFile << "'...";
  bool savedPrefs = true;
  try {
    prefs_g.writeToFile(prefFile);
  } catch (MRException err) {
    savedPrefs = false;
    string errStr = "ERROR!: \n\t";
    errStr += err.text;
    cerr << errStr << endl;
  }
  if(savedPrefs) { cerr << "done."; }

  // First, grab any still-existing process widgets, clean up memory,
  // and drop their data into the library
  GList* pdaList = get_all_data(processTree, PROCESS_NODE);
  FOR_GLIST(walker, pdaList) {
    if(walker->data != NULL && ((ProcessDataAug*) walker->data)->pw != NULL) {
      processWidget_cleanup(((ProcessDataAug*) walker->data)->pw);
    }
  }

  ofstream libraryFile;
  libraryFile.open(historyFilename_g.c_str());
  if(libraryFile.is_open()) {
    cerr << "\n\tSaving history library to '" << historyFilename_g << "'...";

    // Not enough code to be worth functionalizing it.
    string prefix;
    FOR_EACH(libraryIt, persistentStdinCommandHistory_g) {
      prefix = "stdin ";
      prefix += libraryIt->first;
      prefix += " ";
      
      FOR_EACH(histIt, libraryIt->second) {
        libraryFile << prefix << *histIt << endl;
      }
    }

    FOR_EACH(libraryIt, persistentRegexpHistory_g) {
      prefix = "filter ";
      prefix += libraryIt->first;
      prefix += " ";
      
      FOR_EACH(histIt, libraryIt->second) {
        libraryFile << prefix << *histIt << endl;
      }
    }
    libraryFile.close();
    cerr << "done." << endl;
  }
  // Couldn't open the library file
  else {
    cerr << "\n\tWARNING: Unable to save history library; couldn't open '" << historyFilename_g << "'." << endl;
  }


  cerr << "\tRegurgitating any swallowed windows...";;

  GList* tobarf = get_all_data(processTree, SWALLOWED_NODE);
  GList* walker;
  GtkWidget* sock;
  string winName;
  string sockName;
  bool danglingLine = true;

  for(walker = g_list_first(tobarf); walker; walker = g_list_next(walker)) {
    if(walker->data == NULL) {
      continue;
    }
    winName = (char*) ((ProcessDataAug*) walker->data)->procName;
    if(danglingLine) { cerr << endl; danglingLine = false; }
    cerr << "\t\tRegurgitating " << winName << "...";
    // Find socket
    sockName = "socket";
    sockName += winName;
    sock = lookup_widget(HeadDino_g, sockName.c_str());
    // Reparent the child window to the root window
    gdk_window_reparent(GTK_SOCKET(sock)->plug_window, GDK_ROOT_PARENT(), 0, 0);    
    cerr << "done." << endl;
  }
  if(danglingLine) { cerr << "done." << endl; danglingLine = false; }

  //cerr << "\tClosing X display...";
  //XCloseDisplay(root_display_g);
  //cerr << "NOT ";
  //cerr << "done." << endl;

  /* Clean up subscriptions */
  cerr << "\tBeginning memory cleanup...";
  // FIXME: BUGCHECK: this occasionally infinite-loops... 
  /*
  hash_map<ProcessData, bool, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>::iterator sit;
  cerr << "\tCleaning up subscriptions" << flush;
  for(sit = subscriptions_g->begin(); sit != subscriptions_g->end(); sit++) {
    cerr << "." << flush;
    free_process_data_members(&((*sit).first));    
  }
  cerr << " and " << flush;
  free(subscriptions_g);
  cerr << "done!" << endl;
  */
  cerr << "done." << endl;
  //gtk_main_quit();
  gtk_exit(0);
}


void
swallow_window(char* winName, Window window)
{
  GtkWidget* newSock;
  GtkNotebook *nb;
  GtkLabel *newLabel;
  GtkWidget* scroller;
  GtkWidget* table;
  GtkWidget* buttonBox;
  GtkWidget* killButton;
  GdkPixmap* buttonPixmap;
  GtkWidget* buttonGtkPixmap;
  GtkStyle*  style;
  GdkBitmap* mask;
  GtkWidget* throwupButton;
  GdkPixmap* throwupPixmap;
  GtkWidget* throwupGtkPixmap;
  GtkStyle*  throwupstyle;
  GdkBitmap* throwupmask;
  string sockName;
  string annotatedWinName;

  if(string(winName) == topWindowName_g) 
  {
    string warnStr = "WARNING: sorry, you can't swallow the main window.  I'm a dinosaur, not a snake!";
    print_to_common_buffer(warnStr.c_str(), WARNING_COL);
    return;
  }

  // Uniquize the tab name
  string proposedWinName = winName;
  int maxSuffix = -1;
  int usLoc, tmpSuffix;
  GtkCTree* processTree = GTK_CTREE(lookup_widget(HeadDino_g, "ProcessTree"));
  GList* swalList = get_all_data(processTree, SWALLOWED_NODE);  

  FOR_GLIST(walker, swalList) 
  {
    if(walker->data == NULL || ((ProcessDataAug*) walker->data)->procName == NULL)
      continue;
    string curWinName = ((ProcessDataAug*) walker->data)->procName;
    usLoc = curWinName.rfind("_");    
    if(usLoc == -1) 
    { // No _; it might be the first instance of this window      
      if(curWinName == proposedWinName)
        { maxSuffix = 0 > maxSuffix ? 0 : maxSuffix; }
      continue;
    }
    // Add one to make it a size value rather than a 0-based index
    usLoc++;
    if(curWinName.substr(0, usLoc-1) == proposedWinName) 
    {
      tmpSuffix = atoi(curWinName.substr(usLoc).c_str());
      maxSuffix = tmpSuffix > maxSuffix ? tmpSuffix : maxSuffix;
    }
  }

  // Add one to create a new suffix
  maxSuffix++;
  annotatedWinName = winName;
  if(maxSuffix > 0)
  {
    char suf[255];
    sprintf(suf, "_%d", maxSuffix);
    annotatedWinName += suf;
  }
  

  // Set up the socket
  newSock = gtk_socket_new();
  sockName = "socket";
  sockName += annotatedWinName;

  gtk_object_set_data (GTK_OBJECT (HeadDino_g), sockName.c_str(), newSock);
  gtk_widget_show(newSock);

  // Create a parent for it
  scroller = gtk_scrolled_window_new (NULL, NULL);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scroller), GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_object_set_user_data(GTK_OBJECT(scroller), strdup(annotatedWinName.c_str()));
  gtk_widget_show (scroller);

  // We'll use a table to hold the window and its close button
  table = gtk_table_new (2, 1, FALSE);
  gtk_widget_ref (table);
  // Do I actually need the next two lines?  I'm mimic'ing them from
  //  the Glade-generated code...
  gtk_object_set_data_full (GTK_OBJECT (HeadDino_g), "table", table,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (table);
  gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(scroller),
                                        table);
  
  // Create the buttonBox for the kill button
  buttonBox = gtk_hbutton_box_new();
  gtk_button_box_set_child_size(GTK_BUTTON_BOX(buttonBox), 10, 10);
  gtk_button_box_set_child_ipadding(GTK_BUTTON_BOX(buttonBox),2, 2);
  gtk_button_box_set_spacing(GTK_BUTTON_BOX(buttonBox), 2);
  gtk_button_box_set_layout(GTK_BUTTON_BOX(buttonBox), GTK_BUTTONBOX_END);
  gtk_widget_ref (buttonBox);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino_g), "buttonBox", buttonBox,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (buttonBox);
  // Add the buttonBox to the table
  gtk_table_attach (GTK_TABLE (table), buttonBox, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);

  // Grab kill button pixmap
  style = gtk_widget_get_style( HeadDino_g );
  buttonPixmap = gdk_pixmap_create_from_xpm_d( HeadDino_g->window, &mask,
                                               &style->bg[GTK_STATE_NORMAL],
                                               (char **)hideImage_xpm );
  buttonGtkPixmap = gtk_pixmap_new(buttonPixmap, mask);
  gtk_widget_show(buttonGtkPixmap);

  // Grab throwup button pixmap
  throwupstyle = gtk_widget_get_style( HeadDino_g );
  throwupPixmap = gdk_pixmap_create_from_xpm_d( HeadDino_g->window, &throwupmask,
                                               &throwupstyle->bg[GTK_STATE_NORMAL],
						(char **)throwupImage_xpm );
  throwupGtkPixmap = gtk_pixmap_new(throwupPixmap, throwupmask);
  gtk_widget_show(throwupGtkPixmap);

  // Create the throwup button
  throwupButton = gtk_button_new();
  gtk_container_add(GTK_CONTAINER(throwupButton), throwupGtkPixmap);
  gtk_widget_ref (throwupButton);
  gtk_object_set_data_full (GTK_OBJECT (buttonBox), "throwupButton", throwupButton, (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (throwupButton);
  gtk_signal_connect (GTK_OBJECT (throwupButton), "clicked",
                      GTK_SIGNAL_FUNC (on_swallowed_window_throwup_button_clicked),
                      NULL);

  // Add it to the buttonBox
  gtk_box_pack_start(GTK_BOX(buttonBox), 
                     throwupButton, FALSE, FALSE, 0);    
  GTK_WIDGET_UNSET_FLAGS (throwupButton, GTK_CAN_FOCUS);

  // Create the kill button
  killButton = gtk_button_new();
  gtk_container_add(GTK_CONTAINER(killButton), buttonGtkPixmap);
  gtk_widget_ref (killButton);
  gtk_object_set_data_full (GTK_OBJECT (buttonBox), "killButton", 
                            killButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (killButton);
  gtk_signal_connect (GTK_OBJECT (killButton), "clicked",
                      GTK_SIGNAL_FUNC (on_swallowed_window_kill_button_clicked),
                      NULL);

  // Add it to the buttonBox
  gtk_box_pack_start(GTK_BOX(buttonBox), 
                     killButton, FALSE, FALSE, 0);    
  GTK_WIDGET_UNSET_FLAGS (killButton, GTK_CAN_FOCUS);

  // Add the socket to the table
  gtk_table_attach (GTK_TABLE (table), newSock, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);  

  // Stick it in a new tab
  newLabel = GTK_LABEL(gtk_label_new(annotatedWinName.c_str()));
  // Add a tab to the notebook, simultaneously adding the socket
  nb = GTK_NOTEBOOK(lookup_widget(HeadDino_g, "notebook1"));

  //Add the table instead of the scroller to the notebook page?
  gtk_notebook_append_page(nb, GTK_WIDGET(scroller), GTK_WIDGET(newLabel));

  switch_to_tab(annotatedWinName);
  gtk_widget_show(GTK_WIDGET(nb));
  
  // Steal the window
  gtk_socket_steal(GTK_SOCKET(newSock), window);

  // Update the processTree...
  add_swallowed_to_tree(annotatedWinName);
}



int
prefs_get_back_history_length          (void)
{
  int numLines = 50;
  if(prefs_g[0]("back_history_length").defined()
     && prefs_g[0]("back_history_length").getLong()) {
    numLines = prefs_g[0]("back_history_length").getLong();
  }
  return numLines;
}

int
prefs_get_stdin_history_length          (void)
{
  int numLines = 10;
  if(prefs_g[0]("stdin_history_length").defined()
     && prefs_g[0]("stdin_history_length").getLong()) {
    numLines = prefs_g[0]("stdin_history_length").getLong();
  }
  return numLines;
}

int
prefs_get_filter_history_length          (void)
{
  int numLines = 10;
  if(prefs_g[0]("filter_history_length").defined()
     && prefs_g[0]("filter_history_length").getLong()) {
    numLines = prefs_g[0]("filter_history_length").getLong();
  }
  return numLines;
}

enum treeTopLevelSortType
prefs_get_view_mode                    (void)
{  
  if(prefs_g[0]("view_mode").defined()) {
    string mode = prefs_g[0]("view_mode").getString();
    // Default to daemons; try all the usual misspellings of "groups"
    // Just search on a substring to do a loose match
    if(mode.find("gro") < mode.length()
       || mode.find("Gro") < mode.length()
       || mode.find("GRO") < mode.length()
       || mode.find("grp") < mode.length()
       || mode.find("Grp") < mode.length()
       || mode.find("GRP") < mode.length()) {
      return GROUPS_FIRST;
    }
  }
  return DAEMONS_FIRST;
}

/* Return help browser string */
string
prefs_help_browser()
{
  if(prefs_g[0]("help_browser").defined()) {
    return prefs_g[0]("help_browser").getString();
  } else {
    return "firefox %s";
  }
}

/* Return the initial geometry string, if any. */
string
prefs_initial_window_geometry()
{
  if(prefs_g[0]("initial_window_geometry").defined()) {
    return prefs_g[0]("initial_window_geometry").getString();
  } else {
    return "";
  }
}

string
prettify_pref_name                     (string name)
{
  if(islower(name[0])) name[0] = toupper(name[0]);
  // Do this the silly way
  for(unsigned int j = 0; j < name.size(); j++) {
    if(name[j] == '_') name[j] = ' ';
  }
  return name;
}

bool
is_checkbox_pref                       (rcl::exp& e)
{
  if(e.getType() == "vector"
     && e.getVector().size() == 2
     && e.getVector()[0].getType() == "long"
     && e.getVector()[1].getType() == "long"
     && (e.getVector()[0].getLong() == 0 || e.getVector()[0].getLong() == 1)
     && (e.getVector()[1].getLong() == 0 || e.getVector()[1].getLong() == 1) ) {
    return true;
  }
  return false;
}


int
parse_bool_field (string field, rcl::exp prefs)
{
  //cerr << "Checking field \"" << field << "\"" << endl;
  long int val;
  try {
    if(!prefs[0](field.c_str()).defined()) {
      cerr << "Error: parse_bool_field called with a non-existent prefs field (" 
           << field << "). Defaulting to true." << endl;
      return 1;
    }
  } catch(rcl::exception e) {
    cerr << "Hmm.  Caught the following exception:\n\t" << e.text
         << endl << "  while parsing the bool field \"" << field 
         << "\".  Defaulting to true." << endl;
    return 1;
  }
  try {
    val = prefs[0](field.c_str()).getLong();
    return val == 0 ? 0 : 1;
  } catch(rcl::exception e) {
    //cerr << "Caught exception1 (long): " << e.text << endl;
    try {
      string strval = prefs[0](field.c_str()).getString();
      if(strval.find("false") < strval.length()
         || strval.find("FALSE") < strval.length()
         || strval.find("False") < strval.length()
         || strval.find("NO") < strval.length()
         || strval.find("No") < strval.length()
         || strval.find("no") < strval.length()) {
        return 0;
      } else {
        return 1;
      }
    } catch(rcl::exception e) {
      //cerr << "Caught exception2 (string): " << e.text << endl;
      cerr << "Hmm.  Caught the following exception:\n\t" << e.text
           << endl << "  while parsing the bool field \"" << field 
           << "\".  Defaulting to true." << endl;
      return 1;
    } // End catch for <string>
  } // End catch for <long>
}

/* Returns 0 if tie_selection_to_tab is 0 or "false";
   1 otherwise */
int
prefs_get_tie_selection_to_tab         (void)
{
  if(prefs_g[0]("tie_selection_to_tab").defined()) {
    return parse_bool_field("tie_selection_to_tab");
  }
  return 1; // Default to true
}

/* Returns 0 if remember_window is 0 or "false";
   1 otherwise */
int
prefs_get_remember_window              (void)
{
  if(prefs_g[0]("remember_window").defined()) {
    return parse_bool_field("remember_window");
  }
  return 1; // Default to true
}


/* Returns 0 if focus_follows_mouse is 0 or "false";
   1 otherwise */
int
prefs_get_focus_follows_mouse          (void)
{
  if(prefs_g[0]("focus_follows_mouse").defined()) {
    return parse_bool_field("focus_follows_mouse");
  }
  return 0; // Default to false
}


/* Returns 0 if cool_graphics is 0 or "false";
   1 otherwise */
int
prefs_get_cool_graphics                (void)
{
  if(prefs_g[0]("cool_graphics").defined()) {
    string foo = "cool_graphics";
    return parse_bool_field(foo);
  }
  return 1; // Default to true
}

/* Returns 0 if clear_on_run is 0 or "false";
   1 otherwise */
int
prefs_get_clear_on_run                (void)
{
  if(prefs_g[0]("clear_on_run").defined()) {
    string foo = "clear_on_run";
    return parse_bool_field(foo);
  }
  return 1; // Default to true
}

/* Returns 0 if stdout_filtering is 0 or "false";
   1 otherwise */
int
prefs_get_stdout_filtering             (void)
{
  if(prefs_g[0]("stdout_filtering").defined()) {
    string foo = "stdout_filtering";
    return parse_bool_field(foo);
  }
  return 1; // Default to true
}

/* Returns 0 if display_timestamps is 0 or "false";
   1 otherwise */
int
prefs_get_display_timestamps           (void)
{
  if(prefs_g[0]("display_timestamps").defined()) {
    string foo = "display_timestamps";
    return parse_bool_field(foo);
  }
  return 1; // Default to true
}

int
prefs_get_default_config_width         (void)
{
  int width = 450;
  if(prefs_g[0]("default_config_width").defined()
     && prefs_g[0]("default_config_width").getLong()) {
    width = prefs_g[0]("default_config_width").getLong();
  }
  return width;
}


/* Returns 0 if groups_select_members is 0 or "false";
   1 otherwise */
int
prefs_get_groups_select_members         (void)
{
  if(prefs_g[0]("groups_select_members").defined()) {
    return parse_bool_field("groups_select_members");
  }
  return 1; // Default to true
}

void
apply_func_to_grp_members(GtkCTreeNode* grpNode, 
                          GtkCTree* processTree, 
                          bool (*func2) (const char*, const char*),
                          bool (*func3) (const char*, const char*, const char*))
{
  GtkCTreeNode* realNode;
  EntryData* ed;
  EntryDataAug* eda;
  GtkCTreeNode* grpMem;
  char* machName;
  char* status;
  ProcessData pd;

  for(grpMem = GTK_CTREE_ROW(grpNode)->children;
      grpMem != NULL;
      grpMem = GTK_CTREE_ROW(grpMem)->sibling) {
    eda = (EntryDataAug*) gtk_ctree_node_get_row_data(processTree, grpMem);
    if(eda == NULL) continue;
    realNode = eda->realNode;
    if(realNode == NULL) continue;  
    ed = (EntryData*) gtk_ctree_node_get_row_data(processTree, realNode);
    if(ed == NULL) continue;
    // Grab machine / daemon name
    gtk_ctree_get_node_info(processTree, GTK_CTREE_ROW(realNode)->parent, &machName,
                            NULL, NULL, NULL, NULL, NULL, NULL, NULL);
    // Apply function(s)
    if(func2 != NULL)
      func2(machName, ed->label);

    gtk_ctree_node_get_text(processTree, realNode, 1, &status);

    if(func3 != NULL)
      func3(machName, ed->label, status);

    if(ed->pw != NULL) {
      pd.machName = machName;
      pd.procName = ed->label;
      pd.status = status;
      processWidget_button_showandtell(ed->pw, &pd);
    }

  }
}

/* Strips the leading 'c_' and trailing '_<pid>' from a clientname */
string
strip_client_name(string name) {
  assert(name.size() > 2);
  if(name.substr(0, 2) == "c_")
    name.erase(0, 2); // c_
  return strip_pid(name);
}

/* Strips the trailing _<pid> from a machName or a label */
string
strip_pid(string str) {
  unsigned int lastUS = str.rfind("_");
  bool strip = true;
  for(unsigned int i = lastUS+1; i < str.size(); i++) {
    if(!isdigit(str[i])) {
      strip = false;
      break;
    }
  }
  if(strip)
    str.erase(lastUS); // PID
  return str;
}

/* Removes all whitespace characters */
string
strip_whitespace(string str) {
  string out;
  string::iterator sit;
  for(sit = str.begin(); sit != str.end(); sit++) {
    if(!isspace(*sit)) {
      out += *sit;
    }
  }
  return out;
}


string
get_prefs_file_with_default()
{
  string prefFile = "";
  if(prefsFilename_g.size() > 0) {
    prefFile = prefsFilename_g;
  } else {
    prefFile = getenv("HOME");
    prefFile += "/.claw.prefs";
  }
  return prefFile;
}

void
print_gdk_gc(GdkGC* gc)
{
  GdkGCValues vals;
  if(gc != NULL) {
    gdk_gc_get_values(gc, &vals);
    printf("    fg: %d/%d/%d\tbg: %d/%d/%d\ttile: %p\tstip: %p\tclip: %p\n", vals.foreground.red/256, vals.foreground.green/256, vals.foreground.blue/256, vals.background.red/256, vals.background.green/256, vals.background.blue/256, vals.tile, vals.stipple, vals.clip_mask);
  } else {
    printf("    NULL GC.\n");
  }
}

/* Print out a bunch of stuff on a GtkStyle, to help debug GtkEntry
 * background color issues. */
void
print_gtk_style(GtkStyle* style)
{
  //printf("GtkStyle: (engine = %p)\n", style->engine);
  printf(" N: %d, A: %d, P: %d, S: %d, I: %d\n", GTK_STATE_NORMAL, GTK_STATE_ACTIVE, GTK_STATE_PRELIGHT, GTK_STATE_SELECTED, GTK_STATE_INSENSITIVE);
  printf(" fg\tbg\tlight\tdark\tmid\ttext\tbase\tbgpixmap\n");
  for(int i = 0; i < 5; i++) {
    printf("%d:   %d/%d/%d\t", i, style->fg[i].red/256, style->fg[i].green/256, style->fg[i].blue/256);
    printf("%d/%d/%d\t", style->bg[i].red/256, style->bg[i].green/256, style->bg[i].blue/256);
    printf("%d/%d/%d\t", style->light[i].red/256, style->light[i].green/256, style->light[i].blue/256);
    printf("%d/%d/%d\t", style->dark[i].red/256, style->dark[i].green/256, style->dark[i].blue/256);
    printf("%d/%d/%d\t", style->mid[i].red/256, style->mid[i].green/256, style->mid[i].blue/256);
    printf("%d/%d/%d\t", style->text[i].red/256, style->text[i].green/256, style->text[i].blue/256);
    printf("%d/%d/%d\t", style->base[i].red/256, style->base[i].green/256, style->base[i].blue/256);
    printf("%p\n", style->bg_pixmap[i]);
  }
  printf("Graphics contexts:\n");
  for(int i = 0; i < 5; i++) {
    printf("Mode: %d\n", i);
    printf("  FG:\n");
    print_gdk_gc(style->fg_gc[i]);
    printf("  BG:\n");
    print_gdk_gc(style->bg_gc[i]);
    printf("  LIGHT:\n");
    print_gdk_gc(style->light_gc[i]);
    printf("  DARK:\n");
    print_gdk_gc(style->dark_gc[i]);
    printf("  MID:\n");
    print_gdk_gc(style->mid_gc[i]);
    printf("  TEXT:\n");
    print_gdk_gc(style->text_gc[i]);
    printf("  BASE:\n");
    print_gdk_gc(style->base_gc[i]);
  }
}

void gtk_widget_set_font (GtkWidget *widget, const char *font)
{
  PangoFontDescription *font_desc = pango_font_description_from_string(font);
  gtk_widget_modify_font(widget, font_desc);
  pango_font_description_free(font_desc);
}

/***************************************************************
 * Revision History:
 * $Log: support.c,v $
 * Revision 1.81  2007/05/30 19:10:31  brennan
 *  - Fixed GTK warnings on preference editing cancellation, due to
 *    miscasting of checkboxes.
 *
 *  - New preferene: Remember location and size of window
 *
 *  - Improved initial auto-sizing of status/chat buffer
 *
 *  - Increased gutter sizes for pane resizers
 *
 *  - Fixed crash when claw is closed via the window manager
 *
 *  - When initially laying out the window, we now attempt to ensure that
 *    the process window will have enough space, so it's not cut off.
 *
 *  - Stdin and filter entry histories are now remembered across
 *    view/close of a process and quit/start of claw.  Added arg to
 *    specify history filename (defaults to ~/.claw.histories) and prefs
 *    to specify how many history entries to save per process.
 *
 *  - The initial running/exited state of all processes is no longer
 *    printed when claw starts up / daemons initially connect.  Status
 *    changes are still printed.
 *
 * Revision 1.80  2007/04/18 17:13:28  brennan
 * Fixed occasional crash in claw.
 *
 * Revision 1.79  2007/02/23 13:52:05  brennan
 * Fixed segfault when loading invalid / nonexistent config file using --config.
 *
 * Revision 1.78  2007/02/15 18:07:07  brennan
 * Fixed a few memory leaks, and one rogue pointer bug.
 * Mapped keypad enter to regular enter in stdin and filter entries.
 * Added focus-follows-mouse option.
 *
 * Revision 1.77  2007/01/12 19:42:56  brennan
 *  Added context menu to processWidget's filter entry that allows the
 *  user to enable or diable the filter (in the same way as the checkbox
 *  works), as well as launch a dialog to set the desired context
 *  (e.g. lines before and after a matching line that should be printed
 *  as well).
 *
 *  Hacked around the double-click-required on the signal and regexp
 *  context menus by responding to button-press-event as well as
 *  activate.
 *
 * Revision 1.76  2006/12/20 19:07:19  brennan
 *   We now use checkboxes in createHashDialog (e.g. local preferences)
 *   for elements whose default value is a length-two vector of 0 and 1,
 *   but whose value in the "real" hash is a long.
 *
 *   Turned filtering off by default
 *
 *   Claw now parses the standard X --geometry argument to set the
 *   default size and position of the window.
 *
 *   Moved load/save/edit preferences to a new 'Preferences' menu, and
 *   added all checkbox preferences directly to the menu (they still
 *   also appear in the "edit all preferences" dialog)
 *
 *   Fixed bug in which timestamps appeared multiple times in continued
 *   (>80 char) lines.
 *
 *   Fixed shout/dshout sillyness.
 *
 *   Fixed sysv init script errors.
 *
 *   Added buffer clear/reset option to right-click menus.  Will not add
 *   a button for this.  It was already in the 'Monitoring' menu.
 *
 *   Fixed bug resulting in incorrectly populated right-click menu for a
 *   process viewed in a group when the process' name was a substring of
 *   the group's name.  How's that for obscure bugs? :-)
 *
 *   When stdout filtering is turned on or off (either through the prefs
 *   dialog, or the prefs checkbox menu), immediately toggle filtering on
 *   all active process widgets, rather than waiting until they're
 *   hidden, then viewed.
 *
 *   Fixed localizeSite.sh to point search results to local pages, not
 *   gs295.
 *
 *   Updated dshout/shout to eliminate the username field. (code cleanup)
 *
 *   User's own chat messages are now displayed in green; everything else
 *   is in black.
 *
 *   Widened default filter width; now controlled by SHRUNK_WIDTH
 *   #define in processWidget.c
 *
 *   Just a note: Ctrl+U in a GtkEntry (e.g. stdin or filter) will clear
 *   all text in the entry.
 *
 *   The stdin entry / filter now remain visible when a process is dead,
 *   although stdin is disabled.  This allows the user to change the
 *   filtering and examine filtered output after a process has crashed.
 *   In addition, when a process is not running, clicks on the process
 *   widget focus the filter input.
 *
 *   The filter entry now retains a history, just like the stdin entry,
 *   that can be accessed via the up/down arrow keys.
 *
 *   Added taskbar icons for all dialogs.  For the moment, they're the
 *   same claw image as the main window; we may want to specialize them
 *   later.
 *
 *   Added a checkbox to the right of the filter that allows the user to
 *   enable or disable filtering without changing the filter text.  The
 *   [enter] approach is still supported (and checks the box when
 *   appropriate), and the checkbox is disabled when there is no text in
 *   the entry.
 *
 *   Filter now only goes red only if actual editing has occurred (not
 *   just a keypress).
 *
 *   The stdin entry line for a process widget is now greyed out when
 *   the process is dead.
 *
 *   Added footer pointing to www.microraptor.org to localized site.
 *
 *   Added release version stamp to the title png of the help page (pass
 *   version number as first argument to localizeSite.sh)
 *
 *   Added Help menu, and entry that launches a user-specified browser
 *   pointing at the RPM/APT-installed help pages.  The new preference is
 *   'help_browser'.
 *
 *   The background color of the filter entry now changes based on the
 *   active or editing state.  For reference, one must create a new
 *   GtkStyle and set it in order to override a theme engine set by the
 *   user.  GtkRcStyles do *not* do the trick.
 *
 *   We now set the background color of the 'Chat' tab if a new chat
 *   message comes in while the 'Status' tab is in the foreground.  To
 *   accomplish this, I had to disable user-theming of those two notebook
 *   tabs.
 *
 *   The 'Help' menu is now right-justified
 *
 *   Added an 'About' menu option under 'Help'.  We'll need to update the
 *   image with every release.  It's dismissed via a left-click, [enter],
 *   or [esc].
 *
 *   Fixed focus setup for filter/stdin.  When focus enters the filter or
 *   the stdin, it expands.  Much simpler, and does what we want.
 *
 *   Removed "get status", as it's no longer needed.  Left "Get status
 *   all" as "Refresh all processes' status" in the Monitoring menu,
 *   since there's an offchance you'll want to do that right at the
 *   beginning.
 *
 * Revision 1.75  2006/11/16 22:50:31  brennan
 * Made config window default wider (800 pixels).
 *
 * Fixed one echo of client shout per daemon bug.
 *
 * Make filter entry widget expand when it has focus, and vice-versa
 *
 * Claw preferences are auto-saved on exit to the last loaded file, or
 * the default (~/.claw.prefs) otherwise.
 *
 * Preferences load/save dialog is filled with .claw.prefs if no
 * existing prefs file is loaded.
 *
 * Revision 1.74  2006/11/16 18:55:04  brennan
 * Fixed bug where RCL syntax errors in set process config dialogs nuked
 * the contents of the field; the original data is now used and an error
 * message is printed to the common buffer.
 *
 * Added backup kill cmd and kill timeout to process configs.
 *
 * Made process config multiline text boxes expand with the window
 *
 * Added 'stdin_commands' to process configs.  This is a vector, but uses
 * a multiline entry in the config editing dialog.
 *
 * Added dialog during connection to central that allows graphical
 * cancellation in the event of incorrect centralhost designation.
 * Responsiveness is poor, but there's no way around that without hacking
 * IPC directly.
 *
 * Added debugger support to process configs.  Set 'debugger' to 'gdb' to
 * run the process under GDB.  This does not make use of any PATH
 * environment variable: the command must either be absolute, or relative
 * to the working_dir setting for the process.  When the process starts,
 * it will load the arguments, and stop at a gdb prompt to allow the user
 * to set breakpoints, etc.  Just type 'run' to run the process with all
 * of its arguments.  This makes use of Trey's debugger support in the daemon.
 *
 * Added icon for use in the taskbar (16x16; client/imageHeaders/miniClawImage.h)
 *
 * Added 'send signal to process' capability, using new 'signal <sig>
 * <process>' message type.  This is included everywhere run and kill
 * commands are.  Note: the popup menu that comes up when clicking the
 * signal button when viewing a process requires two clicks to select an
 * item.  This is a bug, but I haven't figured it out yet.
 *
 * New mraptord status messages supplant the claw-generated process
 * status messages, and are formatted to display which user issued run,
 * kill, and signal commands.
 *
 * Added client-side regexp filtering of process output.  This is a small
 * 'Filter' entry box in the lower-right of the process window.  Enter a
 * POSIX (e.g. grep -E)-style regexp and press [enter] to filter the
 * stdout.  Clear the entry box and press [enter] to deactivate
 * filtering.  The regexp will be displayed in green when active and
 * black when inactive.  Red denotes a regexp that is being edited while
 * the previous regexp is active.  A tooltip appears explaining this if
 * you hover over the entery box.  The regexp interface can be hidden by
 * setting the client-side preference "stdout_filtering" to 0 or false.
 *
 * Added limited chat support, via a dialog tabbed with the
 * minibuffer/error output.  This uses the new
 * shout/dshout messages.
 * Added graceful support for central crashes: a dialog is displayed to
 * inform the user of the crash, then claw exits.
 *
 * Fixed bug in which hiding, then re-viewing a process didn't fill the
 * buffer with recent output.
 *
 * Fixed newline bug in ClawText that resulted in there always being a
 * blank line at the bottom.
 *
 * Added (optional) timestamping to client output.  This is controlled
 * via the client preferences dialog.
 *
 * Added commandline and preferences option to specify the default width
 * of the configuration dialogs in claw. (--config-width /
 * default_config_width)
 *
 * Revision 1.73  2005/06/14 15:58:04  brennan
 * Patched a memory leak in print_to_processes
 *
 * Revision 1.72  2005/05/18 01:05:13  trey
 * added terminal buffering
 *
 * Revision 1.71  2004/11/25 05:20:48  brennan
 * Fixed run-all bug (using a GList* instead of its data)
 *
 * Patched a bunch of memory leaks, and all the nasty ones.  There are four
 * known remaining leaks, all dealing with the widget used to view the output
 * of a process, with a sum total of ~90 bytes leaked per process viewed.
 * Not worth my time at the moment. :-)
 *
 * Revision 1.70  2004/11/23 07:01:54  brennan
 * A number of memory leaks and free/delete mismatches repaired.
 * Some errors detected by valgrind remain, and will be fixed soon.
 *
 * Revision 1.69  2004/11/17 22:30:22  trey
 * removed sending a code at the end of a line in the terminal; this is redundant if there is a fully specified code at the beginning of the next line
 *
 * Revision 1.68  2004/05/27 13:26:59  trey
 * fixed problem with lineType 'r'
 *
 * Revision 1.67  2004/04/28 18:58:50  dom
 * Appended log directive
 * 
 ***************************************************************/
