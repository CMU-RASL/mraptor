/***** tell emacs we use -*- c++ -*- style comments *****
 * $Revision: 1.50 $ $Author: brennan $ $Date: 2007/05/30 19:10:31 $
 *
 * COPYRIGHT 2004, Carnegie Mellon University 
 *
 * PROJECT: Exploration Robotics (Life in the Atacama)
 *
 * MODULE:
 *
 * FILE: microraptor/client/claw.c
 *
 * DESCRIPTION:
 *
 ********************************************************/
/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <iomanip>
#include <limits>
#include <map>

// For stat()
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#include <X11/Xlib.h>
#include <X11/X.h>
#include <X11/Xmu/WinUtil.h>
#include <gtk/gtk.h>
#include <gdk/gdkx.h>
#include <gdk/gdktypes.h>
#include <sys/time.h>
#include <time.h>

#include "ipc.h"
#include "interface.h"
#include "support.h"
#include "processWidget.h"
#include "callbacks.h"
#include "clientIO.h"
#include "clientComm.h"
#include "RCL.h"
#include "imageHeaders.h"
#include "mrCommonTime.h"

// avoid including tca.h from IPC
// Copied from mraptordInternal.h
extern "C" {
  extern void x_ipcRegisterExitProc(void (*)(void));
}

using namespace std;
using namespace microraptor;

/* List of MR_Comm's; data points to a MR_Comm */
MR_Comm* daemon_comm_g = NULL;
/* Main window, so we can get at it from various IPC handlers */
GtkWidget *HeadDino_g = NULL;
/* Most recent local config file we loaded; kept in sync with current
   system config. */
rcl::exp local_config_g = rcl::map();
/* Where the config file came from */
string local_config_name_g;
/* A map of daemon names to clock skews */
hash_map<string, timeval> clockSkew_g;
/* A map of process data to subscription status */
hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>* subscriptions_g;
/* A map of process data to overwrite status (this is effectively a one-line buffer) */
hash_map<ProcessData, bool, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>* overwrite_g;
/* A static popup menu; we hide and show items to make it context-sensitive 
   Keeping it prebuilt is /much/ faster.
 */
GtkMenu* popup_menu_g = NULL;
/* The data associated with the current popup; popups are effectively modal, 
   so there isn't an overwriting issue. */
pair<ProcessWidget*, ProcessData*> popup_menu_info_g(NULL, NULL);
/* A list of pending things to pop set dialogs for when we receive an appropriate
   config response */
list<string> pending_sets_g;
/* The default set of fields for a process configuration */
rcl::exp procConfigDefault_g;
/* Our window name.  Needed to avoid swallowing self */
string topWindowName_g = "Claw: the Microraptor GUI";

/* Our user preferences */
rcl::exp prefs_g;
rcl::exp prefsDefault_g;
// After incorporating all prefs files; used to check for changes on exit
rcl::exp prefsInitial_g; 
// Location of last-loaded preferences file
string prefsFilename_g = ""; 

// Location of persistent history files
string historyFilename_g = "";
// Cached stdin commands, loaded from file.  Used to populate the
// history of a processWidget when it's created.  A map from process
// name to a vector of commands.
map<string, vector<string> > persistentStdinCommandHistory_g;
// Ditto, for filters
map<string, vector<string> > persistentRegexpHistory_g;

Display *root_display_g;
// The ID of the IPC timeout handler; used to remove it when central goes away
unsigned int ipcTimeoutID = 0;

static gint ipc_timeout_handler(gpointer data) {
  IPC_listenClear(5); // timeout of 5 milliseconds
  return TRUE; // If this is FALSE, the handler is removed.
}

static gint status_update_handler(gpointer data) {
  get_status_process(NULL, "-a");
  return TRUE;
}

void
x_root_fd_callback(int fd, void *clientData)
{
  //cerr << "Entering FD handler" << endl;
  // FIXME: We really should use a nonmodifying ("peek") call,
  //        but I can't find one that's nonblocking.  What we have
  //        is fine if the events we're seeing are a private stream;
  //        I'm not sure if they are or not.
  // FIXME: Make this more efficient.
  // FIXME: This more or less works.  However, there are three possible
  //        results, which seem equally probable:
  //         (1) It works perfectly
  //         (2) The window gets swallowed, but an empty frame is left behind
  //         (3) The window just gets resized to the size it would be were it
  //             to be successfully swallowed.
  //        This seems to point to a timing issue in the arrival of CreateNotify
  //         messages.  Is there a message that gets fired off when a client 
  //         finishes building itself?  Some sort of realization message?
  // We don't want to allocate these every time
  static XEvent report;
  static XCreateWindowEvent* cwe;
  static char* name;
#if 0
  static Window window;
  static Window root;
  static unsigned int dummy;
  static int dummyi;
#endif
  // XPeekEvent blocks:
  //XPeekEvent(root_display_g, &report);


  // Clear the queue, making sure createNotify's don't have matching destroyNotify's
  // TODO: DO THIS!
  if(XCheckWindowEvent(root_display_g, 
                       GDK_ROOT_WINDOW(), 
                       SubstructureNotifyMask, 
                       &report)) {
    
    if(report.type == CreateNotify) {
      cwe = (XCreateWindowEvent*) &report;

      if(XFetchName(root_display_g, cwe->window, &name)) {
        cerr << "Winname: \"" << name << "\"" << endl;
// Test code
#if 0
        if(strcmp(name, "Calculator") == 0) {
          
          cerr << "\tAttempting to swallow it..." << endl;
          window = cwe->window;
          Window parent;
          Window* children;
          Window target = window;
          Atom WM_STATE;
          Atom type;
          int format;
          unsigned long nitems, after;
          unsigned char *data;
          unsigned int nchildren;
          int foundState = 0;
          
          WM_STATE = XInternAtom(root_display_g, "WM_STATE", True);
          if (!WM_STATE) {
            do {
              type = None;
              
              XGetWindowProperty(root_display_g, window, WM_STATE, 0, 0, False, AnyPropertyType,
                                 &type, &format, &nitems, &after, &data);
              if(window != root && type) {
                foundState = 1;
                target = window;
                break;
              }
              
              if(!XQueryTree(root_display_g, window, &root, &parent, &children, &nchildren)) {
                cerr << "Gah! XQueryTree failed!" << endl;              
                break;
              } 
              window = parent;
            } while(window != root);
            if(!foundState)
              target = XmuClientWindow (root_display_g, cwe->window);
          } else {
              target = XmuClientWindow (root_display_g, cwe->window);
          }
          swallow_window(name, target);
        } // end if(strcmp, name, "Calculator")
#endif
      } // end if(XFetchName())
      
    } // end if(type == CreateNotify)
  } // end if(XCheckWindowEvent)
  //cerr << "Leaving FD handler" << endl;
  return;
}

void
usage() {
  cerr << "usage: claw OPTIONS" << endl
       << "   -h or --help  prints this message" << endl
       << "   -p <filename> or --preferences <filename> to load an RCL Claw preferences file" << endl
       << "          Note that the contents of this will override any equivalent " << endl
       << "          entries in ~/.claw.prefs." << endl
       << "  --history <filename>  Use <filename> instead of ~/.claw.history to store" << endl
       << "          stdin and filter histories."
       << "   (-c or --config or -lc or --localconfig) <local_config_file>: load process" << endl
       << "          configuration from local file." << endl
       << "   --ssh-display <short daemon name> <display string> (may occur multiple times)" << endl
       << "          Set display string to be used for '%c' occurences in process configs" << endl
       << "          for the given daemon." << endl
       << "   -s <method> or --sort <method> where <method> is \"groups\" or" << endl
       << "          \"daemons\" (no quotes)" << endl
       << "   -d or --debug enables debugging output" << endl
       << "          (prints all data going through the comm layer to terminal)" << endl
       << "   --no-cool-graphics turns off the nifty microraptor / error graphics" << endl
       << "           to save screen real estate." << endl
       << "   --centralhost <host> or --centralhost <host>:<port>" << endl
       << "           connect to the IPC central server on the specified host/port." << endl
       << "   --config-width <int>" << endl
       << "           Process config dialogs will be <int> pixels wide by default." << endl
       << "   --geometry [<width>{xX}<height>][{+-}<xoffset>{+-}<yoffset>]" << endl
       << "           Set the default window size and/or position, using a standard" << endl
       << "           X geometry string." << endl
       << endl;
  exit(1);
}

// Clears the GTK event queue, but takes no more than maxDelay seconds
// and at least minDelay seconds doing so.  Will leave pending events
// if maxDelay is exceeded.  Returns true if there are still events
// pending, false otherwise.
bool clearEventsTimeout(double maxDelay, double minDelay = 0.0)
{
  timeval startTime, iterTime;
  startTime = getTime();
  iterTime = getTime();
  while(timeDiff(iterTime, startTime) <= minDelay
        || (gtk_events_pending()
            && timeDiff(iterTime, startTime) <= maxDelay) ) {
    gtk_main_iteration_do(FALSE);
    iterTime = getTime();
  }
  return gtk_events_pending();
}

// Called after every IPC_Connect attempt (that is, every 5 seconds).
// If the first connection attempt fails, pop up a cancellation
// callback.  Response time will be slow, since we're not
// multithreaded, but it's better than not explaining the delay / hang
// at all (some users don't launch Claw from a terminal, where IPC
// connect foo is printed out).
void allowConnectCancelCallback(string centralhost, bool success)
{
  static GtkWidget* dialog = NULL;
  static double maxDelay = 1.5; // Don't process events for more than 1.5 seconds.

  // Tear down the existing dialog, if any
  if(success) {
    if(dialog != NULL) {
      gtk_widget_destroy(dialog);
      dialog = NULL;
    }
    return;
  }
  // Pop up the dialog
  else if(dialog == NULL) {
    dialog = create_cancelLaunchDialog(centralhost.c_str());
    gtk_widget_show(dialog);
    add_taskbar_icon (dialog, miniClawImage_xpm);
  }
  clearEventsTimeout(maxDelay, 0.1);
}

// The next two functions are called when IPC disconnects.  Remove our
// IPC timeout handlers, display an informative window, then exit when
// the user clicks "ok".
void on_user_acked_shutdown(GtkButton *button, gpointer user_data) {
  cerr << "User has acknowledged the utter cruelty of the world, and central in particular." << endl
       << "Until next time!" << endl;
  // Destroy the dialog
  gtk_widget_destroy (gtk_widget_get_toplevel (GTK_WIDGET (button)));
  // Shut down claw
  claw_quit();
}

void shutdownOnIpcDeath(void) {
  // This can be called more than once by IPC.  Guard against it.
  static bool shuttingDown = false;
  if(shuttingDown) return;
  shuttingDown = true;

  gtk_timeout_remove(ipcTimeoutID);
  cerr << "ERROR: The IPC central process has gone down or disconnected us.  Bailing." << endl;
  GtkWidget *dialog, *label, *okay_button;

  const char *centralHost = getenv("CENTRALHOST");
  if (!centralHost) centralHost = "local host";

  string msg = "IPC Central at ";
  msg += centralHost;
  msg += " has gone down or disconnected us.\n";
  msg += "Check your network connection and/or your\n";
  msg += "primary mraptord machine.  Claw will now exit.";

  dialog = gtk_dialog_new();
  gtk_window_set_title (GTK_WINDOW (dialog), _("Central has crashed"));
  
  label = gtk_label_new (msg.c_str());
  gtk_misc_set_padding (GTK_MISC (label), 20, 20);
  
  okay_button = gtk_button_new_with_label("Sigh.  Goodbye.");
   
  /* Ensure that the dialog box is destroyed when the user clicks ok. */
  gtk_signal_connect (GTK_OBJECT (okay_button), "clicked",
                      GTK_SIGNAL_FUNC (on_user_acked_shutdown),
                      NULL);
  gtk_container_add (GTK_CONTAINER (GTK_DIALOG(dialog)->action_area),
                     okay_button);

  /* Add the label, make the dialog modal, and show everything we've
   * added to the dialog. */
  gtk_container_add (GTK_CONTAINER (GTK_DIALOG(dialog)->vbox),
                     label);
  gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);
  gtk_widget_show_all (dialog);
}

int
main (int argc, char *argv[])
{
  timeval   curtime;
  rcl::exp tmpExp;
  bool loadedLocalConfig = false;
  bool debugCommOutput = false;
  string centralhost = "";
  int winX, winY;
  unsigned int winW, winH;
  int parsedGeomMask = 0;

#ifdef ENABLE_NLS
  bindtextdomain (PACKAGE, PACKAGE_LOCALE_DIR);
  textdomain (PACKAGE);
#endif

  gtk_set_locale ();
  gtk_init (&argc, &argv);

  /* Read GTK resources file */
  // For now, setting the ones we care about by hand (see processWidget.c)
  //gtk_rc_parse("~/.clawrc");

  gettimeofday(&curtime, NULL);
  srand(curtime.tv_sec);

  /* Default preferences structure */
  /* SUPPORTED:
       view_mode: [ groups daemons ] should groups or daemons be sorted first, and which should be
                  expanded on start.
       tie_selection_to_tab: [ 0 1 ] if true, reselect the contents of each tab
                                     when the current tab is changed
       focus_follows_mouse: [ 0 1 ] if true, focus follows the mouse between process widgets and the
                                    process tree.  This isn't per-widget focus-follow, just per-process
                                    (e.g. it doesn't do focus-follows-mouse between the stdin and filter
                                    entries)
       display_skew: [ 0 1 ] display per-daemon time skew values in process tree
       back_history_length: in number of lines, how much history we
                            want to retreive on a subscribe
       stdin_history_length: in number of lines, how many stdin
                             commands do we want to remember across claw restarts?
       filter_history_length: in number of lines, how many filter
                             commands do we want to remember across claw restarts?
       cool_graphics: [ 0 1 ] display nifty graphics in GUI (turn off to save space)
       help_browser: [string] what browser to use to view the help files.  %s resolves to target webpage.
       clear_on_run: [ 0 1 ] clear the process buffer on a run command (if it's visible)
       ssh_displays: hash of undecorated daemon name to display string of our ssh
                     tunnel to it
       remember_window: [ 0 1 ] if true, remember the window's
                    position and size for the next time we start.
       initial_window_geometry: <geometry string> Window geometry to
                    use on startup.
     UNSUPPORTED / MAY BE ADDED AT SOME POINT:
       compact_daemon_display: [ 0 1 ] compact daemon name display
       auto_swallow: vector of quoted window names
       verbosity: int in the range [1 5]
       client_side_logging: [0 1] log stuff clientside
       status_update_frequency: in milliseconds, how often to update all processes' status
       initially_view: vector of process names we want to view as soon as we find out about them
   */
  string defPrefStr = "{ view_mode => \"daemons\", ";
  defPrefStr += "back_history_length => 100, ";
  defPrefStr += "stdin_history_length => 10, ";
  defPrefStr += "filter_history_length => 10, ";
  defPrefStr += "default_config_width => 800, ";
  defPrefStr += "help_browser => \"firefox %s\", ";
  defPrefStr += "ssh_displays => { foo => \":0.0\" }, ";
  defPrefStr += "tie_selection_to_tab => [1, 0], ";
  defPrefStr += "focus_follows_mouse => [0, 1], ";
  defPrefStr += "groups_select_members => [0, 1], ";
  defPrefStr += "display_skew => [0, 1], ";
  //defPrefStr += "compact_daemon_display => 0, \n";
  //defPrefStr += "auto_swallow => [\"Calculator\", \"gaim\"], \n";
  //defPrefStr += "status_update_frequency => 30000, \n";
  //defPrefStr += "initially_view => [\"a\", \"b\", \"d\"], \n"; 
  defPrefStr += "cool_graphics => [1, 0], ";
  defPrefStr += "clear_on_run => [1, 0], ";
  defPrefStr += "stdout_filtering => [0, 1], ";
  defPrefStr += "display_timestamps => [0, 1], ";
  defPrefStr += "remember_window => [1, 0], ";
  defPrefStr += "initial_window_geometry => \"\" ";
  //defPrefStr += "verbosity => 2 ";  
  defPrefStr += "}";

  // Load hard-coded defaults
  try {
    prefsDefault_g = rcl::readFromString(defPrefStr);
    prefs_g = rcl::readFromString(defPrefStr);
    // We only wanted the example ssh_displays for prefsDefault_g
    prefs_g[0]("ssh_displays") = rcl::map();
    // Reset checkboxes to their default values
    rcl::exp checkDefault;
    FOR_EACH(pr, prefs_g[0].getMap()) {
      if(is_checkbox_pref((*pr).second)) {
        checkDefault = (*pr).second.getVector()[0];
        (*pr).second = checkDefault;
      }
    }
  } catch(rcl::exception e) {
    string errStr = "ERROR: ";
    errStr += e.text;
    cerr << errStr;
  }

  // Overlay default config file, if it exists
  // Make sure the file exists
  string defPrefFile = getenv("HOME");
  defPrefFile += "/.claw.prefs";
  FILE* dummyfile = fopen(defPrefFile.c_str(), "r");
  if(dummyfile != NULL) {
    fclose(dummyfile);
    try {
      rcl::exp defFilePrefs = rcl::readFromFile(defPrefFile);
      cout << "Incorporating " << defPrefFile << " into preferences." << endl;
      if(defFilePrefs[0].defined() && defFilePrefs[0][0].defined())
        prefs_g[0].addFrom(defFilePrefs[0][0]);      
      prefsFilename_g = defPrefFile;
    } catch(rcl::exception e) {
      // FIXME: Pop up a dialog?
      cerr << "*************************************************" << endl
           << "ERROR: Unable to parse default preferences file " << defPrefFile << endl
           << "       " << e.text << endl
           << "       Soldiering on with hardcoded defaults." << endl
           << "*************************************************" << endl;
    }
  } else {
    cerr << "No default preferences file (" << defPrefFile << ") found." << endl;
  }

  // Set default history file
  historyFilename_g = getenv("HOME");
  historyFilename_g += "/.claw.history";
 
  string arg;
  char* endPtr; // For strtod error checking
  for (int argi=1; argi < argc; argi++) {
    arg = argv[argi];
    if (arg == "-h" || arg == "--help") {
      usage();
    } else if (arg == "-c" || arg == "--config"
               || arg == "-lc" || arg == "--localconfig") {
      if (++argi >= argc) {
	cerr << "You fed me a config flag without an argument!  Yuck!" << endl << endl;
	usage();
      }
      local_config_g = load_local_config(argv[argi]);
      local_config_name_g = argv[argi];
      loadedLocalConfig = true;
    } else if (arg == "-p" || arg == "--preferences") {
      if (++argi >= argc) {
        cerr << "You gave me a preferences flag without an argument!  Geez, you're too polite!" << endl << endl;
        usage();
      }
      try {
        rcl::exp filePrefs = rcl::readFromFile(argv[argi]);
        // BUGCHECK: Can this add fields that we don't have in prefs_g?
        if(filePrefs[0].defined() && filePrefs[0][0].defined())
          prefs_g[0].addFrom(filePrefs[0][0]);
        cout << "Incorporating " << argv[argi] << " into preferences." << endl;
        prefsFilename_g = argv[argi];
      } catch(rcl::exception e) {
        cerr << "*************************************************" << endl
             << "Parsing of preferences file \"" << argv[argi] << "\" failed:" << endl
             << "  " << e.text << endl
             << "  Soldiering on, with default prefs." << endl
             << "*************************************************" << endl;
      }
    } else if (arg == "--history") {
      if(++argi >= argc) {
        cerr << "Sorry, but --history requires a filename argument.  Try again!" << endl << endl;
        usage();
      }
      historyFilename_g = argv[argi];
    } else if (arg == "--ssh-display") {
      if(argi+2 >= argc) {
        cerr << "Hmm, I spy an --ssh-display without enough arguments.  Can you find them?" << endl << endl;
        usage();
      }
      cout << "Using remote display " << argv[argi+2] << " for host " << argv[argi+1] << endl;
      prefs_g[0]("ssh_displays")(string(argv[argi+1])) = string(argv[argi+2]);
        //rcl::readFromString(string(argv[++argi]));
      argi += 2;
    } else if(arg == "-s" || arg == "--sort") {
      if(++argi >= argc) {
        cerr << "Got sort option without argument!" << endl << endl;
        usage();
      }
      prefs_g[0]("view_mode") = string(argv[argi]);
    } else if(arg == "-d" || arg == "--debug") {
      cout << "Debugging output enabled." << endl;
      debugCommOutput = true;
    } else if(arg == "--no-cool-graphics") {
      prefs_g[0]("cool_graphics").setValue((long) 0);
    } else if(arg == "--centralhost") {
      if (++argi >= argc) {
        cerr << "Geez, if you're going to change my centralhost, you need to say what it is!" << endl << endl;
        usage();
      }
      setenv("CENTRALHOST", argv[argi], 1);
    } else if(arg == "--config-width") {
      if (++argi >= argc) {
        cerr << "You must specify a width to go along with --config-width!" << endl;
        usage();
      }
      long int width = strtol(argv[argi], &endPtr, 10);
      if(width == 0 && endPtr == argv[argi]) {
        cerr << "ERROR: You must specify an integer argument for --config-width." << endl;
        usage();
      }
      prefs_g[0]("default_config_width") = width;
      cout << "Config windows will default to " << prefs_g[0]("default_config_width") << " pixels wide." << endl;
    } else if(arg == "--geometry") {
      if (++argi >= argc) {
        cerr << "You must specify a geometry string with --geometry." << endl;
        usage();
      }
      parsedGeomMask = XParseGeometry(argv[argi], &winX, &winY, &winW, &winH);
      if(prefs_get_remember_window()) {
        prefs_g[0]("initial_window_geometry") = string(argv[argi]);
      }
    } else {
      cerr << "ERROR: unknown argument (information overload! :)" << endl << endl;
      usage();
    }
  }

  cout << "Initial prefs: " << endl;
  prefs_g.writeConfig(cout, 1);
  cout << endl;
  // BUGCHECK: this is a value copy, right?
  prefsInitial_g = prefs_g;

  struct stat junk;
  if(!stat(historyFilename_g.c_str(), &junk)) {
    ifstream libraryFile;
    libraryFile.open(historyFilename_g.c_str());

    if(libraryFile.is_open()) {
      cout << "Loading stdin and filter histories from " << historyFilename_g << "...";
      string entryType, procName, line;
      map<string, vector<string> >::iterator libraryIt;
      while(libraryFile.good()) {
        libraryFile >> entryType;

        if(!libraryFile.good())
          break;
        
        // Ignore comments
        if(entryType[0] == '#') {
          libraryFile.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
          continue;
        }

        // Sanity check
        if(entryType != "stdin" && entryType != "filter") {
          cerr << "WARNING: Malformed history library line.  Entry type is '"
               << entryType << "'; should be 'entry' or 'filter'." << endl
               << "         Ignoring." << endl;
          continue;
        }

        libraryFile >> procName;
        getline(libraryFile, line);
        // Pop the space after procName off of line
        line.erase(line.begin());

        // Not quite enough code to worry about the duplication
        if(entryType == "stdin") {
          libraryIt = persistentStdinCommandHistory_g.find(procName);
          if(libraryIt != persistentStdinCommandHistory_g.end()) {
            libraryIt->second.push_back(line);
          }
          else {
            vector<string> newVec;  newVec.clear();
            newVec.push_back(line);
            persistentStdinCommandHistory_g.insert(pair<string, vector<string> >(procName, newVec));
          }
        }
        else if(entryType == "filter") {
          libraryIt = persistentRegexpHistory_g.find(procName);
          if(libraryIt != persistentRegexpHistory_g.end()) {
            libraryIt->second.push_back(line);
          }
          else {
            vector<string> newVec;  newVec.clear();
            newVec.push_back(line);
            persistentRegexpHistory_g.insert(pair<string, vector<string> >(procName, newVec));
          }
        }
        else assert(0);
        
      } // End loop through library file
      libraryFile.close();
      cout << "done." << endl;
    }
    else {
      cout << "WARNING: Unable to open history library from '" << historyFilename_g << "'." << endl
           << "         Your histories won't be populated.  C'est la vie." << endl;
    }
  }

  /* Establish default configurations so editHashDialog always has enough fields
     NOTE: the values here are only used to provide example values; they are not
       filled into the dialog.
  */
  string defProcStr = "{ cmd => \"joyride -r -p\", ";
  defProcStr += "working_dir => \"/tmp/foo\", ";
  defProcStr += "log_file => \"/tmp/%n_%u.log\", ";
  defProcStr += "ready => \"> \", ";
  defProcStr += "depends => [a, b], ";
  defProcStr += "debugger => \"gdb\", ";
  defProcStr += "stdin_commands => [\"set user foo\", \"do magic\"], ";
  defProcStr += "env => { DISPLAY => \":0\" }, ";
  defProcStr += "kill_cmd => \"kill -INT %p\", ";
  defProcStr += "backup_kill_delay => 5.0, ";
  defProcStr += "backup_kill_cmd => \"kill -TERM %p\" }";
  try {
    tmpExp = rcl::readFromString(defProcStr);
  } catch(MRException e) {
    string errStr = "ERROR: ";
    errStr += e.text;
    cerr << errStr;
  }

  /* readFromString always returns a vector; pull out the hash */
  procConfigDefault_g = tmpExp[0];

  /* The main window */
  HeadDino_g = create_HeadDino ();  

  /* If geometry wasn't specified on the commandline, parse from the
   * preferences, if we want to remember the window size. */
  if(prefs_get_remember_window() 
     && !parsedGeomMask
     && prefs_initial_window_geometry().size() > 0) {
    parsedGeomMask = XParseGeometry(prefs_initial_window_geometry().c_str(), &winX, &winY, &winW, &winH);
  }

  if((parsedGeomMask & XValue) && (parsedGeomMask & YValue)) {
    gtk_widget_set_uposition (HeadDino_g, winX, winY);
  }
  if((parsedGeomMask & WidthValue) && (parsedGeomMask & HeightValue)) {
    gtk_window_set_default_size (GTK_WINDOW (HeadDino_g), winW, winH);
  }

  /* Create popup menu for right-clicking; we show/hide the various elements at
     popup time instead of dynamically creating it.  This makes popups much faster.
  */
  popup_menu_g = pw_popup_menu();

  /* Make notebook scrollable if necessary */
  gtk_notebook_set_scrollable(GTK_NOTEBOOK(lookup_widget(HeadDino_g, "notebook1")), TRUE);

  gtk_widget_show (HeadDino_g);

  mod_HeadDino_postShow();

  add_taskbar_icon (HeadDino_g, miniClawImage_xpm);

  /* Throw the pixmap in the right place */
  set_gratuitous_image(false);

  /* Display everything, before we wait on connecting to central, but don't wait too long. */
  clearEventsTimeout(2.0);

  // Set up the comm
  IPCHelper::setVerbose(false);
  daemon_comm_g = new MR_Comm("c"); // connect as client
  if(debugCommOutput)
  {
    daemon_comm_g->set_verbose_mode(true);
  }
  daemon_comm_g->handle_config_sync(fslot(&get_config), loadedLocalConfig);
  daemon_comm_g->subscribe_messages(response_handler, NULL);
  daemon_comm_g->subscribe_connect(connect_handler, NULL);
  daemon_comm_g->subscribe_disconnect(disconnect_handler, NULL);

  cout << "Trying to connect to IPC central..." << flush;
  daemon_comm_g->connect_to_central(allowConnectCancelCallback);
  cout << "connected." << endl;

  // Initialize the subscription list
  subscriptions_g = new hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>(4, &ProcessDataHash, &ProcessDataEqual);

  // Initialize the overwrite list
  overwrite_g = new hash_map<ProcessData, bool, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>(4, &ProcessDataHash, &ProcessDataEqual);

  // Use g_timeout_add to add a timer function to periodically handle
  //  IPC events.  See below link for data:
  //   http://developer.gnome.org/doc/API/glib/glib-the-main-event-loop.html
  // This eliminates our refresh problems; we need to load it up and make sure
  //  it won't cause problems with heavy IPC loads.
  ipcTimeoutID = gtk_timeout_add(20, ipc_timeout_handler, NULL);

  // Update our status every 30 seconds
  gtk_timeout_add(30000, status_update_handler, NULL);

  // Support graceful handling of central shutdown / disconnection.
  x_ipcRegisterExitProc(shutdownOnIpcDeath);

  // Closed in claw_quit()
  //root_display_g = XOpenDisplay( NULL );
  /*
  root_display_g = XOpenDisplay( gdk_get_display() );
  if(root_display_g == NULL) {
    fprintf(stderr, "Can't open root display!  Blast!\n");
  } else {
    XSelectInput(root_display_g, 
                 DefaultRootWindow(root_display_g), 
                 SubstructureNotifyMask);
    XEvent report;
    // Need this to bootstrap the FD somehow.  Very weird.
    // Unfortunately, there don't appear to be any "Peek" functions that
    //  are nonblocking.  Thus, we lose one event.  This can't be anything
    //  from one of our child windows, since we haven't started processing
    //  IPC messages yet.
    XCheckWindowEvent(root_display_g, 
                      GDK_ROOT_WINDOW(), 
                      SubstructureNotifyMask, 
                      &report);
    IPC_subscribeFD(XConnectionNumber(root_display_g), x_root_fd_callback, NULL);
  }
  */

  //CONVERSION
  //GTK MAIN causes event crashes
  gtk_main ();

  // Note: I think there's a memory leak wrt colData
  return 0;
}




/***************************************************************
 * Revision History:
 * $Log: claw.c,v $
 * Revision 1.50  2007/05/30 19:10:31  brennan
 *  - Fixed GTK warnings on preference editing cancellation, due to
 *    miscasting of checkboxes.
 *
 *  - New preferene: Remember location and size of window
 *
 *  - Improved initial auto-sizing of status/chat buffer
 *
 *  - Increased gutter sizes for pane resizers
 *
 *  - Fixed crash when claw is closed via the window manager
 *
 *  - When initially laying out the window, we now attempt to ensure that
 *    the process window will have enough space, so it's not cut off.
 *
 *  - Stdin and filter entry histories are now remembered across
 *    view/close of a process and quit/start of claw.  Added arg to
 *    specify history filename (defaults to ~/.claw.histories) and prefs
 *    to specify how many history entries to save per process.
 *
 *  - The initial running/exited state of all processes is no longer
 *    printed when claw starts up / daemons initially connect.  Status
 *    changes are still printed.
 *
 * Revision 1.49  2007/02/15 18:07:06  brennan
 * Fixed a few memory leaks, and one rogue pointer bug.
 * Mapped keypad enter to regular enter in stdin and filter entries.
 * Added focus-follows-mouse option.
 *
 * Revision 1.48  2006/12/20 19:07:18  brennan
 *   We now use checkboxes in createHashDialog (e.g. local preferences)
 *   for elements whose default value is a length-two vector of 0 and 1,
 *   but whose value in the "real" hash is a long.
 *
 *   Turned filtering off by default
 *
 *   Claw now parses the standard X --geometry argument to set the
 *   default size and position of the window.
 *
 *   Moved load/save/edit preferences to a new 'Preferences' menu, and
 *   added all checkbox preferences directly to the menu (they still
 *   also appear in the "edit all preferences" dialog)
 *
 *   Fixed bug in which timestamps appeared multiple times in continued
 *   (>80 char) lines.
 *
 *   Fixed shout/dshout sillyness.
 *
 *   Fixed sysv init script errors.
 *
 *   Added buffer clear/reset option to right-click menus.  Will not add
 *   a button for this.  It was already in the 'Monitoring' menu.
 *
 *   Fixed bug resulting in incorrectly populated right-click menu for a
 *   process viewed in a group when the process' name was a substring of
 *   the group's name.  How's that for obscure bugs? :-)
 *
 *   When stdout filtering is turned on or off (either through the prefs
 *   dialog, or the prefs checkbox menu), immediately toggle filtering on
 *   all active process widgets, rather than waiting until they're
 *   hidden, then viewed.
 *
 *   Fixed localizeSite.sh to point search results to local pages, not
 *   gs295.
 *
 *   Updated dshout/shout to eliminate the username field. (code cleanup)
 *
 *   User's own chat messages are now displayed in green; everything else
 *   is in black.
 *
 *   Widened default filter width; now controlled by SHRUNK_WIDTH
 *   #define in processWidget.c
 *
 *   Just a note: Ctrl+U in a GtkEntry (e.g. stdin or filter) will clear
 *   all text in the entry.
 *
 *   The stdin entry / filter now remain visible when a process is dead,
 *   although stdin is disabled.  This allows the user to change the
 *   filtering and examine filtered output after a process has crashed.
 *   In addition, when a process is not running, clicks on the process
 *   widget focus the filter input.
 *
 *   The filter entry now retains a history, just like the stdin entry,
 *   that can be accessed via the up/down arrow keys.
 *
 *   Added taskbar icons for all dialogs.  For the moment, they're the
 *   same claw image as the main window; we may want to specialize them
 *   later.
 *
 *   Added a checkbox to the right of the filter that allows the user to
 *   enable or disable filtering without changing the filter text.  The
 *   [enter] approach is still supported (and checks the box when
 *   appropriate), and the checkbox is disabled when there is no text in
 *   the entry.
 *
 *   Filter now only goes red only if actual editing has occurred (not
 *   just a keypress).
 *
 *   The stdin entry line for a process widget is now greyed out when
 *   the process is dead.
 *
 *   Added footer pointing to www.microraptor.org to localized site.
 *
 *   Added release version stamp to the title png of the help page (pass
 *   version number as first argument to localizeSite.sh)
 *
 *   Added Help menu, and entry that launches a user-specified browser
 *   pointing at the RPM/APT-installed help pages.  The new preference is
 *   'help_browser'.
 *
 *   The background color of the filter entry now changes based on the
 *   active or editing state.  For reference, one must create a new
 *   GtkStyle and set it in order to override a theme engine set by the
 *   user.  GtkRcStyles do *not* do the trick.
 *
 *   We now set the background color of the 'Chat' tab if a new chat
 *   message comes in while the 'Status' tab is in the foreground.  To
 *   accomplish this, I had to disable user-theming of those two notebook
 *   tabs.
 *
 *   The 'Help' menu is now right-justified
 *
 *   Added an 'About' menu option under 'Help'.  We'll need to update the
 *   image with every release.  It's dismissed via a left-click, [enter],
 *   or [esc].
 *
 *   Fixed focus setup for filter/stdin.  When focus enters the filter or
 *   the stdin, it expands.  Much simpler, and does what we want.
 *
 *   Removed "get status", as it's no longer needed.  Left "Get status
 *   all" as "Refresh all processes' status" in the Monitoring menu,
 *   since there's an offchance you'll want to do that right at the
 *   beginning.
 *
 * Revision 1.47  2006/11/16 22:50:31  brennan
 * Made config window default wider (800 pixels).
 *
 * Fixed one echo of client shout per daemon bug.
 *
 * Make filter entry widget expand when it has focus, and vice-versa
 *
 * Claw preferences are auto-saved on exit to the last loaded file, or
 * the default (~/.claw.prefs) otherwise.
 *
 * Preferences load/save dialog is filled with .claw.prefs if no
 * existing prefs file is loaded.
 *
 * Revision 1.46  2006/11/16 18:55:04  brennan
 * Fixed bug where RCL syntax errors in set process config dialogs nuked
 * the contents of the field; the original data is now used and an error
 * message is printed to the common buffer.
 *
 * Added backup kill cmd and kill timeout to process configs.
 *
 * Made process config multiline text boxes expand with the window
 *
 * Added 'stdin_commands' to process configs.  This is a vector, but uses
 * a multiline entry in the config editing dialog.
 *
 * Added dialog during connection to central that allows graphical
 * cancellation in the event of incorrect centralhost designation.
 * Responsiveness is poor, but there's no way around that without hacking
 * IPC directly.
 *
 * Added debugger support to process configs.  Set 'debugger' to 'gdb' to
 * run the process under GDB.  This does not make use of any PATH
 * environment variable: the command must either be absolute, or relative
 * to the working_dir setting for the process.  When the process starts,
 * it will load the arguments, and stop at a gdb prompt to allow the user
 * to set breakpoints, etc.  Just type 'run' to run the process with all
 * of its arguments.  This makes use of Trey's debugger support in the daemon.
 *
 * Added icon for use in the taskbar (16x16; client/imageHeaders/miniClawImage.h)
 *
 * Added 'send signal to process' capability, using new 'signal <sig>
 * <process>' message type.  This is included everywhere run and kill
 * commands are.  Note: the popup menu that comes up when clicking the
 * signal button when viewing a process requires two clicks to select an
 * item.  This is a bug, but I haven't figured it out yet.
 *
 * New mraptord status messages supplant the claw-generated process
 * status messages, and are formatted to display which user issued run,
 * kill, and signal commands.
 *
 * Added client-side regexp filtering of process output.  This is a small
 * 'Filter' entry box in the lower-right of the process window.  Enter a
 * POSIX (e.g. grep -E)-style regexp and press [enter] to filter the
 * stdout.  Clear the entry box and press [enter] to deactivate
 * filtering.  The regexp will be displayed in green when active and
 * black when inactive.  Red denotes a regexp that is being edited while
 * the previous regexp is active.  A tooltip appears explaining this if
 * you hover over the entery box.  The regexp interface can be hidden by
 * setting the client-side preference "stdout_filtering" to 0 or false.
 *
 * Added limited chat support, via a dialog tabbed with the
 * minibuffer/error output.  This uses the new
 * shout/dshout messages.
 * Added graceful support for central crashes: a dialog is displayed to
 * inform the user of the crash, then claw exits.
 *
 * Fixed bug in which hiding, then re-viewing a process didn't fill the
 * buffer with recent output.
 *
 * Fixed newline bug in ClawText that resulted in there always being a
 * blank line at the bottom.
 *
 * Added (optional) timestamping to client output.  This is controlled
 * via the client preferences dialog.
 *
 * Added commandline and preferences option to specify the default width
 * of the configuration dialogs in claw. (--config-width /
 * default_config_width)
 *
 * Revision 1.45  2006/06/04 05:27:03  brennan
 * First pass at modularized RPMs, and changes to build under gcc 2.96.
 *
 * Revision 1.44  2004/11/25 05:20:48  brennan
 * Fixed run-all bug (using a GList* instead of its data)
 *
 * Patched a bunch of memory leaks, and all the nasty ones.  There are four
 * known remaining leaks, all dealing with the widget used to view the output
 * of a process, with a sum total of ~90 bytes leaked per process viewed.
 * Not worth my time at the moment. :-)
 *
 * Revision 1.43  2004/06/28 15:46:18  trey
 * fixed to properly find ipc.h and libipc.a in new atacama external area
 *
 * Revision 1.42  2004/04/28 18:58:50  dom
 * Appended log directive
 * 
 ***************************************************************/
