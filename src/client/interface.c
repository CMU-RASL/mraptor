/***** tell emacs we use -*- c++ -*- style comments *****
 * $Revision: 1.50 $ $Author: brennan $ $Date: 2007/05/30 19:10:31 $
 *
 * COPYRIGHT 2004, Carnegie Mellon University 
 *
 * PROJECT: Exploration Robotics (Life in the Atacama)
 *
 * MODULE:
 *
 * FILE: microraptor/client/interface.c
 *
 * DESCRIPTION:
 *
 ********************************************************/
/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 */

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>

#include <gdk/gdkkeysyms.h>
#include <gtk/gtk.h>

#include "callbacks.h"
#include "interface.h"
#include "support.h"
#include "clientComm.h"
#include "mrCommonDefs.h"
#include "RCL.h"

#include "imageHeaders.h" // For taskbar icon
#include "imageHeaders/about.h"

using namespace microraptor;

GtkWidget*
create_HeadDino (void)
{
  GtkWidget *HeadDino;
  GtkWidget *ToplevelTable;
  GtkWidget *errorOutputScrolledWindow;
  ClawText *ErrorOutput;
  ClawText *ChatOutput;
  GtkWidget *MainMenuBar;
  GtkWidget *main1;
  GtkWidget *main1_menu;
//  GtkAccelGroup *main1_menu_accels;
  GtkWidget *get_config_file1;
  GtkWidget *get_local_config_file1;
  GtkWidget *reload_local_config_file1;
  GtkWidget *set_process1;
  GtkWidget *kill_daemon;
  GtkWidget *exit2;
  GtkWidget *processes1;
  GtkWidget *processes1_menu;
//  GtkAccelGroup *processes1_menu_accels;
  GtkWidget *signals1;
  GtkWidget *signals1_menu;
//  GtkAccelGroup *signals1_menu_accels;
  GtkWidget *navigation1;
  GtkWidget *navigation1_menu;
//  GtkAccelGroup *navigation1_menu_accels;
  GtkWidget *view_selected1;
  GtkWidget *view_all1;
  GtkWidget *hide_selected1;
  GtkWidget *hide_all1;
  GtkWidget *clear_cur_buffer;
  GtkWidget *switch_to_overview;
  GtkWidget *switch_to_next_tab;
  GtkWidget *switch_to_prev_tab;
  GtkWidget *run_selected1;
  GtkWidget *run_all_selected1;
  GtkWidget *kill_selected1;
  GtkWidget *kill_all_selected1;
  GtkWidget *signal_selected1;
  GtkWidget *signal_submenu;
  GtkWidget *subscribe_selected1;
  GtkWidget *unsubscribe_selected1;
  GtkWidget *refresh_status_all;
  GtkWidget *preferences;
  GtkWidget *preferences_menu;
//  GtkAccelGroup *preferences_menu_accels;
  GtkWidget *checkbox_prefs;
  GtkWidget *set_prefs;
  GtkWidget *save_prefs;
  GtkWidget *load_prefs;
  GtkWidget *help;
  GtkWidget *help_menu;
  GtkWidget *launch_browser;
  GtkWidget *about;
  GtkWidget *swallow_window1;
  GtkWidget *HPane1;
  GtkWidget *VPane1;
  GtkWidget *LeftPaneTable;
  GtkWidget *scrolledwindow6;
  GtkWidget *ProcessTree;
  GtkWidget *processTreeEventBox;
  GtkWidget *label22;
  GtkWidget *label23;
  GtkWidget *label24;
  GtkWidget *RaptorImage;
  GtkWidget *notebook1;
  GtkWidget *errorAndChatNotebook;
  GtkWidget *errorAndChatEventBox;
  GtkWidget *proccessTableScrolledWindow;
  GtkWidget *statusPageLabel;
  GtkWidget *chatVbox;
  GtkWidget *chatScrolledWindow;
  GtkWidget *chatEntry;
  GtkWidget *chatPageLabel;
  GtkWidget *ProcessTable;
  GtkWidget *label11;
  GtkAccelGroup *accel_group;
  guint tmp_key;
  GdkModifierType tmp_mod_mask;


  // Used in various places for callbacks.
  ProcessTree = gtk_ctree_new (3, 0);

  accel_group = gtk_accel_group_new ();

  HeadDino = gtk_window_new (GTK_WINDOW_TOPLEVEL);
  gtk_object_set_data (GTK_OBJECT (HeadDino), "HeadDino", HeadDino);
  //gtk_widget_set_usize (HeadDino, 800, 600);
  gtk_window_set_default_size (GTK_WINDOW (HeadDino), 800, 600);
  gtk_window_set_policy(GTK_WINDOW (HeadDino), 
                        TRUE /* Allow shrink */,
                        TRUE /* Allow grow */,
                        FALSE /* Auto shrink */);
  gtk_window_set_title (GTK_WINDOW (HeadDino), topWindowName_g.c_str());

  ToplevelTable = gtk_table_new (2, 1, FALSE);
  g_object_ref (ToplevelTable);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "ToplevelTable", ToplevelTable,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (ToplevelTable);
  gtk_container_add (GTK_CONTAINER (HeadDino), ToplevelTable);

  VPane1 = gtk_vpaned_new ();
  g_object_ref (VPane1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "VPane1", VPane1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (VPane1);
  gtk_table_attach (GTK_TABLE (ToplevelTable), VPane1, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);

  // An eventbox so we can get mouse entry notifications for the
  // notebook.  We'll connect the signal after we create the chat page,
  // so we can pass in the chat entry widget as userdata.
  errorAndChatEventBox = gtk_event_box_new ();
  g_object_ref (errorAndChatEventBox);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "errorAndChatEventBox", errorAndChatEventBox,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_paned_pack2 (GTK_PANED (VPane1), errorAndChatEventBox, TRUE, TRUE);  
  gtk_widget_show(errorAndChatEventBox);

  // A notebook to put the minibuffer/error output and chat windows in.
  errorAndChatNotebook = gtk_notebook_new ();
  g_object_ref (errorAndChatNotebook);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "errorAndChatNotebook", errorAndChatNotebook,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_container_add (GTK_CONTAINER(errorAndChatEventBox), errorAndChatNotebook);
  gtk_notebook_set_tab_pos(GTK_NOTEBOOK(errorAndChatNotebook), GTK_POS_RIGHT);

  GtkStyle* old = gtk_widget_get_style(GTK_WIDGET(errorAndChatNotebook));
  GtkStyle* normalStyle = gtk_style_new();
  normalStyle->bg[GTK_STATE_NORMAL] = old->bg[GTK_STATE_NORMAL];
  normalStyle->bg[GTK_STATE_INSENSITIVE] = old->bg[GTK_STATE_ACTIVE];
  gtk_widget_set_style(errorAndChatNotebook, normalStyle);

  gtk_signal_connect(GTK_OBJECT(errorAndChatNotebook), "destroy",
                     G_CALLBACK(gtk_widget_destroyed),
                     &errorAndChatNotebook);

  gtk_widget_show (errorAndChatNotebook);

  errorOutputScrolledWindow = gtk_scrolled_window_new (NULL, NULL);
  g_object_ref (errorOutputScrolledWindow);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "errorOutputScrolledWindow", errorOutputScrolledWindow,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (errorOutputScrolledWindow);

  //gtk_paned_pack2 (GTK_PANED(VPane1), errorOutputScrolledWindow, TRUE, TRUE);
  gtk_widget_set_usize (errorOutputScrolledWindow, -2, 90);
  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (errorOutputScrolledWindow), GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
  GtkObject *eoWindowAdjustment = GTK_OBJECT(gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(errorOutputScrolledWindow)));
  ErrorOutput = new ClawText(gtk_text_view_new());
  ClawText::ref (ErrorOutput);
  ErrorOutput->set_font_from_string("Fixed Light 8");
  gtk_text_view_set_wrap_mode((GtkTextView *)ErrorOutput->get_text_widget(),
			      GTK_WRAP_CHAR);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "ErrorOutput", ErrorOutput,
                            (GtkDestroyNotify) &ClawText::unref);
  gtk_widget_show (ErrorOutput->get_text_widget());
  gtk_container_add (GTK_CONTAINER (errorOutputScrolledWindow), ErrorOutput->get_text_widget());
  gtk_widget_set_usize (ErrorOutput->get_text_widget(), -2, 200);
  GTK_WIDGET_UNSET_FLAGS (ErrorOutput->get_text_widget(), GTK_CAN_FOCUS);
  // Connect adjustment signals for scrolled window; do it here because we want
  //   to use ErrorOutput as our user_data.
  gtk_signal_connect (GTK_OBJECT(eoWindowAdjustment), "value-changed",
                      G_CALLBACK (on_errorOrChat_output_generic_scrolled),
                      ErrorOutput);
  gtk_signal_connect (GTK_OBJECT(eoWindowAdjustment), "changed",
                      G_CALLBACK (on_errorOrChat_output_text_expanded),
                      ErrorOutput);
  // Reset adjustment; we need to deal with the text adjustments on our own
  //Replace set adjustments with:set-scroll-adjustments
  //gtk_text_set_adjustments(GTK_TEXT(ErrorOutput->get_text_widget()),
  //                        NULL, GTK_ADJUSTMENT(eoWindowAdjustment));
  //gtk_text_set_scroll_adjustments(GTK_TEXT(ErrorOutput->get_text_widget()),
  //                          GTK_ADJUSTMENT(eoWindowAdjustment),
  //                          NULL, NULL);
  //  Add errorOutputScrolledWindow to the notebook
  statusPageLabel = gtk_label_new("Status");
  gtk_widget_set_name(statusPageLabel, "tab_label");
  //gtk_widget_modify_style(statusPageLabel, tab_rc_style);
  gtk_notebook_append_page(GTK_NOTEBOOK(errorAndChatNotebook), errorOutputScrolledWindow, statusPageLabel);

  //gtk_widget_modify_style(gtk_notebook_get_tab_label(GTK_NOTEBOOK (errorAndChatNotebook), errorOutputScrolledWindow), tab_rc_style);

  // Add chat window
  // First, we need a vertical box for the text and input widgets
  chatVbox = gtk_vbox_new(FALSE, 0);
  g_object_ref(chatVbox);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "chatVbox", chatVbox,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (chatVbox);

  //  Add box to the notebook
  chatPageLabel = gtk_label_new("Chat");
  gtk_widget_set_name(chatPageLabel, "tab_label");
  //gtk_widget_modify_style(chatPageLabel, tab_rc_style);
  gtk_notebook_append_page(GTK_NOTEBOOK(errorAndChatNotebook), chatVbox, chatPageLabel);

  //gtk_widget_modify_style(gtk_notebook_get_tab_label(GTK_NOTEBOOK (errorAndChatNotebook), chatVbox), tab_rc_style);

  // FIXME: PUT THIS IN THE RIGHT PLACE
  //gtk_rc_style_unref(tab_rc_style);

  // Now, create the text widget
  chatScrolledWindow = gtk_scrolled_window_new (NULL, NULL);
  g_object_ref (chatScrolledWindow);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "chatScrolledWindow", chatScrolledWindow,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (chatScrolledWindow);

  gtk_widget_set_usize (chatScrolledWindow, -2, 90);
  gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (chatScrolledWindow), GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
  GtkObject *chatWindowAdjustment = GTK_OBJECT(gtk_scrolled_window_get_vadjustment(GTK_SCROLLED_WINDOW(chatScrolledWindow)));

  ChatOutput = new ClawText(gtk_text_view_new());
  ChatOutput->set_font_from_string("Fixed Light 9");
  ClawText::ref (ChatOutput);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "ChatOutput", ChatOutput,
                            (GtkDestroyNotify) &ClawText::unref);
  gtk_widget_show (ChatOutput->get_text_widget());
  gtk_container_add (GTK_CONTAINER (chatScrolledWindow), ChatOutput->get_text_widget());
  gtk_widget_set_usize (ChatOutput->get_text_widget(), -2, 200);
  GTK_WIDGET_UNSET_FLAGS (ChatOutput->get_text_widget(), GTK_CAN_FOCUS);
  gtk_signal_connect(GTK_OBJECT(ChatOutput->get_text_widget()), "button_press_event",
                     G_CALLBACK (on_chat_output_button_press_event),
                     NULL);
  // Connect adjustment signals for scrolled window; do it here because we want
  //   to use ChatOutput as our user_data.
  gtk_signal_connect (GTK_OBJECT(chatWindowAdjustment), "value-changed",
                      G_CALLBACK (on_errorOrChat_output_generic_scrolled),
                      ChatOutput);
  gtk_signal_connect (GTK_OBJECT(chatWindowAdjustment), "changed",
                      G_CALLBACK (on_errorOrChat_output_text_expanded),
                      ChatOutput);
  // Reset adjustment; we need to deal with the text adjustments on our own
  //Will need to change Reset adjustment with refactoring
  //gtk_text_set_adjustments(GTK_TEXT(ChatOutput->get_text_widget()),
  //                        NULL, GTK_ADJUSTMENT(chatWindowAdjustment));
  // Add the scrolled window to the top of the vbox, and have it expand
  gtk_box_pack_start(GTK_BOX(chatVbox), chatScrolledWindow, TRUE, TRUE, 0);

  // Finally, create the input widget
  chatEntry = gtk_entry_new();
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "chatEntry", chatEntry,
                            (GtkDestroyNotify) gtk_widget_unref);
  g_object_ref(chatEntry);
  gtk_signal_connect (GTK_OBJECT(chatEntry), "activate",
                      G_CALLBACK (on_chat_input),
                      NULL);
  gtk_signal_connect(GTK_OBJECT(chatEntry), "destroy",
                     G_CALLBACK(gtk_widget_destroyed),
                     &chatEntry);
  gtk_box_pack_end(GTK_BOX(chatVbox), chatEntry, FALSE, FALSE, 0);
  gtk_widget_show(chatEntry);

  // Focus-follows-mouse support: we'll focus the chat entry if it's visible
  gtk_signal_connect (GTK_OBJECT (errorAndChatEventBox), "enter-notify-event",
                      G_CALLBACK (on_errorOrChat_enter_notify_event),
                      chatEntry);



  MainMenuBar = gtk_menu_bar_new ();
  g_object_ref (MainMenuBar);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "MainMenuBar", MainMenuBar,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (MainMenuBar);
  gtk_table_attach (GTK_TABLE (ToplevelTable), MainMenuBar, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);

  /* MAIN menu */
  main1 = gtk_menu_item_new_with_label ("");
  g_object_ref (main1);
  tmp_key = gtk_label_parse_uline (GTK_LABEL (GTK_BIN (main1)->child),
                                   _("_Main"));
  gtk_widget_add_accelerator (main1, "activate", accel_group,
                              tmp_key, GDK_MOD1_MASK, (GtkAccelFlags) 0);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "main1", main1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (main1);
  //gtk_container_add (GTK_CONTAINER (MainMenuBar), main1);
  gtk_menu_bar_append(MainMenuBar, main1);
  main1_menu = gtk_menu_new ();
  g_object_ref (main1_menu);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "main1_menu", main1_menu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_set_submenu (GTK_MENU_ITEM (main1), main1_menu);
  //main1_menu_accels = gtk_menu_ensure_uline_accel_group (GTK_MENU(main1_menu));
  get_config_file1 = gtk_menu_item_new_with_label (_("Load remote config file..."));
  g_object_ref (get_config_file1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "get_config_file1", get_config_file1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (get_config_file1);
  //gtk_container_add (GTK_CONTAINER (main1_menu), get_config_file1);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), get_config_file1);
  tmp_mod_mask = (GdkModifierType)(GDK_CONTROL_MASK | GDK_SHIFT_MASK);
  gtk_widget_add_accelerator (get_config_file1, "activate", accel_group,
                              GDK_i, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  get_local_config_file1 = gtk_menu_item_new_with_label (_("Load local config file..."));
  g_object_ref (get_local_config_file1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "get_local_config_file1", get_local_config_file1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (get_local_config_file1);
  //gtk_container_add (GTK_CONTAINER (main1_menu), get_local_config_file1);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), get_local_config_file1);
  gtk_widget_add_accelerator (get_local_config_file1, "activate", accel_group,
                              GDK_i, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  reload_local_config_file1 = gtk_menu_item_new_with_label (_("Reload last local config file"));
  g_object_ref (reload_local_config_file1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), 
                            "reload_local_config_file1", 
                            reload_local_config_file1,
                            (GtkDestroyNotify) gtk_widget_unref);
  // Can't click "reload" until we've loaded a local file. :)
  gtk_widget_set_sensitive(reload_local_config_file1, FALSE);
  gtk_widget_show (reload_local_config_file1);
  //gtk_container_add (GTK_CONTAINER (main1_menu), reload_local_config_file1);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), reload_local_config_file1);
  gtk_widget_add_accelerator (reload_local_config_file1, "activate", accel_group,
                              GDK_j, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  set_process1 = gtk_menu_item_new_with_label (_("Set process config..."));
  g_object_ref (set_process1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "set_process1", set_process1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (set_process1);
  //gtk_container_add (GTK_CONTAINER (main1_menu), set_process1);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), set_process1);
  gtk_widget_add_accelerator (set_process1, "activate", accel_group,
                              GDK_g, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  swallow_window1 = gtk_menu_item_new_with_label (_("Swallow window"));
  g_object_ref (swallow_window1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "swallow_window1", swallow_window1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (swallow_window1);
  //gtk_container_add (GTK_CONTAINER (main1_menu), swallow_window1);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), swallow_window1);
  gtk_widget_add_accelerator (swallow_window1, "activate", accel_group,
                              GDK_z, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  kill_daemon = gtk_menu_item_new_with_label (_("Kill server daemon..."));
  g_object_ref (kill_daemon);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "kill_daemon", kill_daemon,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (kill_daemon);
  //gtk_container_add (GTK_CONTAINER (main1_menu), kill_daemon);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), kill_daemon);

  exit2 = gtk_menu_item_new_with_label (_("Exit"));
  g_object_ref (exit2);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "exit2", exit2,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (exit2);
  //gtk_container_add (GTK_CONTAINER (main1_menu), exit2);
  gtk_menu_shell_append(GTK_MENU_SHELL(main1_menu), exit2);
  gtk_widget_add_accelerator (exit2, "activate", accel_group,
                              GDK_q, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* MONITORING menu */

  processes1 = gtk_menu_item_new_with_label ("");
  g_object_ref (processes1);
  tmp_key = gtk_label_parse_uline (GTK_LABEL (GTK_BIN (processes1)->child),
                                   _("M_onitoring"));
  gtk_widget_add_accelerator (processes1, "activate", accel_group,
                              tmp_key, GDK_MOD1_MASK, (GtkAccelFlags) 0);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "processes1", processes1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (processes1);
  gtk_container_add (GTK_CONTAINER (MainMenuBar), processes1);
  /* not working
  gtk_widget_add_accelerator (processes1, "activate", accel_group,
                              GDK_p, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);
  */

  processes1_menu = gtk_menu_new ();
  g_object_ref (processes1_menu);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "processes1_menu", processes1_menu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_set_submenu (GTK_MENU_ITEM (processes1), processes1_menu);
  //processes1_menu_accels = gtk_menu_ensure_uline_accel_group (GTK_MENU (processes1_menu));

  view_selected1 = gtk_menu_item_new_with_label (_("View Selected"));
  g_object_ref (view_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "view_selected1", view_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (view_selected1);
  gtk_container_add (GTK_CONTAINER (processes1_menu), view_selected1);
  gtk_widget_add_accelerator (view_selected1, "activate", accel_group,
                              GDK_s, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  view_all1 = gtk_menu_item_new_with_label (_("View All"));
  g_object_ref (view_all1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "view_all1", view_all1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (view_all1);
  gtk_container_add (GTK_CONTAINER (processes1_menu), view_all1);
  gtk_widget_add_accelerator (view_all1, "activate", accel_group,
                              GDK_s, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  hide_selected1 = gtk_menu_item_new_with_label (_("Hide Selected"));
  g_object_ref (hide_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "hide_selected1", hide_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hide_selected1);
  gtk_container_add (GTK_CONTAINER (processes1_menu), hide_selected1);
  gtk_widget_add_accelerator (hide_selected1, "activate", accel_group,
                              GDK_m, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  hide_all1 = gtk_menu_item_new_with_label (_("Hide All"));
  g_object_ref (hide_all1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "hide_all1", hide_all1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hide_all1);
  gtk_container_add (GTK_CONTAINER (processes1_menu), hide_all1);
  tmp_mod_mask = (GdkModifierType)(GDK_CONTROL_MASK | GDK_SHIFT_MASK);
  gtk_widget_add_accelerator (hide_all1, "activate", accel_group,
                              GDK_m, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  subscribe_selected1 = gtk_menu_item_new_with_label (_("Subscribe to selected"));
  g_object_ref (subscribe_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "subscribe_selected1", subscribe_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (subscribe_selected1);
  gtk_container_add (GTK_CONTAINER (processes1_menu), subscribe_selected1);
  gtk_widget_add_accelerator (subscribe_selected1, "activate", accel_group,
                              GDK_l, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  unsubscribe_selected1 = gtk_menu_item_new_with_label (_("Unsubscribe from selected"));
  g_object_ref (unsubscribe_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "unsubscribe_selected1", unsubscribe_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (unsubscribe_selected1);
  gtk_container_add (GTK_CONTAINER (processes1_menu), unsubscribe_selected1);
  gtk_widget_add_accelerator (unsubscribe_selected1, "activate", accel_group,
                              GDK_n, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  refresh_status_all = gtk_menu_item_new_with_label (_("Refresh processes' status"));
  g_object_ref (refresh_status_all);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "refresh_status_all", refresh_status_all,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (refresh_status_all);
  gtk_container_add (GTK_CONTAINER (processes1_menu), refresh_status_all);
  gtk_widget_add_accelerator (refresh_status_all, "activate", accel_group,
                              GDK_y, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  clear_cur_buffer = gtk_menu_item_new_with_label (_("Clear current buffer(s)"));
  g_object_ref (clear_cur_buffer);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "clear_cur_buffer", clear_cur_buffer,
                            (GtkDestroyNotify) gtk_widget_unref);
  // Can't clear unless there's a buffer visible
  gtk_widget_set_sensitive(clear_cur_buffer, FALSE);
  gtk_widget_show (clear_cur_buffer);
  gtk_container_add (GTK_CONTAINER (processes1_menu), clear_cur_buffer);
  gtk_widget_add_accelerator (clear_cur_buffer, "activate", accel_group,
                              GDK_m, GDK_MOD1_MASK,
                              GTK_ACCEL_VISIBLE);
  /* END MONITORING menu */

  /* CONTROL menu */
  signals1 = gtk_menu_item_new_with_label ("");
  g_object_ref (signals1);
  tmp_key = gtk_label_parse_uline (GTK_LABEL (GTK_BIN (signals1)->child),
                                   _("_Control"));
  gtk_widget_add_accelerator (signals1, "activate", accel_group,
                              tmp_key, GDK_MOD1_MASK, (GtkAccelFlags) 0);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "signals1", signals1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (signals1);
  gtk_container_add (GTK_CONTAINER (MainMenuBar), signals1);

  signals1_menu = gtk_menu_new ();
  g_object_ref (signals1_menu);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "signals1_menu", signals1_menu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_set_submenu (GTK_MENU_ITEM (signals1), signals1_menu);
  //signals1_menu_accels = gtk_menu_ensure_uline_accel_group (GTK_MENU (signals1_menu));


  /* Added by hand */
  run_selected1 = gtk_menu_item_new_with_label (_("Run Selected"));
  g_object_ref (run_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "run_selected1", run_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (run_selected1);
  gtk_container_add (GTK_CONTAINER (signals1_menu), run_selected1);
  gtk_widget_add_accelerator (run_selected1, "activate", accel_group,
                              GDK_r, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  run_all_selected1 = gtk_menu_item_new_with_label (_("Run All"));
  g_object_ref (run_all_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "run_all_selected1", run_all_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (run_all_selected1);
  gtk_container_add (GTK_CONTAINER (signals1_menu), run_all_selected1);
  gtk_widget_add_accelerator (run_all_selected1, "activate", accel_group,
                              GDK_r, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  kill_selected1 = gtk_menu_item_new_with_label (_("Kill Selected"));
  g_object_ref (kill_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "kill_selected1", kill_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (kill_selected1);
  gtk_container_add (GTK_CONTAINER (signals1_menu), kill_selected1);
  gtk_widget_add_accelerator (kill_selected1, "activate", accel_group,
                              GDK_t, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  kill_all_selected1 = gtk_menu_item_new_with_label (_("Kill All"));
  g_object_ref (kill_all_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "kill_all_selected1", kill_all_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (kill_all_selected1);
  gtk_container_add (GTK_CONTAINER (signals1_menu), kill_all_selected1);
  gtk_widget_add_accelerator (kill_all_selected1, "activate", accel_group,
                              GDK_t, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  /* Added by hand */
  // Create signal main entry
  signal_selected1 = gtk_menu_item_new_with_label (_("Signal Selected"));
  g_object_ref (signal_selected1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "signal_selected1", signal_selected1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (signal_selected1);
  gtk_container_add (GTK_CONTAINER (signals1_menu), signal_selected1);
  gtk_widget_add_accelerator (signal_selected1, "activate", accel_group,
                              GDK_s, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  // Create signal submenu items and add them
  signal_submenu = build_signal_submenu(ProcessTree, 0);

  // Attach submenu to the signal main entry
  gtk_menu_item_set_submenu(GTK_MENU_ITEM(signal_selected1), signal_submenu);

  /* END CONTROL menu */

  /* NAVIGATION menu */
  
  navigation1 = gtk_menu_item_new_with_label ("");
  g_object_ref (navigation1);
  tmp_key = gtk_label_parse_uline (GTK_LABEL (GTK_BIN (navigation1)->child),
                                   _("_Navigation"));
  gtk_widget_add_accelerator (navigation1, "activate", accel_group,
                              tmp_key, GDK_MOD1_MASK, (GtkAccelFlags) 0);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "navigation1", navigation1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (navigation1);
  gtk_container_add (GTK_CONTAINER (MainMenuBar), navigation1);

  navigation1_menu = gtk_menu_new ();
  g_object_ref (navigation1_menu);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "navigation1_menu", navigation1_menu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_set_submenu (GTK_MENU_ITEM (navigation1), navigation1_menu);
  //navigation1_menu_accels = gtk_menu_ensure_uline_accel_group (GTK_MENU (navigation1_menu));

  /* Added by hand */
  switch_to_overview = gtk_menu_item_new_with_label (_("Switch to Overview tab"));
  g_object_ref (switch_to_overview);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "switch_to_overview", switch_to_overview,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (switch_to_overview);
  gtk_container_add (GTK_CONTAINER (navigation1_menu), switch_to_overview);
  gtk_widget_add_accelerator (switch_to_overview, "activate", accel_group,
                              GDK_o, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* Switch to next tab */
  switch_to_next_tab = gtk_menu_item_new_with_label (_("Switch to next tab"));
  g_object_ref (switch_to_next_tab);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "switch_to_next_tab", switch_to_next_tab,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (switch_to_next_tab);
  gtk_container_add (GTK_CONTAINER (navigation1_menu), switch_to_next_tab);
  gtk_widget_add_accelerator (switch_to_next_tab, "activate", accel_group,
                              GDK_Tab, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  /* Switch to prev tab */
  switch_to_prev_tab = gtk_menu_item_new_with_label (_("Switch to prev tab"));
  g_object_ref (switch_to_prev_tab);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "switch_to_prev_tab", switch_to_prev_tab,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (switch_to_prev_tab);
  gtk_container_add (GTK_CONTAINER (navigation1_menu), switch_to_prev_tab);
  gtk_widget_add_accelerator (switch_to_prev_tab, "activate", accel_group,
                              GDK_Tab, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  /* END NAVIGATION menu */

  /* PREFERENCES menu */
  
  preferences = gtk_menu_item_new_with_label ("");
  g_object_ref (preferences);
  tmp_key = gtk_label_parse_uline (GTK_LABEL (GTK_BIN (preferences)->child),
                                   _("_Preferences"));
  gtk_widget_add_accelerator (preferences, "activate", accel_group,
                              tmp_key, GDK_MOD1_MASK, (GtkAccelFlags) 0);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "preferences", preferences,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (preferences);
  gtk_container_add (GTK_CONTAINER (MainMenuBar), preferences);

  preferences_menu = gtk_menu_new ();
  g_object_ref (preferences_menu);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "preferences_menu", preferences_menu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_set_submenu (GTK_MENU_ITEM (preferences), preferences_menu);
  //preferences_menu_accels = gtk_menu_ensure_uline_accel_group (GTK_MENU (preferences_menu));

  /* Add the checkbox preferences.  Need to loop through the defaults
   * in order to find checkbox prefs. */
  string ck; // Current Key
  rcl::exp ce; // Current Expression
  rcl::exp ceDef; // Current Default Expression
  string prettyName;
  string widgetName;

  FOR_EACH(pr, prefsDefault_g[0].getMap()) {
    ck = pr->first;  // Key
    ceDef = pr->second; // Expression value from defaults
    if(!is_checkbox_pref(ceDef)) {
      continue;
    }
    if(!prefs_g[0](ck).defined()) {
      cerr << "ERROR: " << ck << ", which is defined in prefsDefault, is not defined in prefs!  Boom!" << endl;
      assert(0);
    }
    ce = prefs_g[0](ck);

    prettyName = prettify_pref_name(ck);
    widgetName = "check_menu_item_";
    widgetName += ck;

    checkbox_prefs = gtk_check_menu_item_new_with_label (_(prettyName.c_str()));
    g_object_ref (checkbox_prefs);
    gtk_object_set_data_full (GTK_OBJECT (HeadDino), widgetName.c_str(), checkbox_prefs,
                              (GtkDestroyNotify) gtk_widget_unref);
    gtk_object_set_user_data (GTK_OBJECT (checkbox_prefs), strdup(widgetName.c_str()));
    gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM(checkbox_prefs),
                                    ce.getLong());
    gtk_widget_show (checkbox_prefs);
    gtk_container_add (GTK_CONTAINER (preferences_menu), checkbox_prefs);
    // A memory leak, but we wouldn't clean up until exit anyhow
    gtk_signal_connect (GTK_OBJECT (checkbox_prefs), "activate",
                        G_CALLBACK (on_checkbox_prefs_activate),
                        strdup(ck.c_str()));
  }

  /* And an edit-all-prefs link */
  set_prefs = gtk_menu_item_new_with_label (_("Edit all..."));
  g_object_ref (set_prefs);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "set_prefs", set_prefs,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (set_prefs);
  gtk_container_add (GTK_CONTAINER (preferences_menu), set_prefs);
  gtk_widget_add_accelerator (set_prefs, "activate", accel_group,
                              GDK_p, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  save_prefs = gtk_menu_item_new_with_label (_("Save preferences..."));
  g_object_ref (save_prefs);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "save_prefs", save_prefs,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (save_prefs);
  gtk_container_add (GTK_CONTAINER (preferences_menu), save_prefs);

  load_prefs = gtk_menu_item_new_with_label (_("Load preferences..."));
  g_object_ref (load_prefs);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "load_prefs", load_prefs,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (load_prefs);
  gtk_container_add (GTK_CONTAINER (preferences_menu), load_prefs);

  /* END PREFERENCES menu */

  /* HELP menu */
  
  help = gtk_menu_item_new_with_label ("Help");
  g_object_ref (help);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "help", help,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_right_justify( GTK_MENU_ITEM(help) );
  gtk_widget_show (help);
  gtk_container_add (GTK_CONTAINER (MainMenuBar), help);

  help_menu = gtk_menu_new ();
  g_object_ref (help_menu);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "help_menu", help_menu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_menu_item_set_submenu (GTK_MENU_ITEM (help), help_menu);

  /* Launch a browser pointed to locally installed help */
  launch_browser = gtk_menu_item_new_with_label (_("View help..."));
  g_object_ref (launch_browser);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "launch_browser", launch_browser,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (launch_browser);
  gtk_container_add (GTK_CONTAINER (help_menu), launch_browser);
  gtk_widget_add_accelerator (launch_browser, "activate", accel_group,
                              GDK_h, GDK_CONTROL_MASK,
                              GTK_ACCEL_VISIBLE);

  about = gtk_menu_item_new_with_label (_("About..."));
  g_object_ref (about);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "about", about,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (about);
  gtk_container_add (GTK_CONTAINER (help_menu), about);

  /* END HELP menu */

  HPane1 = gtk_hpaned_new ();
  g_object_ref (HPane1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "HPane1", HPane1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (HPane1);

  gtk_paned_pack1 (GTK_PANED(VPane1), HPane1, TRUE, TRUE);
  
  LeftPaneTable = gtk_table_new (2, 1, FALSE);
  g_object_ref (LeftPaneTable);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "LeftPaneTable", LeftPaneTable,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (LeftPaneTable);

  gtk_paned_pack1 (GTK_PANED (HPane1), LeftPaneTable, TRUE, TRUE);

  gtk_paned_set_gutter_size(GTK_PANED (HPane1), 15);
  gtk_paned_set_gutter_size(GTK_PANED (VPane1), 15);

  // Event box for focus-follows-mouse
  processTreeEventBox = gtk_event_box_new ();
  g_object_ref (processTreeEventBox);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "processTreeEventBox", processTreeEventBox,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_table_attach (GTK_TABLE (LeftPaneTable), processTreeEventBox, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL), 0, 0);
  gtk_widget_show(processTreeEventBox);
  gtk_signal_connect (GTK_OBJECT (processTreeEventBox), "enter-notify-event",
                      G_CALLBACK (on_ProcessTree_enter_notify_event),
                      ProcessTree);

  scrolledwindow6 = gtk_scrolled_window_new (NULL, NULL);
  g_object_ref (scrolledwindow6);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "scrolledwindow6", scrolledwindow6,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (scrolledwindow6);
  gtk_container_add (GTK_CONTAINER (processTreeEventBox), scrolledwindow6);
  gtk_widget_set_usize (scrolledwindow6, 100, -2);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(scrolledwindow6), 
                                 GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);

  // ProcessTree is created way above; we need it during menu creation
  g_object_ref (ProcessTree);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "ProcessTree", ProcessTree,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_set_font(ProcessTree, "Fixed Light 9");
  gtk_widget_show (ProcessTree);
  gtk_container_add (GTK_CONTAINER (scrolledwindow6), ProcessTree);
  gtk_clist_set_column_width (GTK_CLIST (ProcessTree), 0, 82);
  gtk_clist_set_column_width (GTK_CLIST (ProcessTree), 1, 65);
  gtk_clist_set_column_width (GTK_CLIST (ProcessTree), 2, 30);
  gtk_clist_set_column_auto_resize (GTK_CLIST (ProcessTree), 0, TRUE);
  gtk_clist_set_selection_mode (GTK_CLIST (ProcessTree), GTK_SELECTION_EXTENDED);
  gtk_clist_column_titles_show (GTK_CLIST (ProcessTree));
  gtk_clist_set_compare_func (GTK_CLIST (ProcessTree), treeCompareFunc);
  gtk_signal_connect(GTK_OBJECT(ProcessTree), "destroy",
                     G_CALLBACK(gtk_widget_destroyed),
                     &ProcessTree);

  label22 = gtk_label_new (_("Process"));
  g_object_ref (label22);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "label22", label22,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (label22);
  gtk_clist_set_column_widget (GTK_CLIST (ProcessTree), 0, label22);
  gtk_clist_column_title_passive (GTK_CLIST (ProcessTree), 0);

  label23 = gtk_label_new (_("Status"));
  g_object_ref (label23);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "label23", label23,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (label23);
  gtk_clist_set_column_widget (GTK_CLIST (ProcessTree), 1, label23);
  gtk_clist_column_title_passive (GTK_CLIST (ProcessTree), 1);

  label24 = gtk_label_new (_("Aux Status"));
  g_object_ref (label24);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "label24", label24,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (label24);
  gtk_clist_set_column_widget (GTK_CLIST (ProcessTree), 2, label24);
  gtk_clist_column_title_passive (GTK_CLIST (ProcessTree), 2);

  gtk_signal_connect(GTK_OBJECT(ProcessTree), "button_press_event",
                     G_CALLBACK (on_ProcessTree_button_press_event),
                     NULL);


  RaptorImage = create_pixmap (HeadDino, NULL);
  g_object_ref (RaptorImage);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "RaptorImage", RaptorImage,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_table_attach (GTK_TABLE (LeftPaneTable), RaptorImage, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_EXPAND),
                    (GtkAttachOptions) (GTK_FILL), 0, 0);

  if(prefs_get_cool_graphics()) {
    gtk_widget_show (RaptorImage);
  } else {
    gtk_widget_hide (RaptorImage);
  }
  notebook1 = gtk_notebook_new ();
  g_object_ref (notebook1);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "notebook1", notebook1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (notebook1);
  gtk_paned_pack2 (GTK_PANED (HPane1), notebook1, TRUE, TRUE);
  gtk_signal_connect(GTK_OBJECT(notebook1), "destroy",
                     G_CALLBACK(gtk_widget_destroyed),
                     &notebook1);

  proccessTableScrolledWindow = gtk_scrolled_window_new (NULL, NULL);
  g_object_ref (proccessTableScrolledWindow);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "proccessTableScrolledWindow", proccessTableScrolledWindow,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (proccessTableScrolledWindow);
  gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(proccessTableScrolledWindow), 
                                 GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
  gtk_container_add (GTK_CONTAINER (notebook1), proccessTableScrolledWindow);

  ProcessTable = gtk_table_new (1, 1, FALSE);
  g_object_ref (ProcessTable);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "ProcessTable", ProcessTable,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (ProcessTable);
  //gtk_container_add (GTK_CONTAINER (proccessTableScrolledWindow), ProcessTable);
  gtk_scrolled_window_add_with_viewport(GTK_SCROLLED_WINDOW(proccessTableScrolledWindow), ProcessTable);

  label11 = gtk_label_new (_("Overview"));
  gtk_widget_set_name(GTK_WIDGET(label11), "tab_label");
  g_object_ref (label11);
  gtk_object_set_data_full (GTK_OBJECT (HeadDino), "label11", label11,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_object_set_user_data(GTK_OBJECT(label11), NULL);
  gtk_widget_show (label11);
  gtk_notebook_set_tab_label (GTK_NOTEBOOK (notebook1), gtk_notebook_get_nth_page (GTK_NOTEBOOK (notebook1), 0), label11);

  /* Connect 101 signals */
  gtk_signal_connect (GTK_OBJECT (HeadDino), "destroy",
                      G_CALLBACK (on_HeadDino_destroy),
                      NULL);
#if 1
  gtk_signal_connect (GTK_OBJECT (MainMenuBar), "selection-done",
                      G_CALLBACK (on_MainMenuBar_selection_done),
                      NULL);
#endif
#if 1
  g_signal_connect (GTK_OBJECT (MainMenuBar), "button-press-event",
                      G_CALLBACK (on_MainMenuBar_button_press),
                      NULL);
#endif
  gtk_signal_connect (GTK_OBJECT (get_config_file1), "activate",
                      G_CALLBACK (on_get_config_file1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (get_local_config_file1), "activate",
                      G_CALLBACK (on_get_local_config_file1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (reload_local_config_file1), "activate",
                      G_CALLBACK (on_reload_local_config_file1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (set_process1), "activate",
                      G_CALLBACK (on_set_process1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (set_prefs), "activate",
                      G_CALLBACK (on_set_prefs_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (save_prefs), "activate",
                      G_CALLBACK (on_save_prefs_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (load_prefs), "activate",
                      G_CALLBACK (on_load_prefs_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (swallow_window1), "activate",
                      G_CALLBACK (on_swallow_window1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (kill_daemon), "activate",
                      G_CALLBACK (on_kill_daemon_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (exit2), "activate",
                      G_CALLBACK (on_exit2_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (processes1), "activate",
                      G_CALLBACK (on_processes1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (signals1), "activate",
                      G_CALLBACK (on_signals1_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (view_selected1), "activate",
                      G_CALLBACK (on_view_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (view_all1), "activate",
                      G_CALLBACK (on_view_all1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (hide_selected1), "activate",
                      G_CALLBACK (on_hide_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (hide_all1), "activate",
                      G_CALLBACK (on_hide_all1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (switch_to_overview), "activate",
                      G_CALLBACK (on_switch_to_overview_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (switch_to_next_tab), "activate",
                      G_CALLBACK (on_switch_to_next_tab_activate),
                      notebook1);
  gtk_signal_connect (GTK_OBJECT (switch_to_prev_tab), "activate",
                      G_CALLBACK (on_switch_to_prev_tab_activate),
                      notebook1);
  gtk_signal_connect (GTK_OBJECT (run_selected1), "activate",
                      G_CALLBACK (on_run_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (run_all_selected1), "activate",
                      G_CALLBACK (on_run_all_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (kill_selected1), "activate",
                      G_CALLBACK (on_kill_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (kill_all_selected1), "activate",
                      G_CALLBACK (on_kill_all_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (subscribe_selected1), "activate",
                      G_CALLBACK (on_subscribe_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (unsubscribe_selected1), "activate",
                      G_CALLBACK (on_unsubscribe_selected1_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (refresh_status_all), "activate",
                      G_CALLBACK (on_refresh_status_all_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (clear_cur_buffer), "activate",
                      G_CALLBACK (on_clear_cur_buffer_activate),
                      ProcessTree);
  gtk_signal_connect (GTK_OBJECT (ProcessTree), "key_press_event",
                      G_CALLBACK (on_ProcessTree_key_press_event),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (ProcessTree), "button_release_event",
                      G_CALLBACK (on_ProcessTree_button_release_event),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (notebook1), "switch-page",
                      G_CALLBACK (on_notebook_page_switched),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (errorAndChatNotebook), "switch-page",
                      G_CALLBACK (on_error_and_chat_notebook_page_switched),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (HeadDino), "key_press_event",
                      G_CALLBACK (on_HeadDino_key_press_event),
                      notebook1);
  gtk_signal_connect (GTK_OBJECT (launch_browser), "activate",
                      G_CALLBACK (on_launch_browser_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (about), "activate",
                      G_CALLBACK (on_about_activate),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (HeadDino), accel_group);
  gtk_accel_group_lock(accel_group);

  return HeadDino;
}


void mod_HeadDino_postShow(void) {
  // The error/chat dialog should start out as 100 pixels high;
  // defined in interface.h
  GtkWidget* VPane1 = lookup_widget(HeadDino_g, "VPane1");
  gtk_paned_set_position (GTK_PANED (VPane1), VPane1->allocation.height - INITIAL_ERROR_CHAT_HEIGHT_PIX);

  // The process tree should leave enough space for a full terminal,
  // as long as there's a bit of room for it.
  GtkWidget* HPane1 = lookup_widget(HeadDino_g, "HPane1");
  int hpanePos = 220;
  if(HPane1->allocation.width - hpanePos < PROCESSWIDGET_MIN_WIDTH) {
    hpanePos = HPane1->allocation.width - PROCESSWIDGET_MIN_WIDTH;
    if(hpanePos < PROCESSTREE_MIN_INITIAL_WIDTH)
      hpanePos = PROCESSTREE_MIN_INITIAL_WIDTH;
  }
  gtk_paned_set_position (GTK_PANED (HPane1), hpanePos);

}

GtkWidget*
create_loadFileDialog (void)
{
  GtkWidget *loadFileDialog;
  GtkWidget *dialog_vbox3;
  GtkWidget *table1;
  GtkWidget *label32;
  GtkWidget *label24;
  GtkWidget *filenameEntry;
  GtkWidget *daemonOptionMenu;
  GtkWidget *daemonOptionMenu_menu;
  GtkWidget *glade_menuitem;
  GtkWidget *dialog_action_area3;
  GtkWidget *hbuttonbox3;
  GtkWidget *loadButton;
  GtkWidget *cancelButton;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask;
  
  accel_group = gtk_accel_group_new ();

  loadFileDialog = gtk_dialog_new ();
  gtk_object_set_data (GTK_OBJECT (loadFileDialog), "loadFileDialog", loadFileDialog);
  gtk_window_set_title (GTK_WINDOW (loadFileDialog), _("Load Remote Config File"));
  gtk_window_set_policy (GTK_WINDOW (loadFileDialog), TRUE, TRUE, FALSE);

  dialog_vbox3 = GTK_DIALOG (loadFileDialog)->vbox;
  gtk_object_set_data (GTK_OBJECT (loadFileDialog), "dialog_vbox3", dialog_vbox3);
  gtk_widget_show (dialog_vbox3);

  table1 = gtk_table_new (2, 2, FALSE);
  g_object_ref (table1);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "table1", table1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (table1);
  gtk_box_pack_start (GTK_BOX (dialog_vbox3), table1, TRUE, TRUE, 0);

  label32 = gtk_label_new (_("Daemon to load on (short machine name):"));
  g_object_ref (label32);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "label32", label32,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (label32);
  gtk_table_attach (GTK_TABLE (table1), label32, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label32), 0, 0.5);

  label24 = gtk_label_new (_("Enter config filename (on daemon machine):"));
  g_object_ref (label24);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "label24", label24,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (label24);
  gtk_table_attach (GTK_TABLE (table1), label24, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_misc_set_alignment (GTK_MISC (label24), 0, 0.5);

  filenameEntry = gtk_entry_new ();
  g_object_ref (filenameEntry);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "filenameEntry", filenameEntry,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (filenameEntry);
  gtk_table_attach (GTK_TABLE (table1), filenameEntry, 1, 2, 1, 2,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_signal_connect (GTK_OBJECT (filenameEntry), "activate",
                      G_CALLBACK (on_loadFile_filenameEntry_activate),
                      NULL);


  daemonOptionMenu = gtk_option_menu_new ();
  g_object_ref (daemonOptionMenu);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "daemonOptionMenu", 
                            daemonOptionMenu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (daemonOptionMenu);
  gtk_table_attach (GTK_TABLE (table1), daemonOptionMenu, 1, 2, 0, 1,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  daemonOptionMenu_menu = gtk_menu_new ();

  FOR_EACH(connPair, daemon_comm_g->get_connections()) {
    // Clients are in the connections list too
    if(MR_Comm::extract_type_from_module_name((*connPair).first) == "d") {
      glade_menuitem = gtk_menu_item_new_with_label (_((*connPair).first.c_str()));
      gtk_widget_show (glade_menuitem);
      gtk_menu_append (GTK_MENU (daemonOptionMenu_menu), glade_menuitem);    
    }
  }

  gtk_option_menu_set_menu (GTK_OPTION_MENU (daemonOptionMenu), daemonOptionMenu_menu);

  dialog_action_area3 = GTK_DIALOG (loadFileDialog)->action_area;
  gtk_object_set_data (GTK_OBJECT (loadFileDialog), "dialog_action_area3", dialog_action_area3);
  gtk_widget_show (dialog_action_area3);
  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area3), 10);

  hbuttonbox3 = gtk_hbutton_box_new ();
  g_object_ref (hbuttonbox3);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "hbuttonbox3", hbuttonbox3,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hbuttonbox3);
  gtk_box_pack_start (GTK_BOX (dialog_action_area3), hbuttonbox3, TRUE, TRUE, 0);

  loadButton = gtk_button_new_with_label (_("Load"));
  g_object_ref (loadButton);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "loadButton", loadButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (loadButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox3), loadButton);
  GTK_WIDGET_SET_FLAGS (loadButton, GTK_CAN_DEFAULT);

  cancelButton = gtk_button_new_with_label (_("Cancel"));
  g_object_ref (cancelButton);
  gtk_object_set_data_full (GTK_OBJECT (loadFileDialog), "cancelButton", cancelButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (cancelButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox3), cancelButton);
  GTK_WIDGET_SET_FLAGS (cancelButton, GTK_CAN_DEFAULT);
  tmp_mod_mask = (GdkModifierType)0;
  gtk_widget_add_accelerator (cancelButton, "clicked", accel_group,
                              GDK_Escape, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (loadButton), "clicked",
                      G_CALLBACK (on_loadFile_loadButton_clicked),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (cancelButton), "clicked",
                      G_CALLBACK (on_loadFile_cancelButton_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (loadFileDialog), accel_group);
  gtk_widget_grab_focus(filenameEntry);

  return loadFileDialog;
}


GtkWidget*
create_savePrefsFileSelection (void)
{
  GtkWidget *savePrefsFileSelection;
  GtkWidget *load_button;
  GtkWidget *cancel_button1;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask = (GdkModifierType)0;
  accel_group = gtk_accel_group_new ();

  savePrefsFileSelection = gtk_file_selection_new (_("Save Preferences"));
  gtk_object_set_data (GTK_OBJECT (savePrefsFileSelection), "savePrefsFileSelection", savePrefsFileSelection);
  gtk_container_set_border_width (GTK_CONTAINER (savePrefsFileSelection), 10);
  gtk_file_selection_hide_fileop_buttons (GTK_FILE_SELECTION (savePrefsFileSelection));

  load_button = GTK_FILE_SELECTION (savePrefsFileSelection)->ok_button;
  gtk_object_set_data (GTK_OBJECT (savePrefsFileSelection), "load_button", load_button);
  gtk_widget_show (load_button);
  GTK_WIDGET_SET_FLAGS (load_button, GTK_CAN_DEFAULT);

  cancel_button1 = GTK_FILE_SELECTION (savePrefsFileSelection)->cancel_button;
  gtk_object_set_data (GTK_OBJECT (savePrefsFileSelection), "cancel_button1", cancel_button1);
  gtk_widget_show (cancel_button1);
  GTK_WIDGET_SET_FLAGS (cancel_button1, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancel_button1, "clicked", accel_group,
                              GDK_Escape, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (load_button), "clicked",
                      G_CALLBACK (on_savePrefsFileSelection_load_button_clicked),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (cancel_button1), "clicked",
                      G_CALLBACK (on_savePrefsFileSelection_cancel_button1_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (savePrefsFileSelection), accel_group);
  gtk_widget_grab_focus (savePrefsFileSelection);

  return savePrefsFileSelection;
}

GtkWidget*
create_loadPrefsFileSelection (void)
{
  GtkWidget *loadPrefsFileSelection;
  GtkWidget *load_button;
  GtkWidget *cancel_button1;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask = (GdkModifierType)0;

  accel_group = gtk_accel_group_new ();

  loadPrefsFileSelection = gtk_file_selection_new (_("Load Preferences"));
  gtk_object_set_data (GTK_OBJECT (loadPrefsFileSelection), "loadPrefsFileSelection", loadPrefsFileSelection);
  gtk_container_set_border_width (GTK_CONTAINER (loadPrefsFileSelection), 10);
  gtk_file_selection_hide_fileop_buttons (GTK_FILE_SELECTION (loadPrefsFileSelection));

  load_button = GTK_FILE_SELECTION (loadPrefsFileSelection)->ok_button;
  gtk_object_set_data (GTK_OBJECT (loadPrefsFileSelection), "load_button", load_button);
  gtk_widget_show (load_button);
  GTK_WIDGET_SET_FLAGS (load_button, GTK_CAN_DEFAULT);

  cancel_button1 = GTK_FILE_SELECTION (loadPrefsFileSelection)->cancel_button;
  gtk_object_set_data (GTK_OBJECT (loadPrefsFileSelection), "cancel_button1", cancel_button1);
  gtk_widget_show (cancel_button1);
  GTK_WIDGET_SET_FLAGS (cancel_button1, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancel_button1, "clicked", accel_group,
                              GDK_Escape,   tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (load_button), "clicked",
                      G_CALLBACK (on_loadPrefsFileSelection_load_button_clicked),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (cancel_button1), "clicked",
                      G_CALLBACK (on_loadPrefsFileSelection_cancel_button1_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (loadPrefsFileSelection), accel_group);
  gtk_widget_grab_focus (loadPrefsFileSelection);

  return loadPrefsFileSelection;
}

GtkWidget*
create_localFileSelection (void)
{
  GtkWidget *localFileSelection;
  GtkWidget *load_button;
  GtkWidget *cancel_button1;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask = (GdkModifierType)0;

  accel_group = gtk_accel_group_new ();

  localFileSelection = gtk_file_selection_new (_("Select Local Config File"));
  gtk_object_set_data (GTK_OBJECT (localFileSelection), "localFileSelection", localFileSelection);
  gtk_container_set_border_width (GTK_CONTAINER (localFileSelection), 10);
  gtk_file_selection_hide_fileop_buttons (GTK_FILE_SELECTION (localFileSelection));

  load_button = GTK_FILE_SELECTION (localFileSelection)->ok_button;
  gtk_object_set_data (GTK_OBJECT (localFileSelection), "load_button", load_button);
  gtk_widget_show (load_button);
  GTK_WIDGET_SET_FLAGS (load_button, GTK_CAN_DEFAULT);

  cancel_button1 = GTK_FILE_SELECTION (localFileSelection)->cancel_button;
  gtk_object_set_data (GTK_OBJECT (localFileSelection), "cancel_button1", cancel_button1);
  gtk_widget_show (cancel_button1);
  GTK_WIDGET_SET_FLAGS (cancel_button1, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancel_button1, "clicked", accel_group,
                              GDK_Escape, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (load_button), "clicked",
                      G_CALLBACK (on_localFileSelection_load_button_clicked),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (cancel_button1), "clicked",
                      G_CALLBACK (on_localFileSelection_cancel_button1_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (localFileSelection), accel_group);
  gtk_widget_grab_focus (localFileSelection);

  return localFileSelection;
}

GtkWidget*
create_pickDaemonDialog (void)
{
  GtkWidget *pickDaemonDialog;
  GtkWidget *dialog_vbox2;
  GtkWidget *table2;
  GtkWidget *label31;
  GtkWidget *daemonEntry;
  GtkWidget *dialog_action_area2;
  GtkWidget *hbuttonbox2;
  GtkWidget *connectButton;
  GtkWidget *cancelButton;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask = (GdkModifierType)0;

  accel_group = gtk_accel_group_new ();

  pickDaemonDialog = gtk_dialog_new ();
  gtk_object_set_data (GTK_OBJECT (pickDaemonDialog), "pickDaemonDialog", pickDaemonDialog);
  gtk_window_set_title (GTK_WINDOW (pickDaemonDialog), _("Pick a Daemon, Any Daemon!"));
  gtk_window_set_policy (GTK_WINDOW (pickDaemonDialog), TRUE, TRUE, FALSE);

  dialog_vbox2 = GTK_DIALOG (pickDaemonDialog)->vbox;
  gtk_object_set_data (GTK_OBJECT (pickDaemonDialog), "dialog_vbox2", dialog_vbox2);
  gtk_widget_show (dialog_vbox2);

  table2 = gtk_table_new (2, 1, FALSE);
  g_object_ref (table2);
  gtk_object_set_data_full (GTK_OBJECT (pickDaemonDialog), "table2", table2,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (table2);
  gtk_box_pack_start (GTK_BOX (dialog_vbox2), table2, FALSE, TRUE, 3);

  label31 = gtk_label_new (_("Enter short name of daemon's machine:"));
  g_object_ref (label31);
  gtk_object_set_data_full (GTK_OBJECT (pickDaemonDialog), "label31", label31,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (label31);
  gtk_table_attach (GTK_TABLE (table2), label31, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);
  gtk_label_set_justify (GTK_LABEL (label31), GTK_JUSTIFY_LEFT);
  gtk_misc_set_alignment (GTK_MISC (label31), 0, 0.5);

  daemonEntry = gtk_entry_new ();
  g_object_ref (daemonEntry);
  gtk_object_set_data_full (GTK_OBJECT (pickDaemonDialog), "daemonEntry", daemonEntry,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (daemonEntry);
  gtk_table_attach (GTK_TABLE (table2), daemonEntry, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                    (GtkAttachOptions) (0), 0, 0);

  dialog_action_area2 = GTK_DIALOG (pickDaemonDialog)->action_area;
  gtk_object_set_data (GTK_OBJECT (pickDaemonDialog), "dialog_action_area2", dialog_action_area2);
  gtk_widget_show (dialog_action_area2);
  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area2), 10);

  hbuttonbox2 = gtk_hbutton_box_new ();
  g_object_ref (hbuttonbox2);
  gtk_object_set_data_full (GTK_OBJECT (pickDaemonDialog), "hbuttonbox2", hbuttonbox2,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hbuttonbox2);
  gtk_box_pack_start (GTK_BOX (dialog_action_area2), hbuttonbox2, TRUE, TRUE, 0);

  connectButton = gtk_button_new_with_label (_("Connect"));
  g_object_ref (connectButton);
  gtk_object_set_data_full (GTK_OBJECT (pickDaemonDialog), "connectButton", connectButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (connectButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox2), connectButton);
  GTK_WIDGET_SET_FLAGS (connectButton, GTK_CAN_DEFAULT);

  cancelButton = gtk_button_new_with_label (_("Cancel"));
  g_object_ref (cancelButton);
  gtk_object_set_data_full (GTK_OBJECT (pickDaemonDialog), "cancelButton", cancelButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (cancelButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox2), cancelButton);
  GTK_WIDGET_SET_FLAGS (cancelButton, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancelButton, "clicked", accel_group,
                              GDK_Escape, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (daemonEntry), "activate",
                      G_CALLBACK (on_pickDaemon_daemonEntry_activate),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (connectButton), "clicked",
                      G_CALLBACK (on_pickDaemon_connectButton_clicked),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (cancelButton), "clicked",
                      G_CALLBACK (on_pickDaemon_cancelButton_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (pickDaemonDialog), accel_group);
  gtk_widget_grab_focus(daemonEntry);

  return pickDaemonDialog;
}


GtkWidget*
create_pickTargetDialog (void)
{
  GtkWidget *pickTargetDialog;
  GtkWidget *dialog_vbox4;
  GtkWidget *daemonOptionMenu;
  GtkWidget *daemonOptionMenu_menu;
  GtkWidget *glade_menuitem;
  GtkWidget *dialog_action_area4;
  GtkWidget *hbuttonbox4;
  GtkWidget *killButton;
  GtkWidget *cancelButton;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask = (GdkModifierType)0; 

  accel_group = gtk_accel_group_new ();

  /*
    FIXME: CHECK HOW MANY CONNECTIONS HAVE BEEN MADE
  if(daemon_connections == NULL) {
    fprintf(stderr, "No daemon connections have been made, thus you can't kill any.\n");
    return NULL;
  }
  */

  pickTargetDialog = gtk_dialog_new ();
  gtk_object_set_data (GTK_OBJECT (pickTargetDialog), "pickTargetDialog", pickTargetDialog);
  gtk_window_set_title (GTK_WINDOW (pickTargetDialog), _("Pick Daemon to Kill"));
  gtk_window_set_policy (GTK_WINDOW (pickTargetDialog), TRUE, TRUE, FALSE);

  dialog_vbox4 = GTK_DIALOG (pickTargetDialog)->vbox;
  gtk_object_set_data (GTK_OBJECT (pickTargetDialog), "dialog_vbox4", dialog_vbox4);
  gtk_widget_show (dialog_vbox4);

  daemonOptionMenu = gtk_option_menu_new ();
  g_object_ref (daemonOptionMenu);
  gtk_object_set_data_full (GTK_OBJECT (pickTargetDialog), "daemonOptionMenu", daemonOptionMenu,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (daemonOptionMenu);
  gtk_box_pack_start (GTK_BOX (dialog_vbox4), daemonOptionMenu, FALSE, FALSE, 11);
  daemonOptionMenu_menu = gtk_menu_new ();

  FOR_EACH(connPair, daemon_comm_g->get_connections()) {
    // Clients are in the connections list too
    if(MR_Comm::extract_type_from_module_name((*connPair).first) == "d") {
      glade_menuitem = gtk_menu_item_new_with_label (_((*connPair).first.c_str()));
      gtk_widget_show (glade_menuitem);
      gtk_menu_append (GTK_MENU (daemonOptionMenu_menu), glade_menuitem);    
    }
  }

  gtk_option_menu_set_menu (GTK_OPTION_MENU (daemonOptionMenu), daemonOptionMenu_menu);

  dialog_action_area4 = GTK_DIALOG (pickTargetDialog)->action_area;
  gtk_object_set_data (GTK_OBJECT (pickTargetDialog), "dialog_action_area4", dialog_action_area4);
  gtk_widget_show (dialog_action_area4);
  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area4), 10);

  hbuttonbox4 = gtk_hbutton_box_new ();
  g_object_ref (hbuttonbox4);
  gtk_object_set_data_full (GTK_OBJECT (pickTargetDialog), "hbuttonbox4", hbuttonbox4,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hbuttonbox4);
  gtk_box_pack_start (GTK_BOX (dialog_action_area4), hbuttonbox4, TRUE, TRUE, 0);

  killButton = gtk_button_new_with_label (_("Kill"));
  g_object_ref (killButton);
  gtk_object_set_data_full (GTK_OBJECT (pickTargetDialog), "killButton", killButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (killButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox4), killButton);
  GTK_WIDGET_SET_FLAGS (killButton, GTK_CAN_DEFAULT);

  cancelButton = gtk_button_new_with_label (_("Cancel"));
  g_object_ref (cancelButton);
  gtk_object_set_data_full (GTK_OBJECT (pickTargetDialog), "cancelButton", cancelButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (cancelButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox4), cancelButton);
  GTK_WIDGET_SET_FLAGS (cancelButton, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancelButton, "clicked", accel_group,
                              GDK_Escape, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (killButton), "clicked",
                      G_CALLBACK (on_pickTargetDialog_killButton_clicked),
                      NULL);
  gtk_signal_connect (GTK_OBJECT (cancelButton), "clicked",
                      G_CALLBACK (on_pickTargetDialog_cancelButton_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (pickTargetDialog), accel_group);
  gtk_widget_grab_focus (daemonOptionMenu);

  return pickTargetDialog;
}


GtkWidget*
create_cancelLaunchDialog (const char* centralhost)
{
  GtkWidget *cancelLaunchDialog;
  GtkWidget *dialog_vbox4;
  GtkWidget *dialog_action_area4;
  GtkWidget *spaceHbox;
  GtkWidget *cancelButton;
  GtkWidget *label;
  GtkAccelGroup *accel_group;
  GdkModifierType tmp_mod_mask = (GdkModifierType)0;
  char msg[4096];

  accel_group = gtk_accel_group_new ();

  cancelLaunchDialog = gtk_dialog_new ();
  gtk_object_set_data (GTK_OBJECT (cancelLaunchDialog), "cancelLaunchDialog", cancelLaunchDialog);
  gtk_window_set_title (GTK_WINDOW (cancelLaunchDialog), _("Making IPC connection..."));
  gtk_window_set_policy (GTK_WINDOW (cancelLaunchDialog), TRUE, TRUE, FALSE);
  gtk_window_set_modal (GTK_WINDOW (cancelLaunchDialog), TRUE);
  gtk_window_set_position (GTK_WINDOW (cancelLaunchDialog), GTK_WIN_POS_CENTER);

  dialog_vbox4 = GTK_DIALOG (cancelLaunchDialog)->vbox;
  gtk_object_set_data (GTK_OBJECT (cancelLaunchDialog), "dialog_vbox4", dialog_vbox4);
  gtk_widget_show (dialog_vbox4);

  spaceHbox = gtk_hbox_new(FALSE, 10);
  g_object_ref (spaceHbox);
  gtk_object_set_data_full (GTK_OBJECT (cancelLaunchDialog), "spaceHbox", spaceHbox,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (spaceHbox);
  gtk_box_pack_start (GTK_BOX (dialog_vbox4), spaceHbox, FALSE, FALSE, 30);

  if(centralhost != NULL) {
    sprintf(msg, "Connecting to IPC central at %s; response to cancellation will be slow.", centralhost);
  } else {
    sprintf(msg, "Connecting to IPC central; response to cancellation will be slow.");
  }

  label = gtk_label_new(msg);
  g_object_ref (label);
  gtk_object_set_data_full (GTK_OBJECT (cancelLaunchDialog), "label", label,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_label_set_line_wrap (GTK_LABEL (label), TRUE);
  gtk_widget_show (label);
  gtk_box_pack_start (GTK_BOX (spaceHbox), label, FALSE, FALSE, 30);

  dialog_action_area4 = GTK_DIALOG (cancelLaunchDialog)->action_area;
  gtk_object_set_data (GTK_OBJECT (cancelLaunchDialog), "dialog_action_area4", dialog_action_area4);
  gtk_widget_show (dialog_action_area4);
  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area4), 10);

  cancelButton = gtk_button_new_with_label (_("Cancel and Exit"));
  g_object_ref (cancelButton);
  gtk_object_set_data_full (GTK_OBJECT (cancelLaunchDialog), "cancelButton", cancelButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (cancelButton);
  gtk_container_add (GTK_CONTAINER (dialog_action_area4), cancelButton);
  GTK_WIDGET_SET_FLAGS (cancelButton, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancelButton, "clicked", accel_group,
                              GDK_Escape, tmp_mod_mask,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (cancelButton), "clicked",
                      G_CALLBACK (on_cancelLaunchDialog_cancelButton_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (cancelLaunchDialog), accel_group);
  gtk_widget_grab_focus (cancelButton);

  return cancelLaunchDialog;
}

GtkWidget* create_aboutDialog (void) {
  GtkWidget *dialog = gtk_window_new (GTK_WINDOW_POPUP);
  gtk_widget_set_usize (dialog, 500, 300);
  gtk_window_set_policy (GTK_WINDOW (dialog), FALSE, FALSE, TRUE);
  gtk_window_set_title (GTK_WINDOW (dialog), "About Microraptor");
  gtk_window_set_modal (GTK_WINDOW (dialog), TRUE);

  // We need an event box, since a GtkPixmap can't receive events.
  GtkWidget* evbox = gtk_event_box_new();
  g_object_ref(evbox);
  gtk_container_add (GTK_CONTAINER (dialog), evbox);
  gtk_widget_show(evbox);

  // Cut down on decorations
  //gdk_window_set_decorations(dialog->window, GDK_DECOR_BORDER);

  // The pixmap will go here.  
  GtkWidget *image = create_pixmap (dialog, NULL);
  g_object_ref (image);
  gtk_container_add (GTK_CONTAINER (evbox), image);

  // Build the pixmap from an XPM in memory. It just uses HeadDino_g
  // for its colormap; this lets us create the pixmap before showing
  // the window, and looks much nicer.
  GdkBitmap *mask;
  GtkStyle* style = gtk_widget_get_style (dialog);
  GdkPixmap* pixmap = gdk_pixmap_create_from_xpm_d (HeadDino_g->window, &mask,
                                                    &style->bg[GTK_STATE_NORMAL],
                                                    (gchar**)about_xpm);
  gtk_pixmap_set (GTK_PIXMAP(image), pixmap, mask);

  // Set up callback to click-and-go-away
  gtk_signal_connect (GTK_OBJECT (evbox), "button-release-event",
                      G_CALLBACK (on_aboutDialog_button_release_event),
                      NULL);
  // For some reason, the window gets the key events.  Odd.
  gtk_signal_connect (GTK_OBJECT (dialog), "key-press-event",
                      G_CALLBACK (on_aboutDialog_key_release_event),
                      NULL);

  gtk_widget_show (image);  

  gtk_widget_grab_focus(evbox);

  return dialog;
}

GtkWidget*
create_contextDialog (ProcessWidget* pw)
{
  GtkWidget *contextDialog;
  GtkWidget *dialog_vbox;
  GtkWidget *gridTable;
  GtkWidget *notesLabel;
  GtkWidget *preLabel;
  GtkWidget *preSpin;
  GtkObject *preSpinAdj;
  GtkWidget *postLabel;
  GtkWidget *postSpin;
  GtkObject *postSpinAdj;
  GtkWidget *dialog_action_area;
  GtkWidget *hbuttonbox;
  GtkWidget *okButton;
  GtkWidget *cancelButton;
  GtkAccelGroup *accel_group;

  contextDialog = gtk_dialog_new();
  gtk_object_set_data (GTK_OBJECT (contextDialog), "contextDialog", contextDialog);
  gtk_window_set_title (GTK_WINDOW (contextDialog), "Set Filter Context");
  gtk_window_set_policy (GTK_WINDOW (contextDialog), TRUE, TRUE, FALSE);

  // VBox to hold all chillun's
  dialog_vbox = GTK_DIALOG (contextDialog)->vbox;
  gtk_object_set_data (GTK_OBJECT (contextDialog), "dialog_vbox", dialog_vbox);
  gtk_container_set_border_width(GTK_CONTAINER(dialog_vbox), 10);
  gtk_widget_show (dialog_vbox);

  notesLabel = gtk_label_new ("Set the lines of context that are printed\nbefore and/or after each matched line.\nThis is akin to grep's -B and -A options.");
  g_object_ref (notesLabel);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "notesLabel", notesLabel,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_label_set_justify (GTK_LABEL (notesLabel), GTK_JUSTIFY_LEFT);
  gtk_misc_set_alignment (GTK_MISC (notesLabel), 0, 0.5);
  gtk_box_pack_start (GTK_BOX (dialog_vbox), notesLabel, TRUE, TRUE, 0);
  gtk_widget_show (notesLabel);

  gridTable = gtk_table_new (2, 2, FALSE);
  g_object_ref (gridTable);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "gridTable", gridTable,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_container_set_border_width(GTK_CONTAINER(gridTable), 5);
  gtk_table_set_row_spacings(GTK_TABLE(gridTable), 3);
  gtk_table_set_col_spacings(GTK_TABLE(gridTable), 3);
  gtk_widget_show (gridTable);
  gtk_box_pack_start (GTK_BOX (dialog_vbox), gridTable, TRUE, TRUE, 0);

  preLabel = gtk_label_new ("Pre-context:");
  g_object_ref (preLabel);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "preLabel", preLabel,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_object_set_user_data(GTK_OBJECT(preLabel), NULL);
  gtk_label_set_justify (GTK_LABEL (preLabel), GTK_JUSTIFY_LEFT);
  gtk_misc_set_alignment (GTK_MISC (preLabel), 0, 0.5);
  gtk_table_attach (GTK_TABLE (gridTable), preLabel, 0, 1, 0, 1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (GTK_FILL), 0, 0);
  gtk_widget_show (preLabel);

  preSpinAdj = gtk_adjustment_new (pw->regexpPreContext, 0, 100, 1, 5, 5);
  preSpin = gtk_spin_button_new ( GTK_ADJUSTMENT (preSpinAdj), 1.0, 0);
  g_object_ref (preSpin);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "preSpin", preSpin,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (preSpin), TRUE);
  gtk_spin_button_set_snap_to_ticks (GTK_SPIN_BUTTON (preSpin), TRUE);
  gtk_table_attach (GTK_TABLE (gridTable), preSpin, 1, 2, 0, 1,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (GTK_FILL), 0, 0);
  gtk_widget_show (preSpin);

  postLabel = gtk_label_new ("Post-context:");
  g_object_ref (postLabel);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "postLabel", postLabel,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_object_set_user_data(GTK_OBJECT(postLabel), NULL);
  gtk_label_set_justify (GTK_LABEL (postLabel), GTK_JUSTIFY_LEFT);
  gtk_misc_set_alignment (GTK_MISC (postLabel), 0, 0.5);
  gtk_table_attach (GTK_TABLE (gridTable), postLabel, 0, 1, 1, 2,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (GTK_FILL), 0, 0);
  gtk_widget_show (postLabel);

  postSpinAdj = gtk_adjustment_new (pw->regexpPostContext, 0, 100, 1, 5, 5);
  postSpin = gtk_spin_button_new (GTK_ADJUSTMENT (postSpinAdj), 1.0, 0);
  g_object_ref (postSpin);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "postSpin", postSpin,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_spin_button_set_numeric (GTK_SPIN_BUTTON (postSpin), TRUE);
  gtk_spin_button_set_snap_to_ticks (GTK_SPIN_BUTTON (postSpin), TRUE);
  gtk_table_attach (GTK_TABLE (gridTable), postSpin, 1, 2, 1, 2,
                    (GtkAttachOptions) (GTK_FILL),
                    (GtkAttachOptions) (GTK_FILL), 0, 0);
  gtk_widget_show (postSpin);
    
  accel_group = gtk_accel_group_new ();

  // Do common setup at end of dialog    
  dialog_action_area = GTK_DIALOG (contextDialog)->action_area;
  gtk_object_set_data (GTK_OBJECT (contextDialog), "dialog_action_area", dialog_action_area);
  gtk_widget_show (dialog_action_area);
  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area), 10);

  hbuttonbox = gtk_hbutton_box_new ();
  g_object_ref (hbuttonbox);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "hbuttonbox", hbuttonbox,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hbuttonbox);
  gtk_box_pack_start (GTK_BOX (dialog_action_area), hbuttonbox, TRUE, TRUE, 0);

  okButton = gtk_button_new_with_label (_("OK"));
  g_object_ref (okButton);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "okButton", okButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_object_set_user_data(GTK_OBJECT(okButton), (void *) pw);
  gtk_widget_show (okButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox), okButton);
  GTK_WIDGET_SET_FLAGS (okButton, GTK_CAN_DEFAULT);

  cancelButton = gtk_button_new_with_label (_("Cancel"));
  g_object_ref (cancelButton);
  gtk_object_set_data_full (GTK_OBJECT (contextDialog), "cancelButton", cancelButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (cancelButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox), cancelButton);
  GTK_WIDGET_SET_FLAGS (cancelButton, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancelButton, "clicked", accel_group,
                              GDK_Escape, (GdkModifierType)0,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (okButton), "clicked",
                      G_CALLBACK (on_contextDialog_okButton_clicked),
                      pw);
  gtk_signal_connect (GTK_OBJECT (cancelButton), "clicked",
                      G_CALLBACK (on_contextDialog_cancelButton_clicked),
                      NULL);

  gtk_window_add_accel_group (GTK_WINDOW (contextDialog), accel_group);

  gtk_widget_grab_focus (preSpin);

  return contextDialog;
}


bool
pair_string_exp_comp(pair<string, rcl::exp> a, pair<string, rcl::exp> b) {
  return a.first < b.first;
}


GtkWidget*
create_editHashDialog (string windowName, 
                       rcl::exp h, 
                       rcl::exp def,
                       void (*userCallback) (rcl::exp))
{
  GtkWidget *editHashDialog;
  GtkWidget *dialog_vbox1;
  GtkWidget *gridTable;
  GtkWidget *label;
  GtkWidget *entry;
  GtkWidget *firstEntry = NULL; // Cache 

  GtkWidget *dialog_action_area1;
  GtkWidget *hbuttonbox1;
  GtkWidget *okButton;
  GtkWidget *cancelButton;
  GtkAccelGroup *accel_group;
  int        numElements;
  string     widgetName;
  char       suffix[255];
  string     elementName;
  rcl::map defbody;
  ProcessData* ppd;
  rcl::exp ce; // Current Expression
  string ck; // Current Key
  string example;
  rcl::exp* initialConfigCopy;
  bool isCheckBox;

  if(h.getType() != RCL_MAP_TYPE) {
    cerr << "ERROR: create_editHashDialog called with an argument rcl::exp of type " 
         << h.getType() 
         << "!" << endl << "   That's not a map!  Give me my Rand McNally!" << endl;
    return NULL;
  }
  if(def.defined() && def.getType() != RCL_MAP_TYPE) {
    cerr << "ERROR: create_editHashDialog called with a default rcl::exp of type " 
         << def.getType() 
         << "!" << endl << "   That's not a hash!  Give me my corned beef!" << endl;
    return NULL;
  }

  accel_group = gtk_accel_group_new ();

  // Grab the body of the default map
  defbody = def.getMap();

  // Sort vector
  // Don't sort, per Trey's request.  Leave it in the same order as in the config file
  //sort(defbody.begin(), defbody.end(), pair_string_exp_comp);

  // How many config elements are there?
  numElements = defbody.size();

  // Set up window wrapping foo
  editHashDialog = gtk_dialog_new ();
  gtk_object_set_data (GTK_OBJECT (editHashDialog), "editHashDialog", editHashDialog);
  gtk_window_set_title (GTK_WINDOW (editHashDialog), windowName.c_str());
  gtk_window_set_policy (GTK_WINDOW (editHashDialog), TRUE, TRUE, FALSE);
  gtk_window_set_default_size (GTK_WINDOW (editHashDialog), prefs_get_default_config_width(), -1);
  // Does this end up in GdkWindow's user_data???
  gtk_object_set_user_data(GTK_OBJECT(editHashDialog), strdup(windowName.c_str()));

  // VBox to hold all chillun's
  dialog_vbox1 = GTK_DIALOG (editHashDialog)->vbox;
  gtk_object_set_data (GTK_OBJECT (editHashDialog), "dialog_vbox1", dialog_vbox1);
  gtk_container_set_border_width(GTK_CONTAINER(dialog_vbox1), 10);
  gtk_widget_show (dialog_vbox1);

  gridTable = gtk_table_new (numElements, 2, FALSE);
  g_object_ref (gridTable);
  gtk_object_set_data_full (GTK_OBJECT (editHashDialog), "gridTable", gridTable,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_container_set_border_width(GTK_CONTAINER(gridTable), 5);
  gtk_table_set_row_spacings(GTK_TABLE(gridTable), 3);
  gtk_table_set_col_spacings(GTK_TABLE(gridTable), 3);
  gtk_widget_show (gridTable);
  gtk_box_pack_start (GTK_BOX (dialog_vbox1), gridTable, TRUE, TRUE, 0);

  // Store copy of initial config in table's userdata, to allow
  // recovery in case of syntax errors.
  initialConfigCopy = new rcl::exp(h);
  gtk_object_set_user_data(GTK_OBJECT (gridTable), (gpointer) initialConfigCopy);

  int i = 0;
  // ASSUMPTION: The default hash is a superset of the value hash
  FOR_EACH(pr, defbody) {

    ck = pr->first;
    ce = pr->second; // This is the default hash

    // Build label for this element
    widgetName = "label";
    sprintf(suffix, "%d_%s", i, ce.getType().c_str());
    widgetName += suffix;
    
    // A checkbox option has a 'default' of a two-element vector with
    // values 0 and 1.  Whichever is first is the default value.
    isCheckBox = is_checkbox_pref(ce);
    
    elementName = prettify_pref_name(ck);
    elementName += ": ";

    // No examples for check boxes
    if(!isCheckBox) {
      // Add an example, based on the default hash
      if(ce.getType() == "string") {
        example = ce.getString();
      } else {
        example = rcl::toStringCompact(ce);
      }
      if(example.length() > 0) {
        elementName += "\n  ex.: ";
        elementName += example;
      }
    }

    // Maps get a multiline input box, which should expand to fill any
    // available space.  Ditto for stdin_commands, which is a vector.
    GtkAttachOptions yAttachOptions = (GtkAttachOptions) 0;
    if(ce.getType() == RCL_MAP_TYPE
       || ck == "stdin_commands") {
      yAttachOptions = (GtkAttachOptions) (GTK_EXPAND | GTK_FILL);
    }

    label = gtk_label_new (elementName.c_str());
    g_object_ref (label);
    gtk_object_set_data_full (GTK_OBJECT (editHashDialog), widgetName.c_str(), label,
                              (GtkDestroyNotify) gtk_widget_unref);
    gtk_object_set_user_data(GTK_OBJECT(label), NULL);
    gtk_label_set_justify (GTK_LABEL (label), GTK_JUSTIFY_LEFT);
    gtk_misc_set_alignment (GTK_MISC (label), 0, 0.5);
    gtk_table_attach (GTK_TABLE (gridTable), label, 0, 1, i, i+1,
                      (GtkAttachOptions) (GTK_FILL),
                      yAttachOptions, 0, 0); 
   gtk_widget_show (label);

    // We need to keep around the key and the RCL type
    ppd = new ProcessData();
    init_process_data(ppd);
    fill_process_data(ppd, ck.c_str(), ce.getType().c_str(), NULL);

    widgetName = "entry";
    widgetName += suffix;
    // And data entry; depends on type
    if(ce.getType() == RCL_MAP_TYPE
       || ck == "stdin_commands") {
      //GtkWidget* hashText;
      string widTName;
      // We need a text widget in a scrolled window
      entry = gtk_scrolled_window_new(NULL, NULL);
      gtk_scrolled_window_set_policy (GTK_SCROLLED_WINDOW (entry), 
                                      GTK_POLICY_NEVER, GTK_POLICY_ALWAYS);
      gtk_object_set_user_data(GTK_OBJECT(entry), NULL);
      widTName = "hashText";
      widTName += suffix;
      //hashText = gtk_text_buffer(NULL);//gtk_text_new (NULL, NULL);
      //hashText = gtk_text_new (NULL, NULL);
      //g_object_ref (hashText);
      //replace insert with set buffer (for now)
      if(h(ck).defined()) {
        //gtk_text_insert(GTK_TEXT(hashText), NULL, NULL, NULL, 
        //                rcl::toStringConfig(h(ck)).c_str(), -1);
        //gtk_text_buffer_insert(GtkTextBuffer *buffer,
        //                                                 GtkTextIter *iter,
        //                                                 const gchar *text,
        //                                                 gint len);
        //gtk_text_view_set_buffer(GTK_TEXT(hashText),
      } 
      else 
      {
        if(ck == "stdin_commands") 
        {
          //gtk_text_insert(GTK_TEXT(hashText), NULL, NULL, NULL,
          //                "[\n]", -1);
          //gtk_text_view_set_buffer(GTK_TEXT(hashText),
        } 
        else 
        {
          //gtk_text_insert(GTK_TEXT(hashText), NULL, NULL, NULL,
          //                "{\n}", -1);
          //gtk_text_view_set_buffer(GTK_TEXT(hashText),
        }
      }
      //FIXME: find out what to do with hashText and related objects
      //gtk_object_set_data_full (GTK_OBJECT (editHashDialog), widTName.c_str(), 
      //                          hashText,
      //                          (GtkDestroyNotify) gtk_widget_unref);
      // Stick the data in the user_data of the entry object
      //gtk_object_set_user_data(GTK_OBJECT(hashText), (gpointer) ppd);
      //gtk_widget_show (hashText);
      //gtk_container_add (GTK_CONTAINER (entry), hashText);
      //gtk_editable_set_editable(GTK_EDITABLE(hashText), TRUE);
    } else if(isCheckBox) {
      entry = gtk_check_button_new();
      if(h(ck).defined()) {
        if(h(ck).getLong()) {
          gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (entry), TRUE);
        }
      }
      // Stick the data in the user_data of the entry object
      gtk_object_set_user_data(GTK_OBJECT(entry), (gpointer) ppd);
    } else {
      // Entry
      entry = gtk_entry_new();

      if(h(ck).defined()) {      
        string val;
        if(h(ck).getType() == "string")
          val = h(ck).getString();
        else
          val = rcl::toStringCompact(h(ck));
        if(val.length() > 0) {
          gtk_entry_set_text(GTK_ENTRY(entry), val.c_str());
        }
      }
      // Stick the data in the user_data of the entry object
      gtk_object_set_user_data(GTK_OBJECT(entry), (gpointer) ppd);

      // Pressing [Enter] in a one-line entry equates to clicking "OK"
      // Pass in callback as user_data
      gtk_signal_connect (GTK_OBJECT (entry), "activate",
                          G_CALLBACK (on_editHashDialog_okButton_clicked),
                          (void *) userCallback);
      // Intercept keypad-enter's and issue an activate isgnal
      gtk_signal_connect (GTK_OBJECT (entry), "key-press-event",
                          G_CALLBACK (on_editHashDialog_key_press_event),
                          NULL);
    }
    g_object_ref(entry);
    gtk_object_set_data_full (GTK_OBJECT (editHashDialog), widgetName.c_str(), entry,
                              (GtkDestroyNotify) gtk_widget_unref);
    gtk_table_attach (GTK_TABLE (gridTable), entry, 1, 2, i, i+1,
                      (GtkAttachOptions) (GTK_EXPAND | GTK_FILL),
                      yAttachOptions, 0, 0);
    gtk_widget_show (entry);
    
    if(firstEntry == NULL) firstEntry = entry;

    i += 2;
  } // End loop through hash elements

  // Do common setup at end of dialog    
  dialog_action_area1 = GTK_DIALOG (editHashDialog)->action_area;
  gtk_object_set_data (GTK_OBJECT (editHashDialog), "dialog_action_area1", dialog_action_area1);
  gtk_widget_show (dialog_action_area1);
  gtk_container_set_border_width (GTK_CONTAINER (dialog_action_area1), 10);

  hbuttonbox1 = gtk_hbutton_box_new ();
  g_object_ref (hbuttonbox1);
  gtk_object_set_data_full (GTK_OBJECT (editHashDialog), "hbuttonbox1", hbuttonbox1,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (hbuttonbox1);
  gtk_box_pack_start (GTK_BOX (dialog_action_area1), hbuttonbox1, TRUE, TRUE, 0);

  okButton = gtk_button_new_with_label (_("OK"));
  g_object_ref (okButton);
  gtk_object_set_data_full (GTK_OBJECT (editHashDialog), "okButton", okButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  // Stash callback in OK button :)
  gtk_object_set_user_data(GTK_OBJECT(okButton), (void *) userCallback);
  gtk_widget_show (okButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), okButton);
  GTK_WIDGET_SET_FLAGS (okButton, GTK_CAN_DEFAULT);

  cancelButton = gtk_button_new_with_label (_("Cancel"));
  g_object_ref (cancelButton);
  gtk_object_set_data_full (GTK_OBJECT (editHashDialog), "cancelButton", cancelButton,
                            (GtkDestroyNotify) gtk_widget_unref);
  gtk_widget_show (cancelButton);
  gtk_container_add (GTK_CONTAINER (hbuttonbox1), cancelButton);
  GTK_WIDGET_SET_FLAGS (cancelButton, GTK_CAN_DEFAULT);
  gtk_widget_add_accelerator (cancelButton, "clicked", accel_group,
                              GDK_Escape, (GdkModifierType)0,
                              GTK_ACCEL_VISIBLE);

  gtk_signal_connect (GTK_OBJECT (okButton), "clicked",
                      G_CALLBACK (on_editHashDialog_okButton_clicked),
                      NULL /* FILLEMIN: user callback */);
  gtk_signal_connect (GTK_OBJECT (cancelButton), "clicked",
                      G_CALLBACK (on_editHashDialog_cancelButton_clicked),
                      NULL);

  

  gtk_window_add_accel_group (GTK_WINDOW (editHashDialog), accel_group);
  gtk_widget_grab_focus (firstEntry);

  return editHashDialog;
}

void
createAndShow_messageDialog(string message, bool modal) {

  GtkWidget *dialog, *label, *okay_button, *hbox;
   
  /* Create the widgets */
  dialog = gtk_dialog_new();
  label = gtk_label_new (message.c_str());
  okay_button = gtk_button_new_with_label("Okay");
  hbox = gtk_hbox_new(FALSE, 0);

  /* Ensure that the dialog box is destroyed when the user clicks ok. */
  gtk_signal_connect_object (GTK_OBJECT (okay_button), "clicked",
                             G_CALLBACK (gtk_widget_destroy), GTK_OBJECT (dialog));
  gtk_container_add (GTK_CONTAINER (GTK_DIALOG(dialog)->action_area),
                     okay_button);

  /* Add the label, and show everything we've added to the dialog. */
  //gtk_container_add (GTK_CONTAINER (GTK_DIALOG(dialog)->vbox),
  //                   label);
  gtk_box_pack_start (GTK_BOX (hbox),
                      label,
                      TRUE, TRUE, 10);
  
  gtk_box_pack_start (GTK_BOX (GTK_DIALOG (dialog)->vbox),
                      hbox,
                      TRUE, TRUE, 10);

  /* Make it modal if needed */
  if(modal) {
    gtk_window_set_modal (GTK_WINDOW (dialog), modal);
  }

  gtk_widget_show_all (dialog);

  /* Change the taskbar icon */
  add_taskbar_icon (dialog, miniClawImage_xpm);
}

/***************************************************************
 * Revision History:
 * $Log: interface.c,v $
 * Revision 1.50  2007/05/30 19:10:31  brennan
 *  - Fixed GTK warnings on preference editing cancellation, due to
 *    miscasting of checkboxes.
 *
 *  - New preferene: Remember location and size of window
 *
 *  - Improved initial auto-sizing of status/chat buffer
 *
 *  - Increased gutter sizes for pane resizers
 *
 *  - Fixed crash when claw is closed via the window manager
 *
 *  - When initially laying out the window, we now attempt to ensure that
 *    the process window will have enough space, so it's not cut off.
 *
 *  - Stdin and filter entry histories are now remembered across
 *    view/close of a process and quit/start of claw.  Added arg to
 *    specify history filename (defaults to ~/.claw.histories) and prefs
 *    to specify how many history entries to save per process.
 *
 *  - The initial running/exited state of all processes is no longer
 *    printed when claw starts up / daemons initially connect.  Status
 *    changes are still printed.
 *
 * Revision 1.49  2007/02/15 18:37:06  brennan
 * Mapped keypad-enter to activate entries in autogenerated dialogs,
 * such as preferences and process configs.
 *
 * Revision 1.48  2007/02/15 18:07:06  brennan
 * Fixed a few memory leaks, and one rogue pointer bug.
 * Mapped keypad enter to regular enter in stdin and filter entries.
 * Added focus-follows-mouse option.
 *
 * Revision 1.47  2007/01/12 19:42:56  brennan
 *  Added context menu to processWidget's filter entry that allows the
 *  user to enable or diable the filter (in the same way as the checkbox
 *  works), as well as launch a dialog to set the desired context
 *  (e.g. lines before and after a matching line that should be printed
 *  as well).
 *
 *  Hacked around the double-click-required on the signal and regexp
 *  context menus by responding to button-press-event as well as
 *  activate.
 *
 * Revision 1.46  2006/12/20 19:07:18  brennan
 *   We now use checkboxes in createHashDialog (e.g. local preferences)
 *   for elements whose default value is a length-two vector of 0 and 1,
 *   but whose value in the "real" hash is a long.
 *
 *   Turned filtering off by default
 *
 *   Claw now parses the standard X --geometry argument to set the
 *   default size and position of the window.
 *
 *   Moved load/save/edit preferences to a new 'Preferences' menu, and
 *   added all checkbox preferences directly to the menu (they still
 *   also appear in the "edit all preferences" dialog)
 *
 *   Fixed bug in which timestamps appeared multiple times in continued
 *   (>80 char) lines.
 *
 *   Fixed shout/dshout sillyness.
 *
 *   Fixed sysv init script errors.
 *
 *   Added buffer clear/reset option to right-click menus.  Will not add
 *   a button for this.  It was already in the 'Monitoring' menu.
 *
 *   Fixed bug resulting in incorrectly populated right-click menu for a
 *   process viewed in a group when the process' name was a substring of
 *   the group's name.  How's that for obscure bugs? :-)
 *
 *   When stdout filtering is turned on or off (either through the prefs
 *   dialog, or the prefs checkbox menu), immediately toggle filtering on
 *   all active process widgets, rather than waiting until they're
 *   hidden, then viewed.
 *
 *   Fixed localizeSite.sh to point search results to local pages, not
 *   gs295.
 *
 *   Updated dshout/shout to eliminate the username field. (code cleanup)
 *
 *   User's own chat messages are now displayed in green; everything else
 *   is in black.
 *
 *   Widened default filter width; now controlled by SHRUNK_WIDTH
 *   #define in processWidget.c
 *
 *   Just a note: Ctrl+U in a GtkEntry (e.g. stdin or filter) will clear
 *   all text in the entry.
 *
 *   The stdin entry / filter now remain visible when a process is dead,
 *   although stdin is disabled.  This allows the user to change the
 *   filtering and examine filtered output after a process has crashed.
 *   In addition, when a process is not running, clicks on the process
 *   widget focus the filter input.
 *
 *   The filter entry now retains a history, just like the stdin entry,
 *   that can be accessed via the up/down arrow keys.
 *
 *   Added taskbar icons for all dialogs.  For the moment, they're the
 *   same claw image as the main window; we may want to specialize them
 *   later.
 *
 *   Added a checkbox to the right of the filter that allows the user to
 *   enable or disable filtering without changing the filter text.  The
 *   [enter] approach is still supported (and checks the box when
 *   appropriate), and the checkbox is disabled when there is no text in
 *   the entry.
 *
 *   Filter now only goes red only if actual editing has occurred (not
 *   just a keypress).
 *
 *   The stdin entry line for a process widget is now greyed out when
 *   the process is dead.
 *
 *   Added footer pointing to www.microraptor.org to localized site.
 *
 *   Added release version stamp to the title png of the help page (pass
 *   version number as first argument to localizeSite.sh)
 *
 *   Added Help menu, and entry that launches a user-specified browser
 *   pointing at the RPM/APT-installed help pages.  The new preference is
 *   'help_browser'.
 *
 *   The background color of the filter entry now changes based on the
 *   active or editing state.  For reference, one must create a new
 *   GtkStyle and set it in order to override a theme engine set by the
 *   user.  GtkRcStyles do *not* do the trick.
 *
 *   We now set the background color of the 'Chat' tab if a new chat
 *   message comes in while the 'Status' tab is in the foreground.  To
 *   accomplish this, I had to disable user-theming of those two notebook
 *   tabs.
 *
 *   The 'Help' menu is now right-justified
 *
 *   Added an 'About' menu option under 'Help'.  We'll need to update the
 *   image with every release.  It's dismissed via a left-click, [enter],
 *   or [esc].
 *
 *   Fixed focus setup for filter/stdin.  When focus enters the filter or
 *   the stdin, it expands.  Much simpler, and does what we want.
 *
 *   Removed "get status", as it's no longer needed.  Left "Get status
 *   all" as "Refresh all processes' status" in the Monitoring menu,
 *   since there's an offchance you'll want to do that right at the
 *   beginning.
 *
 * Revision 1.45  2006/11/16 18:55:04  brennan
 * Fixed bug where RCL syntax errors in set process config dialogs nuked
 * the contents of the field; the original data is now used and an error
 * message is printed to the common buffer.
 *
 * Added backup kill cmd and kill timeout to process configs.
 *
 * Made process config multiline text boxes expand with the window
 *
 * Added 'stdin_commands' to process configs.  This is a vector, but uses
 * a multiline entry in the config editing dialog.
 *
 * Added dialog during connection to central that allows graphical
 * cancellation in the event of incorrect centralhost designation.
 * Responsiveness is poor, but there's no way around that without hacking
 * IPC directly.
 *
 * Added debugger support to process configs.  Set 'debugger' to 'gdb' to
 * run the process under GDB.  This does not make use of any PATH
 * environment variable: the command must either be absolute, or relative
 * to the working_dir setting for the process.  When the process starts,
 * it will load the arguments, and stop at a gdb prompt to allow the user
 * to set breakpoints, etc.  Just type 'run' to run the process with all
 * of its arguments.  This makes use of Trey's debugger support in the daemon.
 *
 * Added icon for use in the taskbar (16x16; client/imageHeaders/miniClawImage.h)
 *
 * Added 'send signal to process' capability, using new 'signal <sig>
 * <process>' message type.  This is included everywhere run and kill
 * commands are.  Note: the popup menu that comes up when clicking the
 * signal button when viewing a process requires two clicks to select an
 * item.  This is a bug, but I haven't figured it out yet.
 *
 * New mraptord status messages supplant the claw-generated process
 * status messages, and are formatted to display which user issued run,
 * kill, and signal commands.
 *
 * Added client-side regexp filtering of process output.  This is a small
 * 'Filter' entry box in the lower-right of the process window.  Enter a
 * POSIX (e.g. grep -E)-style regexp and press [enter] to filter the
 * stdout.  Clear the entry box and press [enter] to deactivate
 * filtering.  The regexp will be displayed in green when active and
 * black when inactive.  Red denotes a regexp that is being edited while
 * the previous regexp is active.  A tooltip appears explaining this if
 * you hover over the entery box.  The regexp interface can be hidden by
 * setting the client-side preference "stdout_filtering" to 0 or false.
 *
 * Added limited chat support, via a dialog tabbed with the
 * minibuffer/error output.  This uses the new
 * shout/dshout messages.
 * Added graceful support for central crashes: a dialog is displayed to
 * inform the user of the crash, then claw exits.
 *
 * Fixed bug in which hiding, then re-viewing a process didn't fill the
 * buffer with recent output.
 *
 * Fixed newline bug in ClawText that resulted in there always being a
 * blank line at the bottom.
 *
 * Added (optional) timestamping to client output.  This is controlled
 * via the client preferences dialog.
 *
 * Added commandline and preferences option to specify the default width
 * of the configuration dialogs in claw. (--config-width /
 * default_config_width)
 *
 * Revision 1.44  2006/08/11 22:05:37  brennan
 * Committed detection of the BadWindow errors which occur when you ssh -X
 * into an X server with the security extension.  A semi-informative error
 * message is printed, and claw now functions, but right-click menus are
 * funkily placed.  Use ssh -Y instead.
 *
 * Revision 1.43  2005/06/16 04:30:49  brennan
 * Invalid RCL expressions in process config dialogs no longer nuke the
 * contents; instead, the original data is used.  This is especially important
 * for the env hash.  An error message is now also printed to the common
 * buffer.
 *
 * Revision 1.42  2004/11/25 05:20:48  brennan
 * Fixed run-all bug (using a GList* instead of its data)
 *
 * Patched a bunch of memory leaks, and all the nasty ones.  There are four
 * known remaining leaks, all dealing with the widget used to view the output
 * of a process, with a sum total of ~90 bytes leaked per process viewed.
 * Not worth my time at the moment. :-)
 *
 * Revision 1.41  2004/04/28 18:58:50  dom
 * Appended log directive
 * 
 ***************************************************************/
