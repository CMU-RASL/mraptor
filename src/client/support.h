/***** tell emacs we use -*- c++ -*- style comments *****
 * $Revision: 1.52 $ $Author: brennan $ $Date: 2007/05/30 19:10:31 $
 *
 * COPYRIGHT 2004, Carnegie Mellon University 
 *
 * PROJECT: Exploration Robotics (Life in the Atacama)
 *
 * MODULE:
 *
 * FILE: microraptor/client/support.h
 *
 * DESCRIPTION:
 *
 ********************************************************/
/*
 * DO NOT EDIT THIS FILE - it is generated by Glade.
 * Eh, we're done using Glade directly now, so I stuck some support functions
 *  in here. -Brennan
 */

#ifndef __SUPPORT_H__
#define __SUPPORT_H__

#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <X11/Xlib.h>
#include <gtk/gtk.h>
#include <stdio.h>
#include <sys/time.h>
#include <time.h>
#include "mrHashMap.h"
#include "clientComm.h"
#include "processWidget.h"
#include "RCLExp.h"

/*
 * Standard gettext macros.
 */
#ifdef ENABLE_NLS
#  include <libintl.h>
#  undef _
#  define _(String) dgettext (PACKAGE, String)
#  ifdef gettext_noop
#    define N_(String) gettext_noop (String)
#  else
#    define N_(String) (String)
#  endif
#else
#  undef textdomain
#  define textdomain(String) (String)
#  undef gettext
#  define gettext(String) (String)
#  undef dgettext
#  define dgettext(Domain,Message) (Message)
#  undef dcgettext
#  define dcgettext(Domain,Message,Type) (Message)
#  undef bindtextdomain
#  define bindtextdomain(Domain,Directory) (Domain)
#  undef _
#  define _(String) (String)
#  undef N_
#  define N_(String) (String)
#endif

//#ifdef USE_ZVT_TERM
// These use the ANSI color escape sequences:
/*
Color	Foreground	Background
black	30	        40
red	31	        41
green	32	        42
yellow	33	        43
blue	34	        44
magenta	35	        45
cyan	36	        46
white	37	        47
Bold on:             1
Bold off:            0
Term separator:      ;
Sequence terminator: m

Not sure about these:
0	Reset all attributes
1	Bright
2	Dim
4	Underscore	
5	Blink
7	Reverse
8	Hidden

Note that bold make things very hard to read

NOTE: the '^[' is one character, not two.  When adding additional
codes, cut and paste from existing ones.
*/
// Green
//#define mr_good_code (char *)"[32;1m"
//#define mr_good_code (char *)"[42;35m"
#define mr_good_code (char *)"[32m"
// Black / default (turn off bold)
//#define mr_ok_code (char *)"[30;47;0m"
#define mr_ok_code (char *)"[30;0m"
//#define mr_ok_code (char *)"[0m"
// Red; or yellow
#define mr_warning_code (char *)"[31m"
//#define mr_warning_code (char *)"[43;30m"
// Bright red
//#define mr_error_code (char *)"[31;1m"
//#define mr_error_code (char *)"[41;36m"
#define mr_error_code (char *)"[31m"
// Bright blue
#define mr_special_code (char *)"[34m"
//#define mr_special_code (char *)"[44;37m"
// Bright blue
#define mr_stdin_code (char *)"[34m"
// Green
#define mr_status_code (char *)"[32m"
// Magenta
#define mr_action_code (char *)"[35m"
// Green (42) is okay, but a bit dark.  Yellow (43) is more of a burnt orange
// Blue (44) is way too dark.  Okay with a white foreground, but not great.
// Magenta (45) is also kind of dark.
// Cyan's (46) just ugly.  Sigh.
// Noop for now.
#define mr_filter_code (char *)"[30;47;0m"
// White
#define mr_nofilter_code (char *)"[30;47;0m"
//#endif

enum printColors {
  GOOD_COL = 1,
  OK_COL,
  WARNING_COL,
  ERROR_COL,
  SPECIAL_COL,
  STDIN_COL,
  STATUS_COL,
  ACTION_COL,
  FILTER_COL,
  NOFILTER_COL
};

enum groupRunningState {
  ALL_DEAD        = 1 << 0,
  ALL_ALIVE       = 1 << 1,
  DEAD_AND_ALIVE  = 1 << 2
};

enum groupSubState {
  ALL_UNSUB       = 1 << 0,
  ALL_SUB         = 1 << 1,
  SUB_AND_UNSUB   = 1 << 2
};

enum triBool {
  FALSE_TB   = 0,
  TRUE_TB    = 1,
  UNKNOWN_TB = -1,
};

#define FOR_GLIST(walker, list) \
  for (GList* walker = g_list_first(list); \
       walker; walker = g_list_next(walker))


typedef struct _ProcessData   ProcessData;

struct _ProcessData
{
  char* machName;
  char* procName;
  char* status;
};

/* Augmented ProcessData */
typedef struct _ProcessDataAug ProcessDataAug;

struct _ProcessDataAug
{
  char* machName;
  char* procName;
  char* status;
  ProcessWidget* pw;
};

typedef struct _EntryData EntryData;

struct _EntryData
{
  char* label;
  GtkWidget* pw;
  set<GtkCTreeNode*> grpMems; // Pointers to the group member nodes that reference us
};

typedef struct _EntryDataAug EntryDataAug;

struct _EntryDataAug
{
  char* label;
  GtkWidget* pw;
  GtkCTreeNode* realNode;
};

typedef struct _SwitchableChildData SwitchableChildData;

struct _SwitchableChildData
{
  GtkWidget* parent;
  GtkWidget* switchedChild;
};

typedef struct _SwitchableChildDataAug SwitchableChildDataAug;

struct _SwitchableChildDataAug
{
  GtkWidget* parent;
  GtkWidget* switchedChild;
  GtkCTreeNode* grpMemNode;
};

size_t ProcessDataHash(ProcessData pd);

bool ProcessDataEqual(ProcessData a, ProcessData b);

/* Return 0 if they're the same.  Note that you have to set the user data
   of a row before you can search for it. :)  There doesn't appear to be
   a good way to search for a row by what's displayed.
   These are now pointers to EntryData's.
*/
gint rowCompareFunc(gconstpointer a, gconstpointer b);

/* clist :	The GtkCList that is affected.
   ptr1 :	A gconstpointer to the first node to compare.
   ptr2 :	A gconstpointer to the second node to compare.
   Returns :	0 if the nodes are equal, less than 0 if the first node should come 
                before the second, and greater than 1 if the second come before the first.
*/
gint treeCompareFunc(GtkCList *clist, gconstpointer ptr1, gconstpointer ptr2);

// Do _NOT_ change the ordering of this!
enum nodeType {
  PROCESS_TOP_NODE      = 1,
  PROCESS_NODE          = 1 << 1,
  SWALLOWED_TOP_NODE    = 1 << 2,
  SWALLOWED_NODE        = 1 << 3,
  GROUP_TOP_NODE        = 1 << 4,
  GROUP_NODE            = 1 << 5,
  GROUP_MEMBER_NODE     = 1 << 6,
  UNKNOWN_NODE          = 1 << 7,
  ALL_NODES             = 0xFF
};

enum treeTopLevelSortType {
  DAEMONS_FIRST          = 1,
  GROUPS_FIRST           = 1 << 1
};

void print_nodetypes(enum nodeType nt, int tablev = 1);
void print_nodetypes_inline(enum nodeType nt, int tablev = 1);
string stringize_nodetypes(enum nodeType nt, int tablev = 1);

extern microraptor::MR_Comm* daemon_comm_g;
extern rcl::exp local_config_g;
extern string local_config_name_g;
extern GtkWidget* HeadDino_g;
/* Sigh... I hate having this many global variables... */
extern hash_map<string, timeval> clockSkew_g;
extern hash_map<ProcessData, pair<bool, timeval>, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>* subscriptions_g;
extern hash_map<ProcessData, bool, size_t (*)(ProcessData), bool (*)(ProcessData, ProcessData)>* overwrite_g;
extern GtkMenu* popup_menu_g;
extern pair<ProcessWidget*, ProcessData*> popup_menu_info_g;
extern list<string> pending_sets_g;
extern string topWindowName_g;
extern rcl::exp procConfigDefault_g;
extern rcl::exp prefs_g;
extern rcl::exp prefsDefault_g;
extern rcl::exp prefsInitial_g;
extern string prefsFilename_g;
extern Display *root_display_g;
/*
 * Public Functions.
 */
rcl::exp load_local_config(const string& config_file_name);

/* Stores current local config in e */
void get_config(rcl::exp& e);

/* Do all necessary cleanup */
void claw_quit(void);

/*
 * This function returns a widget in a component created by Glade.
 * Call it with the toplevel widget in the component (i.e. a window/dialog),
 * or alternatively any widget in the component, and the name of the widget
 * you want returned.
 */
GtkWidget*  lookup_widget              (GtkWidget       *widget,
                                        const gchar     *widget_name);

/* get_widget() is deprecated. Use lookup_widget instead. */
#define get_widget lookup_widget

/* Use this function to set the directory containing installed pixmaps. */
void        add_pixmap_directory       (const gchar     *directory);


/*
 * Private Functions.
 */

/* This is used to create the pixmaps in the interface. */
GtkWidget*  create_pixmap              (GtkWidget       *widget,
                                        const gchar     *filename);

/* Add a taskbar icon for the window pointed to by the passed widget
 * NOTE: This must be called *after* the window is
 * gtk_widget_show()'n */
void
add_taskbar_icon                       (GtkWidget       *windowWid,
                                        const gchar    **xpm);

/* This returns the ProcessWidget if it's a singleton tab */
GtkWidget*
get_child_of_tab                       (string          targLabel);

void
switch_to_tab                          (string          targLabel);

void
switch_to_tab                          (ProcessData     *pd);

void
free_process_data_list                 (GList          *list,
                                        bool            fullDepth);

void
free_process_data                      (ProcessData    *pd);

void
free_process_data_members              (const ProcessData *pd);

void
print_process_data                     (ProcessData    *pd);

void
print_process_data_aug                 (ProcessDataAug *pda);

void
print_process_data_list                (GList          *list,
                                        bool            augmented);

void
process_data_from_label                (ProcessData    *pd,
                                        const char     *nameLabel,
                                        const char     *statusLabel);

/* Strdup's string elements */
void
pda_to_pda                             (ProcessDataAug *pdDest,
                                        ProcessDataAug *pdaSrc);

/* Calls fill_process_data */
void
pda_to_pd                              (ProcessData    *pdDest,
                                        ProcessDataAug *pdaSrc);

/* Strdup's strings */
void
fill_process_data                      (ProcessData    *pd,
                                        const char     *procName,
                                        const char     *machName,
                                        const char     *status);

/* Calls fill_process_data_shallow */
void
pda_to_pd_shallow                      (ProcessData    *pdDest,
                                        ProcessDataAug *pdaSrc);

/* Copies pointers; doesn't dup */
void
fill_process_data_shallow              (ProcessData    *pd,
                                        char           *procName,
                                        char           *machName,
                                        char           *status);

/* Fill with NULL's */
void
init_process_data                      (ProcessData     *pd);

void
init_process_data_aug                  (ProcessDataAug  *pda);

ProcessData*
copy_process_data                      (ProcessData    *dest,
                                        ProcessData    *src);

string
process_data_to_label                  (ProcessData    *pd);

/* TODO: switch to using ProcessData's everywhere */

int
add_group_display                      (GtkCTreeNode*   grpNode);

void
remove_group_display                   (const char      *grpName);

int
add_process_display                    (GtkWidget       *topWid,
                                        const char      *machName, 
                                        const char      *procName,
                                        const char      *status);
int
remove_process_display                 (GtkWidget       *topWid, 
                                        const char      *machName, 
                                        const char      *procName);

// Add one or more member nodes under a group node
// grpMembers is a space-separated string of the process names of one or more group members
// grpNode is the node in the processTree under which we're adding members
// processTree is, of course, the GtkCTree that displays the process/group/swallowed tree
// Returns true if there was a "-p" in grpMembers; false otherwise
bool add_grp_mem_to_tree               (string grpMembers, 
                                        GtkCTreeNode* grpNode, 
                                        GtkCTree* processTree, 
                                        string grpName = "");

/* Switch to the tab labeled with the contents of pd; if NULL, switch
   to the Overview tab. */
void
switch_to_tab                          (ProcessData     *pd);

bool
tab_exists                             (string          targLabel);

void
get_names_from_node                    (GtkCTree        *processTree,
                                        GtkCTreeNode    *node,
                                        char            **procName,
                                        char            **status,
                                        char            **machName);
/* Fill ProcessData structure given a GtkCTreeNode 
   This is a bit of a duplicate of above.
   This does not dup any data.
*/
bool
fill_process_data_from_treenode        (ProcessData     *pd,
                                        GtkCTreeNode    *node,
                                        GtkCTree        *processTree);

/* Fill ProcessData structure given a ProcessWidget
   (which can be obtained from get_process_widget below,
    if you're trying to retrieve the current status)
    This does not dup any data.
*/
bool
fill_process_data_from_process_widget  (ProcessData     *pd,
                                        ProcessWidget   *pw);

void
remove_swallowed_from_tree               (string           winName);

void
add_swallowed_to_tree                  (string           winName);

enum nodeType
get_nodetype                           (ProcessDataAug  *pda);

enum nodeType
get_nodetype                           (ProcessData     *pd);

enum nodeType
get_nodetype                           (const char      *procName,
                                        const char      *machName);

enum nodeType
get_nodetype                           (GtkCTree        *processTree,
                                        GtkCTreeNode    *node);

/* Get status from processTree */
string
get_status_from_processtree            (const char      *procName,
                                        const char      *machName);

string
get_idle_from_processtree              (const char      *procName,
                                        const char      *machName);

/* processTree: GtkCTree we're picking from
   selectCnt:   number of nodes returned
   targetNodes: bitwise OR'ing of any number of the possible nodeType
                values; the return value will only contain nodes of
                the given type.
*/
GList*
get_multiple_selected_data             (GtkCTree        *processTree,
                                        int             *selectCnt = NULL,
                                        enum nodeType   targetNodeTypes = PROCESS_NODE);

void
get_selected_data                      (GtkCTree        *processTree,
                                        char            **procName,
                                        char            **status,
                                        char            **machName);

/* Returns a GList of ProcessDataAug's 
   This is now completely separate from the char** version.
*/
GList*
get_all_data                           (GtkCTree        *processTree,
                                        enum nodeType    targetTypes);

/* Returns a GList of GtkCTreeNode*'s associated with the nodes
   of the given types and (optionally) with the given procName
*/
GList*
get_all_nodes                          (GtkCTree        *processTree,
                                        int              targetTypes, // OR of elements of enum nodeTypes
                                        const char      *procName = NULL);

void
get_all_data                           (GtkCTree        *processTree,
                                        char            **procName,
                                        char            **status,
                                        char            **machName);


/* Returns node associated with procName process.  This is identical to
   get_node_from_procname, except it doesn't restrict itself to group and
   main process nodes.
*/
GtkCTreeNode*
get_node_from_grp_mem_name                 (const char       *procName,
                                            GtkCTreeNode     *grpNode,
                                            enum nodeType     nodetypes = ALL_NODES);

/* Returns node associated with procName process.
   Returns NULL if no such process exists.
   NOTE: Assumes only one process of a given name exists; the daemon
         also makes this assumption.
   NOTE: Only returns a node that's tagged as either a PROCESS_NODE
         or a GROUP_NODE
*/
GtkCTreeNode*
get_node_from_procname                 (const char      *procName,
                                        GtkCTreeNode    *root = NULL);

GtkCTreeNode*
get_node_from_process_data             (ProcessData     *pd);

/* All strings must have an equal number of space-separated tokens 
*/
GList*
strings_to_glist                       (const char      *processList,
                                        const char      *status,
                                        const char      *machList);

/* Safe version of strcat */
void
safecat                           (char            *dest,
                                   const char      *src,
                                   unsigned int    *buffSize,
                                   bool             addSpace = true);

/* Does not play well if processList and machList don't contain the
   same number of space-separated tokens
   We really should switch to using a GList of ProcessData's...
   (that's what we now do internally)
*/
// WARNING: this doesn't deal well wrt timestamps if handed a list of 
//          processes running on different machines, since we only take
//          one timestamp as input.          
void
print_to_processes                     (const char      *processList = NULL,
                                        const char      *machList = NULL,
                                        const char      *text = NULL,
                                        GtkWidget       *topWid = NULL,
                                        enum printColors pc = ERROR_COL,
                                        timeval         *ts = NULL,
                                        char            lineType = 'x');

// WARNING: this doesn't deal well wrt timestamps if handed a list of 
//          processes running on different machines, since we only take
//          one timestamp as input.          
#ifndef USE_ZVT_TERM
void
print_to_processes                     (const char      *processList = NULL,
                                        const char      *machList = NULL,
                                        const char      *text = NULL,
                                        GtkWidget       *topWid = NULL,
                                        GdkColor        *fgColor = NULL,
                                        timeval         *ts = NULL,
                                        char            lineType = 'x');
#endif

/* Prints string to the common Emacs-style buffer at the bottom of
   the screen, in color fgColor
*/
void
print_to_common_buffer                 (const char      *toprint,
                                        GdkColor        *fgColor);

/* Prints string to the chat buffer at the bottom of
   the screen, in color fgColor
*/
void
print_to_chat_buffer                   (const char      *toprint,
                                        GdkColor        *fgColor);

/* Update skew display in processTree */
void
update_skew_display                    (string          daemon,
                                        string          skew);

void
update_skew_display                    (const char      *daemon,
                                        const char      *skew);

bool
is_accepting_input                     (const char      *status);

bool
is_running                             (const char      *status);


enum groupRunningState
is_group_running                       (ProcessData     *pd);

enum groupSubState
is_group_subscribed                    (ProcessData     *pd);

GdkColor
status_to_color                        (const char      *status);


GdkColor
enum_to_color                          (enum printColors pc);

char*
enum_to_code                           (enum printColors pc);

void
print_to_common_buffer                 (const char        *toprint,
                                        enum printColors pc = OK_COL);

void
print_to_common_buffer                 (string            toprint,
                                        enum printColors pc = OK_COL);

void
print_to_chat_buffer                   (const char        *toprint,
                                        enum printColors pc = OK_COL);

void
print_to_chat_buffer                   (string            toprint,
                                        enum printColors pc = OK_COL);

GtkWidget*
get_process_widget                     (const char      *processName,
                                        const char      *machName);

/* If error is true, pick an image from the "error" set; otherwise
   reset to the microraptor image
*/
void
set_gratuitous_image                   (bool error);

/* Hide or show the stdin text entry widget for a given process */
void
toggle_stdin_entry                     (const char *procName, 
                                        const char *machName,
                                        bool show);
void
toggle_stdin_entry                     (string procName, 
                                        string machName,
                                        bool show);

// This calls the other version of pW_b_s&t, to allow us to call it
//  from within the page_switched handler (i.e. before the page/tab gets
//  "officially" switched)
void
processWidget_button_showandtell       (GtkWidget* pw,
                                        ProcessData* pd,
                                        int curPage);

void
processWidget_button_showandtell       (GtkWidget* pw, 
                                        ProcessData* pd,
                                        triBool grpMemTb = UNKNOWN_TB,
                                        int isOverview = FALSE);

void
swallow_window                         (char* winName, 
                                        Window window);

/* Create a menu for popping up; we'll hide and show individual items
   at runtime.
   pw == ProcessWidget 
 */
GtkMenu*
pw_popup_menu                          (void);

/* Create a submenu for sending signals; if popup_mode is nonzero, use
 * the callbacks that make use of the popup menu.  Otherwise, the
 * signal will go to all selected processes.  If clickHack is TRUE,
 * connect to button-press-events as well; this works around the
 * screwy need-double-click bug. */
GtkWidget*
build_signal_submenu                   (GtkWidget* processTree,
                                        int popup_mode,
                                        gboolean clickHack = FALSE);

// Captialize the first letter, and replace '_' with ' '
string
prettify_pref_name                     (string name);

/* Checks whether the expression is a "checkbox style", that is, a
 * length-two vector containing a 0 and a 1, in either order.  Note
 * that this must be from prefsDefault_g, since prefs_g holds the
 * current value (0 or 1), which is indistinguishable from an
 * arbitrary integer that happens to be 0 or 1.
 */
bool
is_checkbox_pref                       (rcl::exp& e);

int
parse_bool_field                       (string field, 
                                        rcl::exp prefs = prefs_g);

int
prefs_get_back_history_length          (void);

int
prefs_get_stdin_history_length         (void);

int
prefs_get_filter_history_length        (void);

enum treeTopLevelSortType
prefs_get_view_mode                    (void);

int
prefs_get_groups_select_members        (void);

/* Returns 0 if tie_selection_to_tab is 0 or "false";
   1 otherwise */
int
prefs_get_tie_selection_to_tab         (void);

/* Returns 0 if remember_window is 0 or "false";
   1 otherwise */
int
prefs_get_remember_window              (void);

/* Returns 0 if focus_follows_mouse is 0 or "false";
   1 otherwise */
int
prefs_get_focus_follows_mouse          (void);

/* Returns 0 if cool_graphics is 0 or "false";
   1 otherwise */
int
prefs_get_cool_graphics                (void);

/* Returns 0 if clear_on_run is 0 or "false";
   1 otherwise */
int
prefs_get_clear_on_run                 (void);

/* Returns 0 if stdout_filtering is 0 or "false";
   1 otherwise */
int
prefs_get_stdout_filtering             (void);

/* Returns 0 if display_timestamps is 0 or "false";
   1 otherwise */
int
prefs_get_display_timestamps           (void);

int
prefs_get_default_config_width         (void);

/* Return help browser string */
string
prefs_help_browser();

/* Return the initial geometry string, if any. */
string
prefs_initial_window_geometry();

/* Apply a supplied callback to all children of a group node.  The callback
   takes as arguments a machine name and a process name (like the majority of
   the clientIO functions), which are defined as the row data associated with
   the real process node associated with the group member and the row data of
   its parent.  This should translate into the process name and the daemon name,
   respectively.

   Also calls processWidget_showandtell to sync up button states.

*/
void
apply_func_to_grp_members(GtkCTreeNode* grpNode, 
                          GtkCTree* processTree, 
                          bool (*func2) (const char*, const char*),
                          bool (*func3) (const char*, const char*, const char*) = NULL);

/* Strips the leading 'c_' and trailing '_<pid>' from a clientname */
string
strip_client_name(string name);

/* Strips the trailing _<pid> from a machName or a label */
string
strip_pid(string str);

/* Removes all whitespace characters */
string
strip_whitespace(string str);


/* Return prefsFilename_g, or ~/.claw.prefs if it's not set. */
string
get_prefs_file_with_default();

/* Print out a bunch of stuff on a GtkStyle, to help debug GtkEntry
 * background color issues. */
void
print_gtk_style(GtkStyle* style);

void gtk_widget_set_font (GtkWidget *widget, const char *font);

#endif /* __SUPPORT_H__ */

/***************************************************************
 * Revision History:
 * $Log: support.h,v $
 * Revision 1.52  2007/05/30 19:10:31  brennan
 *  - Fixed GTK warnings on preference editing cancellation, due to
 *    miscasting of checkboxes.
 *
 *  - New preferene: Remember location and size of window
 *
 *  - Improved initial auto-sizing of status/chat buffer
 *
 *  - Increased gutter sizes for pane resizers
 *
 *  - Fixed crash when claw is closed via the window manager
 *
 *  - When initially laying out the window, we now attempt to ensure that
 *    the process window will have enough space, so it's not cut off.
 *
 *  - Stdin and filter entry histories are now remembered across
 *    view/close of a process and quit/start of claw.  Added arg to
 *    specify history filename (defaults to ~/.claw.histories) and prefs
 *    to specify how many history entries to save per process.
 *
 *  - The initial running/exited state of all processes is no longer
 *    printed when claw starts up / daemons initially connect.  Status
 *    changes are still printed.
 *
 * Revision 1.51  2007/02/15 18:07:07  brennan
 * Fixed a few memory leaks, and one rogue pointer bug.
 * Mapped keypad enter to regular enter in stdin and filter entries.
 * Added focus-follows-mouse option.
 *
 * Revision 1.50  2007/01/12 19:42:56  brennan
 *  Added context menu to processWidget's filter entry that allows the
 *  user to enable or diable the filter (in the same way as the checkbox
 *  works), as well as launch a dialog to set the desired context
 *  (e.g. lines before and after a matching line that should be printed
 *  as well).
 *
 *  Hacked around the double-click-required on the signal and regexp
 *  context menus by responding to button-press-event as well as
 *  activate.
 *
 * Revision 1.49  2006/12/20 19:07:19  brennan
 *   We now use checkboxes in createHashDialog (e.g. local preferences)
 *   for elements whose default value is a length-two vector of 0 and 1,
 *   but whose value in the "real" hash is a long.
 *
 *   Turned filtering off by default
 *
 *   Claw now parses the standard X --geometry argument to set the
 *   default size and position of the window.
 *
 *   Moved load/save/edit preferences to a new 'Preferences' menu, and
 *   added all checkbox preferences directly to the menu (they still
 *   also appear in the "edit all preferences" dialog)
 *
 *   Fixed bug in which timestamps appeared multiple times in continued
 *   (>80 char) lines.
 *
 *   Fixed shout/dshout sillyness.
 *
 *   Fixed sysv init script errors.
 *
 *   Added buffer clear/reset option to right-click menus.  Will not add
 *   a button for this.  It was already in the 'Monitoring' menu.
 *
 *   Fixed bug resulting in incorrectly populated right-click menu for a
 *   process viewed in a group when the process' name was a substring of
 *   the group's name.  How's that for obscure bugs? :-)
 *
 *   When stdout filtering is turned on or off (either through the prefs
 *   dialog, or the prefs checkbox menu), immediately toggle filtering on
 *   all active process widgets, rather than waiting until they're
 *   hidden, then viewed.
 *
 *   Fixed localizeSite.sh to point search results to local pages, not
 *   gs295.
 *
 *   Updated dshout/shout to eliminate the username field. (code cleanup)
 *
 *   User's own chat messages are now displayed in green; everything else
 *   is in black.
 *
 *   Widened default filter width; now controlled by SHRUNK_WIDTH
 *   #define in processWidget.c
 *
 *   Just a note: Ctrl+U in a GtkEntry (e.g. stdin or filter) will clear
 *   all text in the entry.
 *
 *   The stdin entry / filter now remain visible when a process is dead,
 *   although stdin is disabled.  This allows the user to change the
 *   filtering and examine filtered output after a process has crashed.
 *   In addition, when a process is not running, clicks on the process
 *   widget focus the filter input.
 *
 *   The filter entry now retains a history, just like the stdin entry,
 *   that can be accessed via the up/down arrow keys.
 *
 *   Added taskbar icons for all dialogs.  For the moment, they're the
 *   same claw image as the main window; we may want to specialize them
 *   later.
 *
 *   Added a checkbox to the right of the filter that allows the user to
 *   enable or disable filtering without changing the filter text.  The
 *   [enter] approach is still supported (and checks the box when
 *   appropriate), and the checkbox is disabled when there is no text in
 *   the entry.
 *
 *   Filter now only goes red only if actual editing has occurred (not
 *   just a keypress).
 *
 *   The stdin entry line for a process widget is now greyed out when
 *   the process is dead.
 *
 *   Added footer pointing to www.microraptor.org to localized site.
 *
 *   Added release version stamp to the title png of the help page (pass
 *   version number as first argument to localizeSite.sh)
 *
 *   Added Help menu, and entry that launches a user-specified browser
 *   pointing at the RPM/APT-installed help pages.  The new preference is
 *   'help_browser'.
 *
 *   The background color of the filter entry now changes based on the
 *   active or editing state.  For reference, one must create a new
 *   GtkStyle and set it in order to override a theme engine set by the
 *   user.  GtkRcStyles do *not* do the trick.
 *
 *   We now set the background color of the 'Chat' tab if a new chat
 *   message comes in while the 'Status' tab is in the foreground.  To
 *   accomplish this, I had to disable user-theming of those two notebook
 *   tabs.
 *
 *   The 'Help' menu is now right-justified
 *
 *   Added an 'About' menu option under 'Help'.  We'll need to update the
 *   image with every release.  It's dismissed via a left-click, [enter],
 *   or [esc].
 *
 *   Fixed focus setup for filter/stdin.  When focus enters the filter or
 *   the stdin, it expands.  Much simpler, and does what we want.
 *
 *   Removed "get status", as it's no longer needed.  Left "Get status
 *   all" as "Refresh all processes' status" in the Monitoring menu,
 *   since there's an offchance you'll want to do that right at the
 *   beginning.
 *
 * Revision 1.48  2006/11/16 22:50:31  brennan
 * Made config window default wider (800 pixels).
 *
 * Fixed one echo of client shout per daemon bug.
 *
 * Make filter entry widget expand when it has focus, and vice-versa
 *
 * Claw preferences are auto-saved on exit to the last loaded file, or
 * the default (~/.claw.prefs) otherwise.
 *
 * Preferences load/save dialog is filled with .claw.prefs if no
 * existing prefs file is loaded.
 *
 * Revision 1.47  2006/11/16 18:55:04  brennan
 * Fixed bug where RCL syntax errors in set process config dialogs nuked
 * the contents of the field; the original data is now used and an error
 * message is printed to the common buffer.
 *
 * Added backup kill cmd and kill timeout to process configs.
 *
 * Made process config multiline text boxes expand with the window
 *
 * Added 'stdin_commands' to process configs.  This is a vector, but uses
 * a multiline entry in the config editing dialog.
 *
 * Added dialog during connection to central that allows graphical
 * cancellation in the event of incorrect centralhost designation.
 * Responsiveness is poor, but there's no way around that without hacking
 * IPC directly.
 *
 * Added debugger support to process configs.  Set 'debugger' to 'gdb' to
 * run the process under GDB.  This does not make use of any PATH
 * environment variable: the command must either be absolute, or relative
 * to the working_dir setting for the process.  When the process starts,
 * it will load the arguments, and stop at a gdb prompt to allow the user
 * to set breakpoints, etc.  Just type 'run' to run the process with all
 * of its arguments.  This makes use of Trey's debugger support in the daemon.
 *
 * Added icon for use in the taskbar (16x16; client/imageHeaders/miniClawImage.h)
 *
 * Added 'send signal to process' capability, using new 'signal <sig>
 * <process>' message type.  This is included everywhere run and kill
 * commands are.  Note: the popup menu that comes up when clicking the
 * signal button when viewing a process requires two clicks to select an
 * item.  This is a bug, but I haven't figured it out yet.
 *
 * New mraptord status messages supplant the claw-generated process
 * status messages, and are formatted to display which user issued run,
 * kill, and signal commands.
 *
 * Added client-side regexp filtering of process output.  This is a small
 * 'Filter' entry box in the lower-right of the process window.  Enter a
 * POSIX (e.g. grep -E)-style regexp and press [enter] to filter the
 * stdout.  Clear the entry box and press [enter] to deactivate
 * filtering.  The regexp will be displayed in green when active and
 * black when inactive.  Red denotes a regexp that is being edited while
 * the previous regexp is active.  A tooltip appears explaining this if
 * you hover over the entery box.  The regexp interface can be hidden by
 * setting the client-side preference "stdout_filtering" to 0 or false.
 *
 * Added limited chat support, via a dialog tabbed with the
 * minibuffer/error output.  This uses the new
 * shout/dshout messages.
 * Added graceful support for central crashes: a dialog is displayed to
 * inform the user of the crash, then claw exits.
 *
 * Fixed bug in which hiding, then re-viewing a process didn't fill the
 * buffer with recent output.
 *
 * Fixed newline bug in ClawText that resulted in there always being a
 * blank line at the bottom.
 *
 * Added (optional) timestamping to client output.  This is controlled
 * via the client preferences dialog.
 *
 * Added commandline and preferences option to specify the default width
 * of the configuration dialogs in claw. (--config-width /
 * default_config_width)
 *
 * Revision 1.46  2004/11/25 05:20:48  brennan
 * Fixed run-all bug (using a GList* instead of its data)
 *
 * Patched a bunch of memory leaks, and all the nasty ones.  There are four
 * known remaining leaks, all dealing with the widget used to view the output
 * of a process, with a sum total of ~90 bytes leaked per process viewed.
 * Not worth my time at the moment. :-)
 *
 * Revision 1.45  2004/11/17 22:29:22  trey
 * modified mr_ok_code to explicitly restore fore and background colors in addition to clearing bold
 *
 * Revision 1.44  2004/04/28 18:58:50  dom
 * Appended log directive
 * 
 ***************************************************************/
